--- /dev/null	2026-01-13 23:10:59
+++ atos_core/conversation_loop_v102.py	2026-01-13 23:08:10
@@ -0,0 +1,3943 @@
+from __future__ import annotations
+
+import hashlib
+import json
+import os
+from typing import Any, Dict, List, Optional, Sequence, Tuple
+
+from .act import canonical_json_dumps, deterministic_iso, sha256_hex
+from .conversation_actions_v90 import action_concepts_for_dsl_v90
+from .conversation_objectives_v90 import COMM_OBJECTIVES_V90, comm_objective_ids_v90, make_comm_objective_eq_text_v90
+from .conversation_v96 import (
+    BeliefEventV96,
+    BeliefItemV96,
+    ConversationStateV96,
+    MemoryEventV96,
+    MemoryItemV96,
+    TurnV96,
+    append_chained_jsonl_v96,
+    action_plan_id_v96,
+    belief_event_id_v96,
+    belief_event_sig_v96,
+    compute_belief_chain_hash_v96,
+    compute_learned_chain_hash_v96,
+    compute_memory_chain_hash_v96,
+    compute_parse_chain_hash_v96,
+    compute_plan_chain_hash_v96,
+    compute_state_chain_hash_v96,
+    compute_transcript_hash_v96,
+    normalize_text_v96,
+    render_belief_added_ack_text_v96,
+    render_belief_retracted_ack_text_v96,
+    render_belief_revised_ack_text_v96,
+    render_beliefs_text_v96,
+    render_forget_ack_text_v96,
+    render_note_ack_text_v96,
+    render_recall_text_v96,
+    text_sig_v96,
+    verify_chained_jsonl_v96,
+)
+from .conversation_v97 import make_system_spec_v97, render_system_text_v97
+from .conversation_v98 import (
+    EvidenceEventV98,
+    EvidenceItemV98,
+    compute_evidence_chain_hash_v98,
+    render_evidence_added_ack_text_v98,
+    render_evidences_text_v98,
+    render_versions_text_v98,
+    render_why_belief_text_v98,
+)
+from .conversation_v99 import compute_goal_chain_hash_v99, render_auto_text_v99, render_goal_added_ack_text_v99, render_goal_done_ack_text_v99, render_goals_text_v99, render_next_text_v99
+from .conversation_v100 import render_explain_text_v100
+from .conversation_v101 import (
+    render_bindings_text_v101,
+    render_explain_binding_text_v101,
+    render_trace_ref_text_v101,
+)
+from .conversation_v102 import verify_conversation_chain_v102
+from .binding_ledger_v101 import (
+    binding_chain_hash_v101,
+    binding_snapshot_v101,
+    choose_prune_candidate_v101,
+    make_binding_ambiguous_event_v101,
+    make_binding_create_event_v101,
+    make_binding_miss_event_v101,
+    make_binding_prune_event_v101,
+    make_binding_resolve_event_v101,
+)
+from .bindings_v101 import infer_kind_hint_v101, resolve_reference_v101
+from .discourse_ledger_v100 import DiscourseEventV100, compute_discourse_chain_hash_v100, generate_text_candidates_v100, render_discourse_text_v100, render_dossier_text_v100, sha256_text_v100
+from .engine_v80 import EngineV80
+from .fragment_library_v100 import (
+    FragmentEventV100,
+    base_fragments_v100,
+    compute_fragment_chain_hash_v100,
+    fold_fragment_library_v100,
+    fragment_library_snapshot_v100,
+    fragment_should_promote_v100,
+)
+from .goal_ledger_v99 import GoalEventV99, fold_goal_ledger_v99, goal_id_v99, goal_ledger_snapshot_v99
+from .goal_supports_v89 import SupportClaimV89, fold_support_stats_v89, list_supporting_concepts_for_goal_v89, make_goal_support_evidence_event_v89
+from .intent_grammar_v92 import (
+    INTENT_ADD_V92,
+    INTENT_COMPOUND_V92,
+    INTENT_END_V92,
+    INTENT_GET_V92,
+    INTENT_SET_V92,
+    INTENT_SUMMARY_V92,
+    INTENT_UNKNOWN_V92,
+    default_intent_rule_acts_v92,
+    default_intent_rules_v92,
+    grammar_hash_v92,
+    intent_grammar_snapshot_v92,
+    parse_intent_v92,
+)
+from .intent_grammar_v93 import (
+    INTENT_TEACH_V93,
+    IntentRuleV93,
+    canonize_lhs_for_learned_rule_v93,
+    is_teach_command_v93,
+    make_learned_intent_rule_v93,
+    parse_teach_command_v93,
+)
+from .intent_grammar_v94 import INTENT_EXPLAIN_V94, is_explain_command_v94, parse_explain_command_v94
+from .intent_grammar_v98 import (
+    INTENT_DOSSIER_V98,
+    INTENT_EVIDENCE_ADD_V98,
+    INTENT_EVIDENCE_LIST_V98,
+    INTENT_SYSTEM_V98,
+    INTENT_VERSIONS_V98,
+    INTENT_WHY_V98,
+    is_dossier_command_v98,
+    is_evidence_add_command_v98,
+    is_evidences_list_command_v98,
+    is_system_command_v98,
+    is_versions_command_v98,
+    is_why_command_v98,
+    parse_dossier_command_v98,
+    parse_evidence_add_command_v98,
+    parse_evidences_list_command_v98,
+    parse_system_command_v98,
+    parse_versions_command_v98,
+    parse_why_command_v98,
+)
+from .intent_grammar_v99 import (
+    INTENT_GOAL_ADD_V99,
+    INTENT_GOAL_AUTO_V99,
+    INTENT_GOAL_DONE_V99,
+    INTENT_GOAL_LIST_V99,
+    INTENT_GOAL_NEXT_V99,
+    is_auto_command_v99,
+    is_done_command_v99,
+    is_goal_add_command_v99,
+    is_goals_list_command_v99,
+    is_next_command_v99,
+    parse_auto_command_v99,
+    parse_done_command_v99,
+    parse_goal_add_command_v99,
+    parse_goals_list_command_v99,
+    parse_next_command_v99,
+)
+from .intent_grammar_v100 import (
+    INTENT_DISCOURSE_V100,
+    INTENT_WHY_REF_V100,
+    is_discourse_command_v100,
+    is_why_ref_command_v100,
+    parse_discourse_command_v100,
+    parse_why_ref_command_v100,
+)
+from .intent_grammar_v101 import (
+    INTENT_BINDINGS_LIST_V101,
+    INTENT_EXPLAIN_BINDING_V101,
+    INTENT_GOAL_PRIORITY_HIGH_REF_V101,
+    INTENT_PLAN_CREATE_V101,
+    INTENT_PLAN_SHORTEN_REF_V101,
+    INTENT_TRACE_REF_V101,
+    is_bindings_command_v101,
+    is_explain_binding_command_v101,
+    is_plan_create_3_command_v101,
+    is_priority_high_ref_command_v101,
+    is_shorten_ref_command_v101,
+    is_trace_ref_command_v101,
+    parse_bindings_command_v101,
+    parse_explain_binding_command_v101,
+    parse_plan_create_3_command_v101,
+    parse_priority_high_ref_command_v101,
+    parse_shorten_ref_command_v101,
+    parse_trace_ref_command_v101,
+)
+from .intent_grammar_v102 import (
+    INTENT_EXPLAIN_STYLE_V102,
+    INTENT_STYLE_PROFILE_V102,
+    INTENT_TEMPLATES_V102,
+    INTENT_TRACE_STYLE_V102,
+    is_explain_style_command_v102,
+    is_style_profile_command_v102,
+    is_templates_command_v102,
+    is_trace_style_command_v102,
+    parse_explain_style_command_v102,
+    parse_style_profile_command_v102,
+    parse_templates_command_v102,
+    parse_trace_style_command_v102,
+)
+from .intent_grammar_v96 import (
+    INTENT_BELIEF_ADD_V96,
+    INTENT_BELIEF_FORGET_V96,
+    INTENT_BELIEF_LIST_V96,
+    INTENT_BELIEF_REVISE_V96,
+    INTENT_FORGET_V96,
+    INTENT_NOTE_V96,
+    INTENT_RECALL_V96,
+    is_belief_add_command_v96,
+    is_belief_revise_command_v96,
+    is_beliefs_list_command_v96,
+    is_forget_command_v96,
+    is_note_command_v96,
+    is_recall_command_v96,
+    parse_belief_add_command_v96,
+    parse_belief_revise_command_v96,
+    parse_beliefs_list_command_v96,
+    parse_forget_command_v96,
+    parse_note_command_v96,
+    parse_recall_command_v96,
+)
+from .objective_v88 import execute_objective_csv_v88
+from .store import ActStore
+from .discourse_templates_v102 import base_templates_v102, render_templates_list_text_v102
+from .style_ledger_v102 import StyleEventV102, compute_style_chain_hash_v102, fold_template_stats_v102, template_library_snapshot_v102
+from .style_profile_v102 import StyleProfileV102, coerce_style_profile_v102, default_style_profile_v102, derive_style_profile_update_v102, render_style_profile_text_v102
+from .style_selector_v102 import build_and_select_style_candidates_v102
+
+
+def _fail(msg: str) -> None:
+    raise ValueError(msg)
+
+
+def ensure_absent(path: str) -> None:
+    if os.path.exists(path):
+        _fail(f"path_exists:{path}")
+
+
+def sha256_file(path: str) -> str:
+    h = hashlib.sha256()
+    with open(path, "rb") as f:
+        while True:
+            b = f.read(1024 * 1024)
+            if not b:
+                break
+            h.update(b)
+    return h.hexdigest()
+
+
+def _stable_hash_obj(obj: Any) -> str:
+    return sha256_hex(canonical_json_dumps(obj).encode("utf-8"))
+
+
+def _round6(x: Any) -> float:
+    try:
+        return float(round(float(x), 6))
+    except Exception:
+        return 0.0
+
+
+def _deepcopy_json_obj(obj: Any) -> Any:
+    return json.loads(canonical_json_dumps(obj))
+
+
+def _rank_action_candidates_v96(
+    *,
+    candidates: Sequence[Tuple[str, SupportClaimV89]],
+    events: Sequence[Dict[str, Any]],
+    goal_id: str,
+) -> List[Tuple[str, SupportClaimV89, float, float]]:
+    scored: List[Tuple[str, SupportClaimV89, float, float]] = []
+    for act_id, claim in candidates:
+        stats = fold_support_stats_v89(events=events, goal_id=str(goal_id), concept_key=str(act_id), claim=claim)
+        scored.append((str(act_id), claim, float(stats.expected_success), float(stats.expected_cost)))
+    scored.sort(key=lambda t: (-float(t[2]), float(t[3]), str(t[0])))
+    return scored
+
+
+def _is_int_literal(s: str) -> bool:
+    ss = str(s or "")
+    return bool(ss) and ss.isdigit()
+
+
+def _parse_int_or_var(*, vars_map: Dict[str, Any], tok: str, last_answer: Any) -> Tuple[Optional[int], str]:
+    t = str(tok or "")
+    if _is_int_literal(t):
+        return int(t), "ok"
+    if t == "last_answer":
+        try:
+            return int(last_answer), "ok"
+        except Exception:
+            return None, "missing_last_answer"
+    if t in vars_map:
+        try:
+            return int(vars_map.get(t)), "ok"
+        except Exception:
+            return None, "bad_var_type"
+    return None, "missing_key"
+
+
+def _summarize_bindings_v96(*, vars_map: Dict[str, Any], last_answer: Any) -> str:
+    parts: List[str] = []
+    for k in sorted(vars_map.keys(), key=str):
+        parts.append(f"{k}={vars_map.get(k)}")
+    if last_answer != "":
+        parts.append(f"last_answer={last_answer}")
+    inner = "; ".join(parts)
+    return f"Resumo: {inner}".rstrip()
+
+
+def _simulate_compound_execution_v96(
+    *, parse: Dict[str, Any], vars_map: Dict[str, Any], last_answer: Any, beliefs_by_key: Dict[str, Dict[str, Any]]
+) -> Tuple[bool, str, Dict[str, Any]]:
+    segs = parse.get("segments") if isinstance(parse.get("segments"), list) else []
+    cur_vars = dict(vars_map)
+    cur_last = last_answer
+    lines: List[str] = []
+    stop_after = False
+
+    for seg in segs:
+        if not isinstance(seg, dict):
+            return False, "", {"reason": "segment_not_dict"}
+        sp = seg.get("segment_parse") if isinstance(seg.get("segment_parse"), dict) else {}
+        intent_id = str(sp.get("intent_id") or "")
+        slots = sp.get("slots") if isinstance(sp.get("slots"), dict) else {}
+
+        if intent_id == INTENT_SET_V92:
+            k = str(slots.get("k") or "")
+            v = str(slots.get("v") or "")
+            if not k or not v:
+                return False, "", {"reason": "segment_missing_slot", "missing_slot": "k/v"}
+            cur_vars[k] = int(v) if _is_int_literal(v) else v
+            lines.append(f"OK: {k}={v}")
+            continue
+
+        if intent_id == INTENT_GET_V92:
+            k = str(slots.get("k") or "")
+            if not k:
+                return False, "", {"reason": "segment_missing_key", "missing_key": k}
+            if k in cur_vars:
+                lines.append(f"{k}={cur_vars.get(k)}")
+                continue
+            if k in beliefs_by_key:
+                bv = beliefs_by_key.get(k) if isinstance(beliefs_by_key.get(k), dict) else {}
+                lines.append(f"{k}={bv.get('belief_value')}")
+                continue
+            return False, "", {"reason": "segment_missing_key", "missing_key": k}
+
+        if intent_id == INTENT_ADD_V92:
+            a = str(slots.get("a") or "")
+            b = str(slots.get("b") or "")
+            va, ra = _parse_int_or_var(vars_map=cur_vars, tok=a, last_answer=cur_last)
+            if va is None:
+                return False, "", {"reason": "segment_missing_key", "missing_key": a, "detail": ra}
+            vb, rb = _parse_int_or_var(vars_map=cur_vars, tok=b, last_answer=cur_last)
+            if vb is None:
+                return False, "", {"reason": "segment_missing_key", "missing_key": b, "detail": rb}
+            s = int(va) + int(vb)
+            cur_last = int(s)
+            lines.append(f"SUM={s}")
+            continue
+
+        if intent_id == INTENT_SUMMARY_V92:
+            lines.append(_summarize_bindings_v96(vars_map=cur_vars, last_answer=cur_last))
+            continue
+
+        if intent_id == INTENT_END_V92:
+            lines.append("Encerrado.")
+            stop_after = True
+            break
+
+        return False, "", {"reason": "segment_intent_unsupported", "intent_id": intent_id}
+
+    agg = "\n".join(lines)
+    return True, str(agg), {"vars_map": dict(cur_vars), "last_answer": cur_last, "stop_after": bool(stop_after)}
+
+
+def _choose_comm_objective_v96(
+    *, parse: Dict[str, Any], vars_map: Dict[str, Any], last_answer: Any, beliefs_by_key: Dict[str, Dict[str, Any]]
+) -> Tuple[str, Dict[str, Any]]:
+    intent_id = str(parse.get("intent_id") or "")
+    slots = parse.get("slots") if isinstance(parse.get("slots"), dict) else {}
+    missing = parse.get("missing_slots") if isinstance(parse.get("missing_slots"), list) else []
+    if str(intent_id) == INTENT_UNKNOWN_V92:
+        return "COMM_CORRECT", {"reason": "unknown_intent"}
+    if missing:
+        missing_slot = str(missing[0])
+        return "COMM_ASK_CLARIFY", {"missing_slot": missing_slot}
+    if intent_id == INTENT_SUMMARY_V92:
+        return "COMM_SUMMARIZE", {}
+    if intent_id == INTENT_END_V92:
+        return "COMM_END", {}
+    if intent_id == INTENT_GET_V92:
+        k = str(slots.get("k") or "")
+        if not k:
+            return "COMM_ASK_CLARIFY", {"missing_slot": "k"}
+        if k in vars_map:
+            return "COMM_RESPOND", {}
+        if k in beliefs_by_key:
+            return "COMM_RESPOND", {"belief_key": k}
+        return "COMM_ASK_CLARIFY", {"missing_key": k}
+    if intent_id == INTENT_SET_V92:
+        return "COMM_RESPOND", {}
+    if intent_id == INTENT_ADD_V92:
+        a = str(slots.get("a") or "")
+        b = str(slots.get("b") or "")
+        va, _ra = _parse_int_or_var(vars_map=vars_map, tok=a, last_answer=last_answer)
+        if va is None:
+            return "COMM_ASK_CLARIFY", {"missing_key": a}
+        vb, _rb = _parse_int_or_var(vars_map=vars_map, tok=b, last_answer=last_answer)
+        if vb is None:
+            return "COMM_ASK_CLARIFY", {"missing_key": b}
+        return "COMM_RESPOND", {}
+    return "COMM_CORRECT", {"reason": f"unsupported_intent:{intent_id}"}
+
+
+def _build_expected_and_action_inputs_v96(
+    *,
+    objective_kind: str,
+    parse: Dict[str, Any],
+    vars_map: Dict[str, Any],
+    last_answer: Any,
+    beliefs_by_key: Dict[str, Dict[str, Any]],
+    ctx: Dict[str, Any],
+    user_text: str,
+) -> Tuple[str, Dict[str, Any], str]:
+    intent_id = str(parse.get("intent_id") or "")
+    slots = parse.get("slots") if isinstance(parse.get("slots"), dict) else {}
+
+    if intent_id == INTENT_TEACH_V93:
+        if bool(parse.get("teach_ok", False)):
+            text = str(ctx.get("teach_ack_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        if str(parse.get("reason") or "") == "ambiguous":
+            amb = ctx.get("ambiguous")
+            amb_list = amb if isinstance(amb, list) else []
+            opts: List[str] = []
+            for x in amb_list:
+                if not isinstance(x, dict):
+                    continue
+                rid = str(x.get("rule_id") or "")
+                iid = str(x.get("intent_id") or "")
+                if rid and iid:
+                    opts.append(f"{rid}:{iid}")
+            opts = sorted(set(opts))
+            text = "Confirme: " + "; ".join(opts) if opts else "Confirme."
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_STYLE_PROFILE_V102:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("style_profile_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_TEMPLATES_V102:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("templates_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_EXPLAIN_STYLE_V102:
+        if bool(parse.get("parse_ok", False)) and str(ctx.get("explain_style_text") or ""):
+            text = str(ctx.get("explain_style_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or str(parse.get("reason") or ""))
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_TRACE_STYLE_V102:
+        if bool(parse.get("parse_ok", False)) and str(ctx.get("trace_style_text") or ""):
+            text = str(ctx.get("trace_style_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or str(parse.get("reason") or ""))
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_BINDINGS_LIST_V101:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("bindings_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_EXPLAIN_BINDING_V101:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("binding_explain_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_TRACE_REF_V101:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("trace_ref_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id in {INTENT_PLAN_CREATE_V101, INTENT_PLAN_SHORTEN_REF_V101}:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("plan_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_GOAL_PRIORITY_HIGH_REF_V101:
+        if bool(parse.get("parse_ok", False)) and str(ctx.get("msg") or ""):
+            text = str(ctx.get("msg") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_EXPLAIN_V94:
+        if bool(parse.get("parse_ok", False)) and str(parse.get("explained_plan_id") or ""):
+            text = str(ctx.get("explain_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_SYSTEM_V98:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("system_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_DISCOURSE_V100:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("discourse_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_WHY_REF_V100:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("why_ref_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_EVIDENCE_ADD_V98:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("evidence_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_EVIDENCE_LIST_V98:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("evidences_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_WHY_V98:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("why_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_VERSIONS_V98:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("versions_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_DOSSIER_V98:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("dossier_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_GOAL_ADD_V99:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("goal_ack_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_GOAL_LIST_V99:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("goals_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_GOAL_DONE_V99:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("goal_done_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_GOAL_NEXT_V99:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("next_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_GOAL_AUTO_V99:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("auto_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_NOTE_V96:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("note_ack_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_RECALL_V96:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("recall_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id == INTENT_FORGET_V96:
+        if bool(parse.get("parse_ok", False)) and str(ctx.get("forget_ack_text") or ""):
+            text = str(ctx.get("forget_ack_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    if intent_id in {INTENT_BELIEF_ADD_V96, INTENT_BELIEF_REVISE_V96, INTENT_BELIEF_LIST_V96, INTENT_BELIEF_FORGET_V96}:
+        if bool(parse.get("parse_ok", False)):
+            text = str(ctx.get("belief_text") or ctx.get("belief_ack_text") or "")
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        msg = str(ctx.get("msg") or "")
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+
+    # V102: explicit style ack (meta-instruction processed without mutating vars).
+    if str(ctx.get("style_ack_text") or ""):
+        text = str(ctx.get("style_ack_text") or "")
+        return text, {"text": text}, "concept_v90_emit_text_v0"
+
+    if bool(ctx.get("compound", False)) and objective_kind == "COMM_RESPOND":
+        text = str(ctx.get("compound_text") or "")
+        return text, {"text": text}, "concept_v90_emit_text_v0"
+
+    if objective_kind == "COMM_END":
+        return "Encerrado.", {}, "concept_v90_end_conversation_v0"
+    if objective_kind == "COMM_ADMIT_UNKNOWN":
+        return "Não sei.", {}, "concept_v90_admit_unknown_v0"
+    if objective_kind == "COMM_CORRECT":
+        msg = normalize_text_v96(str(user_text))
+        return f"Comando inválido: {msg}", {"msg": msg}, "concept_v90_correct_user_v0"
+    if objective_kind == "COMM_CONFIRM":
+        ctext = str(ctx.get("confirm_text") or ctx.get("msg") or "")
+        if ctext:
+            return str(ctext), {"text": str(ctext)}, "concept_v90_emit_text_v0"
+        amb = ctx.get("ambiguous")
+        amb_list = amb if isinstance(amb, list) else []
+        opts2: List[str] = []
+        for x in amb_list:
+            if not isinstance(x, dict):
+                continue
+            rid = str(x.get("rule_id") or "")
+            iid = str(x.get("intent_id") or "")
+            if rid and iid:
+                opts2.append(f"{rid}:{iid}")
+        opts2 = sorted(set(opts2))
+        text = "Confirme: " + "; ".join(opts2) if opts2 else "Confirme."
+        return text, {"text": text}, "concept_v90_emit_text_v0"
+    if objective_kind == "COMM_SUMMARIZE":
+        summ = _summarize_bindings_v96(vars_map=vars_map, last_answer=last_answer)
+        return summ, {"text": summ}, "concept_v90_emit_text_v0"
+    if objective_kind == "COMM_ASK_CLARIFY":
+        missing_ref = str(ctx.get("missing_ref") or "")
+        if missing_ref:
+            qref = f"A que você se refere com {missing_ref}?"
+            return qref, {"text": qref}, "concept_v90_emit_text_v0"
+        missing_key = str(ctx.get("missing_key") or "")
+        missing_slot = str(ctx.get("missing_slot") or "")
+        if missing_key:
+            return f"Qual é o valor de {missing_key}?", {"k": missing_key}, "concept_v90_ask_clarify_v0"
+        if missing_slot == "v":
+            k = str(slots.get("k") or "")
+            if k:
+                return f"Qual é o valor de {k}?", {"k": k}, "concept_v90_ask_clarify_v0"
+        q = f"Faltando: {missing_slot}" if missing_slot else "Faltando: dados"
+        return q, {"text": q}, "concept_v90_emit_text_v0"
+
+    if intent_id == INTENT_SET_V92:
+        k = str(slots.get("k") or "")
+        v = str(slots.get("v") or "")
+        return f"OK: {k}={v}", {"k": k, "v": v}, "concept_v90_confirm_set_v0"
+    if intent_id == INTENT_GET_V92:
+        k = str(slots.get("k") or "")
+        if k in vars_map:
+            text = f"{k}={vars_map.get(k)}"
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        if k in beliefs_by_key:
+            bv = beliefs_by_key.get(k) if isinstance(beliefs_by_key.get(k), dict) else {}
+            text = f"{k}={bv.get('belief_value')}"
+            return text, {"text": text}, "concept_v90_emit_text_v0"
+        return "Não sei.", {}, "concept_v90_admit_unknown_v0"
+    if intent_id == INTENT_ADD_V92:
+        a = str(slots.get("a") or "")
+        b = str(slots.get("b") or "")
+        va, _ = _parse_int_or_var(vars_map=vars_map, tok=a, last_answer=last_answer)
+        vb, _ = _parse_int_or_var(vars_map=vars_map, tok=b, last_answer=last_answer)
+        if va is None or vb is None:
+            return "Não sei.", {}, "concept_v90_admit_unknown_v0"
+        s = int(int(va) + int(vb))
+        text = f"SUM={s}"
+        return text, {"sum": str(s)}, "concept_v90_emit_sum_v0"
+
+    return "Não sei.", {}, "concept_v90_admit_unknown_v0"
+
+
+def _parse_user_text_compound_v96(*, user_text: str, rules: Sequence[Any]) -> Dict[str, Any]:
+    raw = str(user_text or "")
+    if (";" in raw) or ("\n" in raw):
+        parts: List[str] = []
+        for seg in raw.replace("\n", ";").split(";"):
+            seg2 = seg.strip()
+            if seg2:
+                parts.append(seg2)
+        if len(parts) <= 1:
+            return parse_intent_v92(user_text=str(user_text), rules=list(rules))
+        segments: List[Dict[str, Any]] = []
+        seg_fail: Optional[Dict[str, Any]] = None
+        for i, seg_text in enumerate(parts):
+            sp = parse_intent_v92(user_text=str(seg_text), rules=list(rules))
+            seg_entry = {"segment_index": int(i), "segment_text": str(seg_text), "segment_parse": dict(sp)}
+            segments.append(seg_entry)
+            if seg_fail is None:
+                if not bool(sp.get("parse_ok", False)) or (isinstance(sp.get("missing_slots"), list) and sp.get("missing_slots")):
+                    seg_fail = dict(sp)
+        sem = {
+            "schema_version": 96,
+            "intent_id": INTENT_COMPOUND_V92,
+            "compound": True,
+            "policy": "all_or_nothing",
+            "segments": list(segments),
+            "matched_rule_id": "COMPOUND",
+        }
+        parse_ok = seg_fail is None
+        reason = "ok"
+        if seg_fail is not None:
+            reason = str(seg_fail.get("reason") or "segment_fail")
+        sem["parse_ok"] = bool(parse_ok)
+        sem["reason"] = str(reason)
+        sig = _stable_hash_obj(sem)
+        return dict(sem, parse_sig=str(sig))
+    return parse_intent_v92(user_text=str(user_text), rules=list(rules))
+
+
+def run_conversation_v102(
+    *,
+    user_turn_texts: Sequence[str],
+    out_dir: str,
+    seed: int,
+) -> Dict[str, Any]:
+    ensure_absent(str(out_dir))
+    os.makedirs(str(out_dir), exist_ok=False)
+    repo_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+
+    store_path = os.path.join(str(out_dir), "store.jsonl")
+    grammar_snapshot_path = os.path.join(str(out_dir), "intent_grammar_snapshot.json")
+    system_spec_path = os.path.join(str(out_dir), "system_spec_snapshot.json")
+    turns_path = os.path.join(str(out_dir), "conversation_turns.jsonl")
+    parses_path = os.path.join(str(out_dir), "intent_parses.jsonl")
+    learned_path = os.path.join(str(out_dir), "learned_intent_rules.jsonl")
+    plans_path = os.path.join(str(out_dir), "action_plans.jsonl")
+    memory_path = os.path.join(str(out_dir), "memory_events.jsonl")
+    belief_path = os.path.join(str(out_dir), "belief_events.jsonl")
+    evidence_path = os.path.join(str(out_dir), "evidence_events.jsonl")
+    goal_path = os.path.join(str(out_dir), "goal_events.jsonl")
+    goal_snapshot_path = os.path.join(str(out_dir), "goal_ledger_snapshot.json")
+    discourse_path = os.path.join(str(out_dir), "discourse_events.jsonl")
+    fragment_events_path = os.path.join(str(out_dir), "fragment_events.jsonl")
+    fragment_snapshot_path = os.path.join(str(out_dir), "fragment_library_snapshot.json")
+    binding_events_path = os.path.join(str(out_dir), "binding_events.jsonl")
+    binding_snapshot_path = os.path.join(str(out_dir), "binding_snapshot.json")
+    states_path = os.path.join(str(out_dir), "conversation_states.jsonl")
+    trials_path = os.path.join(str(out_dir), "dialogue_trials.jsonl")
+    evals_path = os.path.join(str(out_dir), "objective_evals.jsonl")
+    transcript_path = os.path.join(str(out_dir), "transcript.jsonl")
+    style_path = os.path.join(str(out_dir), "style_events.jsonl")
+    template_snapshot_path = os.path.join(str(out_dir), "template_library_snapshot_v102.json")
+    verify_path = os.path.join(str(out_dir), "verify_chain_v102.json")
+    manifest_path = os.path.join(str(out_dir), "freeze_manifest_v102.json")
+    summary_path = os.path.join(str(out_dir), "summary.json")
+
+    store = ActStore()
+
+    obj_ids = comm_objective_ids_v90()
+    for okind, oid in sorted(obj_ids.items(), key=lambda kv: str(kv[0])):
+        store.add(make_comm_objective_eq_text_v90(objective_id=str(oid), objective_kind=str(okind), created_step=0))
+
+    goal_ids = {k: str(k) for k in COMM_OBJECTIVES_V90}
+    for act in action_concepts_for_dsl_v90(goal_ids=goal_ids):
+        store.add(act)
+
+    rules = default_intent_rules_v92()
+    for act in default_intent_rule_acts_v92(created_step=0):
+        store.add(act)
+
+    if os.path.exists(store_path):
+        _fail(f"store_path_exists:{store_path}")
+    store.save_jsonl(store_path)
+    store_hash = store.content_hash()
+
+    if os.path.exists(grammar_snapshot_path):
+        _fail(f"grammar_snapshot_exists:{grammar_snapshot_path}")
+    grammar_snapshot = intent_grammar_snapshot_v92(rules)
+    tmpg = grammar_snapshot_path + ".tmp"
+    with open(tmpg, "w", encoding="utf-8") as f:
+        f.write(json.dumps(grammar_snapshot, ensure_ascii=False, indent=2, sort_keys=True))
+        f.write("\n")
+    os.replace(tmpg, grammar_snapshot_path)
+
+    # System spec snapshot (WORM; deterministic, no runtime-dependent fields).
+    if os.path.exists(system_spec_path):
+        _fail(f"system_spec_snapshot_exists:{system_spec_path}")
+    system_spec = make_system_spec_v97()
+    tmpss = system_spec_path + ".tmp"
+    with open(tmpss, "w", encoding="utf-8") as f:
+        f.write(json.dumps(system_spec, ensure_ascii=False, indent=2, sort_keys=True))
+        f.write("\n")
+    os.replace(tmpss, system_spec_path)
+
+    # Ensure ledgers exist even if empty (write-once; WORM).
+    with open(memory_path, "x", encoding="utf-8") as _f:
+        pass
+    with open(belief_path, "x", encoding="utf-8") as _f:
+        pass
+    with open(evidence_path, "x", encoding="utf-8") as _f:
+        pass
+    with open(goal_path, "x", encoding="utf-8") as _f:
+        pass
+    with open(discourse_path, "x", encoding="utf-8") as _f:
+        pass
+    with open(fragment_events_path, "x", encoding="utf-8") as _f:
+        pass
+    with open(binding_events_path, "x", encoding="utf-8") as _f:
+        pass
+    with open(style_path, "x", encoding="utf-8") as _f:
+        pass
+
+    engine = EngineV80(store, seed=int(seed))
+
+    conv_body = {"turns": list(user_turn_texts), "grammar_hash": str(grammar_hash_v92(rules))}
+    conversation_id = f"conv_v102_{sha256_hex(canonical_json_dumps(conv_body).encode('utf-8'))}"
+
+    vars_map: Dict[str, Any] = {}
+    last_answer: Any = ""
+
+    turns: List[Dict[str, Any]] = []
+    states: List[Dict[str, Any]] = []
+    transcript: List[Dict[str, Any]] = []
+    parse_events: List[Dict[str, Any]] = []
+    trials: List[Dict[str, Any]] = []
+    learned_rule_events: List[Dict[str, Any]] = []
+    action_plans: List[Dict[str, Any]] = []
+    memory_events: List[Dict[str, Any]] = []
+    belief_events: List[Dict[str, Any]] = []
+    evidence_events: List[Dict[str, Any]] = []
+    goal_events: List[Dict[str, Any]] = []
+    discourse_events: List[Dict[str, Any]] = []
+    fragment_events: List[Dict[str, Any]] = []
+    style_events: List[Dict[str, Any]] = []
+
+    templates_v102 = base_templates_v102()
+    style_profile = default_style_profile_v102()
+    recent_style_template_ids: List[str] = []
+
+    prev_turns_hash: Optional[str] = None
+    prev_parses_hash: Optional[str] = None
+    prev_learned_hash: Optional[str] = None
+    prev_plans_hash: Optional[str] = None
+    prev_memory_hash: Optional[str] = None
+    prev_belief_hash: Optional[str] = None
+    prev_evidence_hash: Optional[str] = None
+    prev_goal_hash: Optional[str] = None
+    prev_discourse_hash: Optional[str] = None
+    prev_fragment_hash: Optional[str] = None
+    prev_states_hash: Optional[str] = None
+    prev_trials_hash: Optional[str] = None
+    prev_evals_hash: Optional[str] = None
+    prev_transcript_hash: Optional[str] = None
+
+    support_events: List[Dict[str, Any]] = []
+    learned_rules_active: Dict[str, IntentRuleV93] = {}
+
+    memory_items_by_id: Dict[str, Dict[str, Any]] = {}
+    memory_active_ids: Dict[str, bool] = {}
+
+    belief_items_by_id: Dict[str, Dict[str, Any]] = {}
+    belief_active_by_key: Dict[str, str] = {}
+
+    prev_goal_event_sig = ""
+    prev_discourse_event_sig = ""
+    prev_fragment_event_sig = ""
+    prev_style_event_sig = ""
+    prev_binding_event_sig = ""
+    prev_binding_hash: Optional[str] = None
+    prev_style_hash: Optional[str] = None
+    binding_events: List[Dict[str, Any]] = []
+    binding_active_by_id: Dict[str, Dict[str, Any]] = {}
+    binding_ts_logical = 0
+
+    # Discourse state (persisted via discourse_events; also echoed in conversation state bindings).
+    discourse_state: Dict[str, Any] = {
+        "schema_version": 100,
+        "kind": "discourse_state_v100",
+        "active_topics": [],
+        "open_questions": [],
+        "commitments": [],
+        "style_prefs": {},
+        "ref_map": {},
+    }
+
+    base_fragments = base_fragments_v100()
+
+    state_index = 0
+    turn_index = 0
+    step = 0
+
+    def _objective_act_id(okind: str) -> str:
+        return str(obj_ids.get(okind) or "")
+
+    def _active_memory_items_sorted() -> List[Dict[str, Any]]:
+        items: List[Dict[str, Any]] = []
+        for mid in sorted(memory_active_ids.keys(), key=str):
+            if not bool(memory_active_ids.get(mid, False)):
+                continue
+            mi = memory_items_by_id.get(mid)
+            if isinstance(mi, dict):
+                items.append(dict(mi))
+        items.sort(key=lambda it: (int(it.get("created_step", 0)), str(it.get("memory_id") or "")))
+        return items
+
+    def _last_active_memory_id() -> str:
+        items = _active_memory_items_sorted()
+        if not items:
+            return ""
+        items.sort(key=lambda it: (int(it.get("created_step", 0)), str(it.get("memory_id") or "")))
+        return str(items[-1].get("memory_id") or "")
+
+    def _active_beliefs_by_key() -> Dict[str, Dict[str, Any]]:
+        out: Dict[str, Dict[str, Any]] = {}
+        for k in sorted(belief_active_by_key.keys(), key=str):
+            bid = str(belief_active_by_key.get(k) or "")
+            bi = belief_items_by_id.get(bid)
+            if isinstance(bi, dict) and bid:
+                out[str(k)] = dict(bi)
+        return dict(out)
+
+    def _active_bindings_list() -> List[Dict[str, Any]]:
+        items: List[Dict[str, Any]] = []
+        for bid in sorted(binding_active_by_id.keys(), key=str):
+            b = binding_active_by_id.get(bid)
+            if isinstance(b, dict):
+                items.append(dict(b))
+        items.sort(key=lambda b: (-int(b.get("last_used_turn_index") or 0), str(b.get("binding_kind") or ""), str(b.get("binding_id") or "")))
+        return items
+
+    def _append_binding_event(ev: Dict[str, Any]) -> None:
+        nonlocal prev_binding_hash, prev_binding_event_sig, binding_ts_logical
+        ev2 = dict(ev)
+        # ts_logical is part of the signed body; must be set before event_sig is computed.
+        if int(ev2.get("ts_logical", -1)) != int(binding_ts_logical):
+            _fail(f"binding_ts_logical_mismatch:want={binding_ts_logical} got={ev2.get('ts_logical')}")
+        # Append to WORM chain on disk.
+        prev_binding_hash = append_chained_jsonl_v96(binding_events_path, dict(ev2), prev_hash=prev_binding_hash)
+        # Keep in-memory list without outer chain fields.
+        binding_events.append({k: v for k, v in dict(ev2).items() if k not in {"prev_hash", "entry_hash"}})
+        prev_binding_event_sig = str(ev2.get("event_sig") or prev_binding_event_sig)
+        binding_ts_logical += 1
+        # Apply fold incrementally to binding_active_by_id.
+        et = str(ev2.get("type") or "")
+        bid = str(ev2.get("binding_id") or "")
+        if et == "BIND_CREATE" and bid:
+            bval = ev2.get("binding_value") if isinstance(ev2.get("binding_value"), dict) else {}
+            binding_active_by_id[bid] = {
+                "binding_id": str(bid),
+                "binding_kind": str(ev2.get("binding_kind") or ""),
+                "value": dict(bval),
+                "value_hash": str(ev2.get("binding_value_hash") or ""),
+                "value_preview": str(ev2.get("binding_preview") or ""),
+                "created_turn_index": int((ev2.get("evidence") or {}).get("created_turn_index") or 0),
+                "last_used_turn_index": int((ev2.get("evidence") or {}).get("last_used_turn_index") or (ev2.get("evidence") or {}).get("created_turn_index") or 0),
+                "use_count": int((ev2.get("evidence") or {}).get("use_count") or 0),
+                "provenance": dict(ev2.get("provenance") or {}) if isinstance(ev2.get("provenance"), dict) else {},
+            }
+        elif et == "BIND_RESOLVE" and bid and bid in binding_active_by_id:
+            ev_e = ev2.get("evidence") if isinstance(ev2.get("evidence"), dict) else {}
+            if "last_used_turn_index" in ev_e:
+                binding_active_by_id[bid]["last_used_turn_index"] = int(ev_e.get("last_used_turn_index") or binding_active_by_id[bid].get("last_used_turn_index") or 0)
+            if "use_count" in ev_e:
+                binding_active_by_id[bid]["use_count"] = int(ev_e.get("use_count") or binding_active_by_id[bid].get("use_count") or 0)
+        elif et == "BIND_PRUNE" and bid:
+            binding_active_by_id.pop(bid, None)
+
+    def _ensure_binding_create(
+        *,
+        turn_id: str,
+        created_turn_index: int,
+        binding_kind: str,
+        value: Dict[str, Any],
+        value_preview: str,
+        provenance: Dict[str, Any],
+    ) -> str:
+        # Deterministic binding_id derived from kind + value_hash.
+        ev_create = make_binding_create_event_v101(
+            conversation_id=str(conversation_id),
+            ts_logical=int(binding_ts_logical),
+            turn_id=str(turn_id),
+            binding_kind=str(binding_kind),
+            value=dict(value),
+            value_preview=str(value_preview),
+            provenance=dict(provenance),
+            created_turn_index=int(created_turn_index),
+            created_step=int(step),
+            prev_event_sig=str(prev_binding_event_sig),
+        )
+        bid = str(ev_create.get("binding_id") or "")
+        if bid and bid in binding_active_by_id:
+            return bid
+        _append_binding_event(ev_create)
+        # Deterministic prune to enforce bounded growth.
+        max_total = 12
+        if len(binding_active_by_id) > int(max_total):
+            prune = choose_prune_candidate_v101(list(binding_active_by_id.values()))
+            if isinstance(prune, dict):
+                pid = str(prune.get("binding_id") or "")
+                if pid and pid in binding_active_by_id and pid != bid:
+                    ev_prune = make_binding_prune_event_v101(
+                        conversation_id=str(conversation_id),
+                        ts_logical=int(binding_ts_logical),
+                        turn_id=str(turn_id),
+                        binding_id=str(pid),
+                        binding_kind=str(prune.get("binding_kind") or ""),
+                        binding_value_hash=str(prune.get("value_hash") or ""),
+                        reason="max_bindings_total",
+                        created_step=int(step),
+                        prev_event_sig=str(prev_binding_event_sig),
+                    )
+                    _append_binding_event(ev_prune)
+        return str(bid)
+
+    def _binding_get(binding_id: str) -> Optional[Dict[str, Any]]:
+        b = binding_active_by_id.get(str(binding_id) or "")
+        return dict(b) if isinstance(b, dict) else None
+
+    def _binding_use(*, turn_id: str, user_turn_index: int, resolution: Dict[str, Any], chosen_binding_id: str) -> None:
+        b = _binding_get(str(chosen_binding_id))
+        if not isinstance(b, dict):
+            return
+        use_count = int(b.get("use_count") or 0) + 1
+        bkind = str(b.get("binding_kind") or "")
+        vhash = str(b.get("value_hash") or "")
+        ev_res = make_binding_resolve_event_v101(
+            conversation_id=str(conversation_id),
+            ts_logical=int(binding_ts_logical),
+            turn_id=str(turn_id),
+            pronoun=str(resolution.get("pronoun") or ""),
+            resolution=dict(resolution),
+            chosen_binding_id=str(chosen_binding_id),
+            binding_kind=str(bkind),
+            binding_value_hash=str(vhash),
+            created_step=int(step),
+            prev_event_sig=str(prev_binding_event_sig),
+            use_count=int(use_count),
+            last_used_turn_index=int(user_turn_index),
+        )
+        _append_binding_event(ev_res)
+
+    def _last_explainable_plan() -> Optional[Dict[str, Any]]:
+        for p in reversed(action_plans):
+            if not isinstance(p, dict):
+                continue
+            if str(p.get("intent_id") or "") == INTENT_EXPLAIN_V94:
+                continue
+            return dict(p)
+        return None
+
+    def _execute_action(act_id: str, *, goal_kind: str, inputs: Dict[str, Any]) -> Tuple[bool, str, Dict[str, Any], float]:
+        concept_act = store.get_concept_act(str(act_id))
+        if concept_act is None:
+            return False, "", {"ok": False, "reason": "action_not_found"}, 0.0
+        iface = concept_act.evidence.get("interface") if isinstance(concept_act.evidence, dict) else {}
+        in_schema = iface.get("input_schema") if isinstance(iface, dict) else {}
+        in_schema = in_schema if isinstance(in_schema, dict) else {}
+        inps: Dict[str, Any] = {}
+        for k in sorted(in_schema.keys(), key=str):
+            ks = str(k)
+            val = inputs.get(ks)
+            if isinstance(in_schema.get(k), str) and str(in_schema.get(k)) == "str":
+                inps[ks] = "" if val is None else str(val)
+            else:
+                inps[ks] = val
+        exec_res = engine.execute_concept_csv(
+            concept_act_id=str(act_id),
+            inputs=dict(inps),
+            goal_kind=str(goal_kind),
+            expected=None,
+            step=int(step),
+            max_depth=6,
+            max_events=256,
+            validate_output=False,
+        )
+        meta = exec_res.get("meta") if isinstance(exec_res.get("meta"), dict) else {}
+        if not bool(meta.get("ok", False)):
+            return False, "", dict(meta), 0.0
+        out_text = str(meta.get("output_text") or exec_res.get("output") or "")
+        trace = exec_res.get("trace") if isinstance(exec_res.get("trace"), dict) else {}
+        calls = trace.get("concept_calls") if isinstance(trace.get("concept_calls"), list) else []
+        cost_used = 0.0
+        for c in calls:
+            if not isinstance(c, dict):
+                continue
+            cost_used += float(c.get("cost") or 0.0)
+        return True, str(out_text), dict(meta), float(cost_used)
+
+    for user_text in list(user_turn_texts):
+        active_learned_rules = [learned_rules_active[k] for k in sorted(learned_rules_active.keys(), key=str)]
+        rules_for_parse: List[Any] = list(rules) + list(active_learned_rules)
+
+        parse: Dict[str, Any] = {}
+        ctx: Dict[str, Any] = {}
+
+        # Intercepts: TEACH -> EXPLAIN -> BELIEFS -> BELIEF/REVISE -> FORGET (memory/belief) -> NOTE/RECALL -> parser V92/compound.
+        if is_teach_command_v93(str(user_text)):
+            te = parse_teach_command_v93(str(user_text))
+            teach_ok = False
+            teach_reason = str(te.get("reason") or "not_recognized")
+            lhs_raw = str(te.get("lhs_raw") or "")
+            rhs_raw = str(te.get("rhs_raw") or "")
+            rhs_parse_sig = ""
+            rhs_intent_id = ""
+            rhs_rule_id = ""
+            rhs_reason = ""
+            lhs_info: Dict[str, Any] = {}
+            ambiguous_rule_ids: List[str] = []
+            ambiguous_intents: List[Dict[str, Any]] = []
+            pending_learned_rule: Optional[IntentRuleV93] = None
+
+            if bool(te.get("recognized", False)) and bool(te.get("ok", False)):
+                lhs_info = canonize_lhs_for_learned_rule_v93(lhs_raw)
+                stripped = lhs_info.get("lhs_tokens_canon_stripped")
+                stripped_list = [str(x) for x in stripped if isinstance(stripped, list) and isinstance(x, str) and x]
+                if not stripped_list:
+                    teach_ok = False
+                    teach_reason = "lhs_empty_after_normalization"
+                else:
+                    rhs_parse = parse_intent_v92(user_text=str(rhs_raw), rules=list(rules))
+                    # Allow a small set of raw-intercept commands as RHS targets (deterministic, fail-closed).
+                    # This keeps TEACH consistent with the conversation loop's raw intercept layer (e.g., BELIEFS).
+                    if not bool(rhs_parse.get("parse_ok", False)) and is_beliefs_list_command_v96(str(rhs_raw)):
+                        be2 = parse_beliefs_list_command_v96(str(rhs_raw))
+                        ok2 = bool(be2.get("recognized", False)) and bool(be2.get("ok", False))
+                        reason2 = str(be2.get("reason") or "not_recognized")
+                        sem2 = {
+                            "schema_version": 96,
+                            "intent_id": INTENT_BELIEF_LIST_V96,
+                            "matched_rule_id": "",
+                            "compound": False,
+                            "parse_ok": bool(ok2),
+                            "reason": str(reason2),
+                            "prefix": str(be2.get("prefix") or ""),
+                        }
+                        sig2 = _stable_hash_obj(sem2)
+                        rhs_parse = dict(sem2, parse_sig=str(sig2))
+                    rhs_parse_sig = str(rhs_parse.get("parse_sig") or "")
+                    rhs_intent_id = str(rhs_parse.get("intent_id") or "")
+                    rhs_rule_id = str(rhs_parse.get("matched_rule_id") or "")
+                    rhs_reason = str(rhs_parse.get("reason") or "")
+                    if not bool(rhs_parse.get("parse_ok", False)):
+                        teach_reason = f"rhs_parse_fail:{rhs_reason or 'no_match'}"
+                    elif rhs_parse.get("missing_slots"):
+                        teach_reason = "rhs_missing_slots"
+                    elif rhs_intent_id not in {INTENT_SUMMARY_V92, INTENT_END_V92, INTENT_BELIEF_LIST_V96}:
+                        teach_reason = "rhs_intent_disallowed"
+                    else:
+                        learned_rule = make_learned_intent_rule_v93(
+                            intent_id=str(rhs_intent_id),
+                            lhs_tokens_canon_stripped=list(stripped_list),
+                        )
+                        conflicts = []
+                        for r in rules:
+                            try:
+                                rid = str(getattr(r, "rule_id", ""))
+                                pat = getattr(r, "pattern", [])
+                            except Exception:
+                                rid = ""
+                                pat = []
+                            if not isinstance(pat, list):
+                                continue
+                            if [str(x) for x in pat] == stripped_list:
+                                conflicts.append({"rule_id": str(rid), "intent_id": str(getattr(r, "intent_id", ""))})
+                        conflicts = sorted(conflicts, key=lambda d: str(d.get("rule_id") or ""))
+                        if conflicts:
+                            teach_ok = False
+                            teach_reason = "ambiguous"
+                            ambiguous_rule_ids = [str(x.get("rule_id") or "") for x in conflicts]
+                            ambiguous_intents = list(conflicts)
+                        else:
+                            teach_ok = True
+                            teach_reason = "ok"
+                            pending_learned_rule = learned_rule
+
+            sem = {
+                "schema_version": 96,
+                "intent_id": INTENT_TEACH_V93,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(teach_ok),
+                "reason": str(teach_reason),
+                "lhs_raw": str(lhs_raw),
+                "rhs_raw": str(rhs_raw),
+                "rhs_parse_sig": str(rhs_parse_sig),
+                "rhs_intent_id": str(rhs_intent_id),
+                "rhs_rule_id": str(rhs_rule_id),
+                "rhs_reason": str(rhs_reason),
+                "teach_ok": bool(teach_ok),
+                "learned_rule_id": str(pending_learned_rule.rule_id) if pending_learned_rule else "",
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+            if teach_ok and pending_learned_rule is not None:
+                learned_row = {
+                    "kind": "learned_intent_rule_v96",
+                    "time": deterministic_iso(step=int(step)),
+                    "step": int(step),
+                    "teacher_turn_id": "",  # filled after user turn exists
+                    "lhs_raw": str(lhs_raw),
+                    "rhs_raw": str(rhs_raw),
+                    "rhs_parse_sig": str(rhs_parse_sig),
+                    "rhs_intent_id": str(rhs_intent_id),
+                    "rhs_rule_id": str(rhs_rule_id),
+                    "learned_rule": dict(pending_learned_rule.to_dict()),
+                    "provenance": {
+                        "lhs_raw": str(lhs_raw),
+                        "rhs_raw": str(rhs_raw),
+                    },
+                }
+                ctx["pending_learned_rule"] = pending_learned_rule
+                ctx["pending_learned_row"] = learned_row
+            if teach_reason == "ambiguous":
+                ctx["ambiguous"] = list(ambiguous_intents)
+
+        elif is_style_profile_command_v102(str(user_text)):
+            sp = parse_style_profile_command_v102(str(user_text))
+            ok = bool(sp.get("recognized", False)) and bool(sp.get("ok", False))
+            reason = str(sp.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 102,
+                "intent_id": INTENT_STYLE_PROFILE_V102,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(sp.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+            if ok:
+                ctx["style_profile_text"] = render_style_profile_text_v102(style_profile)
+
+        elif is_templates_command_v102(str(user_text)):
+            tp = parse_templates_command_v102(str(user_text))
+            ok = bool(tp.get("recognized", False)) and bool(tp.get("ok", False))
+            reason = str(tp.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 102,
+                "intent_id": INTENT_TEMPLATES_V102,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(tp.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+            if ok:
+                stats_now = fold_template_stats_v102(templates=list(templates_v102), style_events=list(style_events))
+                ctx["templates_text"] = render_templates_list_text_v102(templates=list(templates_v102), template_stats=dict(stats_now))
+
+        elif is_explain_style_command_v102(str(user_text)):
+            es = parse_explain_style_command_v102(str(user_text))
+            ok = bool(es.get("recognized", False)) and bool(es.get("ok", False))
+            reason = str(es.get("reason") or "not_recognized")
+            turn_id = str(es.get("turn_id") or "")
+            sem = {
+                "schema_version": 102,
+                "intent_id": INTENT_EXPLAIN_STYLE_V102,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "turn_id": str(turn_id),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+            if ok:
+                target = None
+                for sev in style_events:
+                    if isinstance(sev, dict) and str(sev.get("turn_id") or "") == str(turn_id):
+                        target = dict(sev)
+                        break
+                if target is None:
+                    parse["parse_ok"] = False
+                    parse["reason"] = "unknown_turn_id"
+                else:
+                    ctx["explain_style_text"] = explain_style_text_v102(style_event=dict(target))
+
+        elif is_trace_style_command_v102(str(user_text)):
+            ts = parse_trace_style_command_v102(str(user_text))
+            ok = bool(ts.get("recognized", False)) and bool(ts.get("ok", False))
+            reason = str(ts.get("reason") or "not_recognized")
+            turn_id = str(ts.get("turn_id") or "")
+            sem = {
+                "schema_version": 102,
+                "intent_id": INTENT_TRACE_STYLE_V102,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "turn_id": str(turn_id),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+            if ok:
+                eid = ""
+                for sev in style_events:
+                    if isinstance(sev, dict) and str(sev.get("turn_id") or "") == str(turn_id):
+                        eid = str(sev.get("event_id") or "")
+                        break
+                ctx["trace_style_text"] = f"TRACE_STYLE: turn_id={turn_id} style_event_id={eid}"
+
+        elif is_bindings_command_v101(str(user_text)):
+            be = parse_bindings_command_v101(str(user_text))
+            ok = bool(be.get("recognized", False)) and bool(be.get("ok", False))
+            reason = str(be.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 101,
+                "intent_id": INTENT_BINDINGS_LIST_V101,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(be.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_explain_binding_command_v101(str(user_text)):
+            eb = parse_explain_binding_command_v101(str(user_text))
+            ok = bool(eb.get("recognized", False)) and bool(eb.get("ok", False))
+            reason = str(eb.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 101,
+                "intent_id": INTENT_EXPLAIN_BINDING_V101,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(eb.get("prefix") or ""),
+                "binding_id": str(eb.get("binding_id") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_trace_ref_command_v101(str(user_text)):
+            tr = parse_trace_ref_command_v101(str(user_text))
+            ok = bool(tr.get("recognized", False)) and bool(tr.get("ok", False))
+            reason = str(tr.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 101,
+                "intent_id": INTENT_TRACE_REF_V101,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(tr.get("prefix") or ""),
+                "turn_id": str(tr.get("turn_id") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_plan_create_3_command_v101(str(user_text)):
+            pc = parse_plan_create_3_command_v101(str(user_text))
+            ok = bool(pc.get("recognized", False)) and bool(pc.get("ok", False))
+            reason = str(pc.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 101,
+                "intent_id": INTENT_PLAN_CREATE_V101,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "target": str(pc.get("target") or ""),
+                "steps_total": int(pc.get("steps_total") or 3),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_shorten_ref_command_v101(str(user_text)):
+            sc = parse_shorten_ref_command_v101(str(user_text))
+            ok = bool(sc.get("recognized", False)) and bool(sc.get("ok", False))
+            reason = str(sc.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 101,
+                "intent_id": INTENT_PLAN_SHORTEN_REF_V101,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "pronoun": str(sc.get("pronoun") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_priority_high_ref_command_v101(str(user_text)):
+            pr = parse_priority_high_ref_command_v101(str(user_text))
+            ok = bool(pr.get("recognized", False)) and bool(pr.get("ok", False))
+            reason = str(pr.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 101,
+                "intent_id": INTENT_GOAL_PRIORITY_HIGH_REF_V101,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "pronoun": str(pr.get("pronoun") or ""),
+                "priority": str(pr.get("priority") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_explain_command_v94(str(user_text)):
+            ex = parse_explain_command_v94(str(user_text))
+            ok = bool(ex.get("recognized", False)) and bool(ex.get("ok", False))
+            reason = str(ex.get("reason") or "not_recognized")
+            explained_plan_id = ""
+            explain_text = ""
+            if ok:
+                lastp = _last_explainable_plan()
+                if lastp is None:
+                    ok = False
+                    reason = "no_prior_plan"
+                else:
+                    explained_plan_id = str(lastp.get("plan_id") or "")
+                    explain_text = render_explain_text_v100(lastp)
+            sem = {
+                "schema_version": 96,
+                "intent_id": INTENT_EXPLAIN_V94,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "explained_plan_id": str(explained_plan_id),
+                "prefix": str(ex.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+            ctx["explain_text"] = str(explain_text)
+            ctx["msg"] = str(reason or "")
+
+        elif is_system_command_v98(str(user_text)):
+            se = parse_system_command_v98(str(user_text))
+            ok = bool(se.get("recognized", False)) and bool(se.get("ok", False))
+            reason = str(se.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 98,
+                "intent_id": INTENT_SYSTEM_V98,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(se.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_discourse_command_v100(str(user_text)):
+            de = parse_discourse_command_v100(str(user_text))
+            ok = bool(de.get("recognized", False)) and bool(de.get("ok", False))
+            reason = str(de.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 100,
+                "intent_id": INTENT_DISCOURSE_V100,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(de.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_evidence_add_command_v98(str(user_text)):
+            ee = parse_evidence_add_command_v98(str(user_text))
+            ok = bool(ee.get("recognized", False)) and bool(ee.get("ok", False))
+            reason = str(ee.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 98,
+                "intent_id": INTENT_EVIDENCE_ADD_V98,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(ee.get("prefix") or ""),
+                "evidence_kind": str(ee.get("evidence_kind") or ""),
+                "evidence_key": str(ee.get("evidence_key") or ""),
+                "evidence_value": str(ee.get("evidence_value") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_evidences_list_command_v98(str(user_text)):
+            el = parse_evidences_list_command_v98(str(user_text))
+            ok = bool(el.get("recognized", False)) and bool(el.get("ok", False))
+            reason = str(el.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 98,
+                "intent_id": INTENT_EVIDENCE_LIST_V98,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(el.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_why_ref_command_v100(str(user_text)):
+            wr = parse_why_ref_command_v100(str(user_text))
+            ok = bool(wr.get("recognized", False)) and bool(wr.get("ok", False))
+            reason = str(wr.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 100,
+                "intent_id": INTENT_WHY_REF_V100,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(wr.get("prefix") or ""),
+                "ref_token": str(wr.get("ref_token") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_why_command_v98(str(user_text)):
+            wy = parse_why_command_v98(str(user_text))
+            ok = bool(wy.get("recognized", False)) and bool(wy.get("ok", False))
+            reason = str(wy.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 98,
+                "intent_id": INTENT_WHY_V98,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(wy.get("prefix") or ""),
+                "key": str(wy.get("key") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_versions_command_v98(str(user_text)):
+            ve = parse_versions_command_v98(str(user_text))
+            ok = bool(ve.get("recognized", False)) and bool(ve.get("ok", False))
+            reason = str(ve.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 98,
+                "intent_id": INTENT_VERSIONS_V98,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(ve.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_dossier_command_v98(str(user_text)):
+            de = parse_dossier_command_v98(str(user_text))
+            ok = bool(de.get("recognized", False)) and bool(de.get("ok", False))
+            reason = str(de.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 98,
+                "intent_id": INTENT_DOSSIER_V98,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(de.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_goal_add_command_v99(str(user_text)):
+            ge = parse_goal_add_command_v99(str(user_text))
+            ok = bool(ge.get("recognized", False)) and bool(ge.get("ok", False))
+            reason = str(ge.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 99,
+                "intent_id": INTENT_GOAL_ADD_V99,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(ge.get("prefix") or ""),
+                "goal_text": str(ge.get("goal_text") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_goals_list_command_v99(str(user_text)):
+            gl = parse_goals_list_command_v99(str(user_text))
+            ok = bool(gl.get("recognized", False)) and bool(gl.get("ok", False))
+            reason = str(gl.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 99,
+                "intent_id": INTENT_GOAL_LIST_V99,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(gl.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_done_command_v99(str(user_text)):
+            dn = parse_done_command_v99(str(user_text))
+            ok = bool(dn.get("recognized", False)) and bool(dn.get("ok", False))
+            reason = str(dn.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 99,
+                "intent_id": INTENT_GOAL_DONE_V99,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(dn.get("prefix") or ""),
+                "goal_id": str(dn.get("goal_id") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_next_command_v99(str(user_text)):
+            nx = parse_next_command_v99(str(user_text))
+            ok = bool(nx.get("recognized", False)) and bool(nx.get("ok", False))
+            reason = str(nx.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 99,
+                "intent_id": INTENT_GOAL_NEXT_V99,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(nx.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_auto_command_v99(str(user_text)):
+            au = parse_auto_command_v99(str(user_text))
+            ok = bool(au.get("recognized", False)) and bool(au.get("ok", False))
+            reason = str(au.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 99,
+                "intent_id": INTENT_GOAL_AUTO_V99,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(au.get("prefix") or ""),
+                "n": int(au.get("n") or 0) if bool(ok) else 0,
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_beliefs_list_command_v96(str(user_text)):
+            be = parse_beliefs_list_command_v96(str(user_text))
+            ok = bool(be.get("recognized", False)) and bool(be.get("ok", False))
+            reason = str(be.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 96,
+                "intent_id": INTENT_BELIEF_LIST_V96,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(be.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_belief_add_command_v96(str(user_text)):
+            be = parse_belief_add_command_v96(str(user_text))
+            ok = bool(be.get("recognized", False)) and bool(be.get("ok", False))
+            reason = str(be.get("reason") or "not_recognized")
+            key = str(be.get("belief_key") or "")
+            val = str(be.get("belief_value") or "")
+            if ok and key in belief_active_by_key:
+                ok = False
+                reason = "key_exists_use_revise"
+            sem = {
+                "schema_version": 96,
+                "intent_id": INTENT_BELIEF_ADD_V96,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(be.get("prefix") or ""),
+                "belief_key": str(key),
+                "belief_value": str(val),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_belief_revise_command_v96(str(user_text)):
+            be = parse_belief_revise_command_v96(str(user_text))
+            ok = bool(be.get("recognized", False)) and bool(be.get("ok", False))
+            reason = str(be.get("reason") or "not_recognized")
+            key = str(be.get("belief_key") or "")
+            val = str(be.get("belief_value") or "")
+            if ok and key not in belief_active_by_key:
+                ok = False
+                reason = "missing_key_use_belief"
+            sem = {
+                "schema_version": 96,
+                "intent_id": INTENT_BELIEF_REVISE_V96,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(be.get("prefix") or ""),
+                "belief_key": str(key),
+                "belief_value": str(val),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_forget_command_v96(str(user_text)):
+            fe = parse_forget_command_v96(str(user_text))
+            ok = bool(fe.get("recognized", False)) and bool(fe.get("ok", False))
+            reason = str(fe.get("reason") or "not_recognized")
+            target_kind = str(fe.get("target_kind") or "")
+            belief_key = str(fe.get("belief_key") or "")
+            if ok and target_kind == "belief":
+                if belief_key not in belief_active_by_key:
+                    ok = False
+                    reason = "missing_key"
+            sem = {
+                "schema_version": 96,
+                "intent_id": INTENT_BELIEF_FORGET_V96 if target_kind == "belief" else INTENT_FORGET_V96,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(fe.get("prefix") or ""),
+                "target_kind": str(target_kind),
+                "target": str(fe.get("target") or ""),
+                "belief_key": str(belief_key),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_note_command_v96(str(user_text)):
+            ne = parse_note_command_v96(str(user_text))
+            ok = bool(ne.get("recognized", False)) and bool(ne.get("ok", False))
+            reason = str(ne.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 96,
+                "intent_id": INTENT_NOTE_V96,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(ne.get("prefix") or ""),
+                "memory_text_raw": str(ne.get("memory_text_raw") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        elif is_recall_command_v96(str(user_text)):
+            re = parse_recall_command_v96(str(user_text))
+            ok = bool(re.get("recognized", False)) and bool(re.get("ok", False))
+            reason = str(re.get("reason") or "not_recognized")
+            sem = {
+                "schema_version": 96,
+                "intent_id": INTENT_RECALL_V96,
+                "matched_rule_id": "",
+                "compound": False,
+                "parse_ok": bool(ok),
+                "reason": str(reason),
+                "prefix": str(re.get("prefix") or ""),
+            }
+            sig = _stable_hash_obj(sem)
+            parse = dict(sem, parse_sig=str(sig))
+
+        else:
+            parse = _parse_user_text_compound_v96(user_text=str(user_text), rules=list(rules_for_parse))
+
+        # Create user turn.
+        ut = TurnV96(
+            conversation_id=str(conversation_id),
+            turn_index=int(turn_index),
+            role="user",
+            text=str(user_text),
+            created_step=int(step),
+            offset_us=0,
+            parse_sig=str(parse.get("parse_sig") or ""),
+            intent_id=str(parse.get("intent_id") or ""),
+            matched_rule_id=str(parse.get("matched_rule_id") or ""),
+        ).to_dict()
+        turn_index += 1
+        step += 1
+        turns.append(dict(ut))
+        prev_turns_hash = append_chained_jsonl_v96(
+            turns_path,
+            {"time": deterministic_iso(step=int(ut["created_step"])), "step": int(ut["created_step"]), "event": "TURN", "payload": dict(ut)},
+            prev_hash=prev_turns_hash,
+        )
+        transcript.append({"role": "user", "text": str(ut.get("text") or ""), "turn_id": str(ut.get("turn_id") or "")})
+        prev_transcript_hash = append_chained_jsonl_v96(
+            transcript_path,
+            {"time": deterministic_iso(step=int(ut["created_step"])), "step": int(ut["created_step"]), "event": "UTTERANCE", "payload": dict(transcript[-1])},
+            prev_hash=prev_transcript_hash,
+        )
+
+        # Log parse (WORM, hash-chained).
+        parse_event = {
+            "kind": "intent_parse_v96",
+            "time": deterministic_iso(step=int(step)),
+            "step": int(step),
+            "turn_id": str(ut.get("turn_id") or ""),
+            "turn_index": int(ut.get("turn_index") or 0),
+            "payload": dict(parse),
+        }
+        prev_parses_hash = append_chained_jsonl_v96(parses_path, dict(parse_event), prev_hash=prev_parses_hash)
+        parse_events.append({"turn_id": str(parse_event["turn_id"]), "turn_index": int(parse_event["turn_index"]), "payload": dict(parse)})
+
+        # Apply learning (TEACH) after user turn exists, before executing actions.
+        if str(parse.get("intent_id") or "") == "INTENT_TEACH" and bool(parse.get("teach_ok", False)):
+            lr = ctx.get("pending_learned_rule")
+            row = ctx.get("pending_learned_row")
+            if isinstance(lr, IntentRuleV93) and isinstance(row, dict):
+                learned_row = dict(row)
+                learned_row["teacher_turn_id"] = str(ut.get("turn_id") or "")
+                learned_row["provenance"] = dict(learned_row.get("provenance") or {})
+                learned_row["provenance"]["teacher_turn_id"] = str(ut.get("turn_id") or "")
+                prev_learned_hash = append_chained_jsonl_v96(learned_path, dict(learned_row), prev_hash=prev_learned_hash)
+                learned_rule_events.append(dict(learned_row))
+                learned_rules_active[str(lr.rule_id)] = lr
+
+        # V102: style profile update from explicit user signals (deterministic, no ML).
+        style_profile_before = style_profile
+        style_profile, style_profile_updates = derive_style_profile_update_v102(
+            prev=style_profile,
+            user_text=str(user_text),
+            user_turn_id=str(ut.get("turn_id") or ""),
+        )
+
+        # Memory/belief ops produce read/write refs for plan.
+        memory_read_ids: List[str] = []
+        memory_write_event_ids: List[str] = []
+        belief_read_keys: List[str] = []
+        belief_read_ids: List[str] = []
+        belief_write_event_ids: List[str] = []
+        evidence_read_ids: List[str] = []
+        evidence_write_ids: List[str] = []
+        cause_evidence_ids: List[str] = []
+        goal_read_ids: List[str] = []
+        goal_write_ids: List[str] = []
+        goal_tick_actions: List[Dict[str, Any]] = []
+
+        objective_kind = ""
+        ctx2: Dict[str, Any] = {}
+
+        beliefs_active = _active_beliefs_by_key()
+
+        if str(parse.get("intent_id") or "") == INTENT_NOTE_V96:
+            if bool(parse.get("parse_ok", False)):
+                txt = str(parse.get("memory_text_raw") or "")
+                mi = MemoryItemV96(conversation_id=str(conversation_id), memory_text=str(txt), source_turn_id=str(ut.get("turn_id") or ""), created_step=int(step)).to_dict()
+                mid = str(mi.get("memory_id") or "")
+                ev = MemoryEventV96(
+                    conversation_id=str(conversation_id),
+                    event_kind="ADD",
+                    created_step=int(step),
+                    source_turn_id=str(ut.get("turn_id") or ""),
+                    memory_item=dict(mi),
+                ).to_dict()
+                prev_memory_hash = append_chained_jsonl_v96(memory_path, dict(ev), prev_hash=prev_memory_hash)
+                memory_events.append(dict(ev))
+                if mid:
+                    memory_items_by_id[mid] = dict(mi)
+                    memory_active_ids[mid] = True
+                    _ensure_binding_create(
+                        turn_id=str(ut.get("turn_id") or ""),
+                        created_turn_index=int(ut.get("turn_index") or 0),
+                        binding_kind="memory",
+                        value={"memory_id": str(mid), "memory_text": str(txt)},
+                        value_preview=f"memory:{str(txt)[:32]}",
+                        provenance={"ledger": "memory_ledger_v96", "source_event_id": str(ev.get("event_id") or "")},
+                    )
+                memory_write_event_ids.append(str(ev.get("event_id") or ""))
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"note_ack_text": render_note_ack_text_v96(mid)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"note_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_RECALL_V96:
+            if bool(parse.get("parse_ok", False)):
+                items = _active_memory_items_sorted()
+                memory_read_ids = [str(it.get("memory_id") or "") for it in items if isinstance(it, dict) and str(it.get("memory_id") or "")]
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"recall_text": render_recall_text_v96(items)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"recall_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_FORGET_V96:
+            if bool(parse.get("parse_ok", False)):
+                target_mid = _last_active_memory_id()
+                if not target_mid:
+                    objective_kind = "COMM_CORRECT"
+                    ctx2 = {"msg": "no_active_memory"}
+                else:
+                    ev = MemoryEventV96(
+                        conversation_id=str(conversation_id),
+                        event_kind="RETRACT",
+                        created_step=int(step),
+                        source_turn_id=str(ut.get("turn_id") or ""),
+                        target_memory_id=str(target_mid),
+                        retract_reason="user_forget_last",
+                    ).to_dict()
+                    prev_memory_hash = append_chained_jsonl_v96(memory_path, dict(ev), prev_hash=prev_memory_hash)
+                    memory_events.append(dict(ev))
+                    memory_active_ids.pop(str(target_mid), None)
+                    memory_read_ids = [str(target_mid)]
+                    memory_write_event_ids.append(str(ev.get("event_id") or ""))
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"forget_ack_text": render_forget_ack_text_v96(target_mid)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"forget_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_BELIEF_ADD_V96:
+            if bool(parse.get("parse_ok", False)):
+                key = str(parse.get("belief_key") or "").strip()
+                val = str(parse.get("belief_value") or "").strip()
+                bi = BeliefItemV96(conversation_id=str(conversation_id), belief_key=str(key), belief_value=str(val), source_turn_id=str(ut.get("turn_id") or ""), created_step=int(step)).to_dict()
+                bid = str(bi.get("belief_id") or "")
+                ev = BeliefEventV96(
+                    conversation_id=str(conversation_id),
+                    event_kind="ADD",
+                    created_step=int(step),
+                    source_turn_id=str(ut.get("turn_id") or ""),
+                    belief_item=dict(bi),
+                ).to_dict()
+                prev_belief_hash = append_chained_jsonl_v96(belief_path, dict(ev), prev_hash=prev_belief_hash)
+                belief_events.append(dict(ev))
+                if bid and key:
+                    belief_items_by_id[bid] = dict(bi)
+                    belief_active_by_key[key] = bid
+                    _ensure_binding_create(
+                        turn_id=str(ut.get("turn_id") or ""),
+                        created_turn_index=int(ut.get("turn_index") or 0),
+                        binding_kind="belief",
+                        value={"belief_key": str(key)},
+                        value_preview=f"belief:{str(key)}",
+                        provenance={"ledger": "belief_ledger_v96", "source_event_id": str(ev.get("event_id") or "")},
+                    )
+                belief_write_event_ids.append(str(ev.get("event_id") or ""))
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"belief_ack_text": render_belief_added_ack_text_v96(belief_id=bid, key=key)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"belief_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_BELIEF_REVISE_V96:
+            if bool(parse.get("parse_ok", False)):
+                key = str(parse.get("belief_key") or "").strip()
+                val = str(parse.get("belief_value") or "").strip()
+                old_id = str(belief_active_by_key.get(key) or "")
+                if not old_id:
+                    objective_kind = "COMM_CORRECT"
+                    ctx2 = {"msg": "missing_key_use_belief"}
+                else:
+                    belief_read_keys = [str(key)]
+                    belief_read_ids = [str(old_id)]
+                    evr = BeliefEventV96(
+                        conversation_id=str(conversation_id),
+                        event_kind="RETRACT",
+                        created_step=int(step),
+                        source_turn_id=str(ut.get("turn_id") or ""),
+                        target_belief_id=str(old_id),
+                        retract_reason="user_revise",
+                    ).to_dict()
+                    prev_belief_hash = append_chained_jsonl_v96(belief_path, dict(evr), prev_hash=prev_belief_hash)
+                    belief_events.append(dict(evr))
+                    bi = BeliefItemV96(conversation_id=str(conversation_id), belief_key=str(key), belief_value=str(val), source_turn_id=str(ut.get("turn_id") or ""), created_step=int(step)).to_dict()
+                    bid = str(bi.get("belief_id") or "")
+                    eva = BeliefEventV96(
+                        conversation_id=str(conversation_id),
+                        event_kind="ADD",
+                        created_step=int(step),
+                        source_turn_id=str(ut.get("turn_id") or ""),
+                        belief_item=dict(bi),
+                    ).to_dict()
+                    prev_belief_hash = append_chained_jsonl_v96(belief_path, dict(eva), prev_hash=prev_belief_hash)
+                    belief_events.append(dict(eva))
+                    if bid and key:
+                        belief_items_by_id[bid] = dict(bi)
+                        belief_active_by_key[key] = bid
+                        _ensure_binding_create(
+                            turn_id=str(ut.get("turn_id") or ""),
+                            created_turn_index=int(ut.get("turn_index") or 0),
+                            binding_kind="belief",
+                            value={"belief_key": str(key)},
+                            value_preview=f"belief:{str(key)}",
+                            provenance={"ledger": "belief_ledger_v96", "source_event_id": str(eva.get("event_id") or "")},
+                        )
+                    belief_write_event_ids.extend([str(evr.get("event_id") or ""), str(eva.get("event_id") or "")])
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"belief_ack_text": render_belief_revised_ack_text_v96(key=key, old_id=old_id, new_id=bid)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"revise_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_BELIEF_LIST_V96:
+            if bool(parse.get("parse_ok", False)):
+                beliefs_active = _active_beliefs_by_key()
+                belief_read_keys = sorted(beliefs_active.keys(), key=str)
+                belief_read_ids = [str(beliefs_active[k].get("belief_id") or "") for k in belief_read_keys if isinstance(beliefs_active.get(k), dict)]
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"belief_text": render_beliefs_text_v96(beliefs_active)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"beliefs_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_BELIEF_FORGET_V96:
+            if bool(parse.get("parse_ok", False)):
+                key = str(parse.get("belief_key") or "").strip()
+                old_id = str(belief_active_by_key.get(key) or "")
+                if not old_id:
+                    objective_kind = "COMM_CORRECT"
+                    ctx2 = {"msg": "missing_key"}
+                else:
+                    belief_read_keys = [str(key)]
+                    belief_read_ids = [str(old_id)]
+                    ev = BeliefEventV96(
+                        conversation_id=str(conversation_id),
+                        event_kind="RETRACT",
+                        created_step=int(step),
+                        source_turn_id=str(ut.get("turn_id") or ""),
+                        target_belief_id=str(old_id),
+                        retract_reason="user_forget_belief",
+                    ).to_dict()
+                    prev_belief_hash = append_chained_jsonl_v96(belief_path, dict(ev), prev_hash=prev_belief_hash)
+                    belief_events.append(dict(ev))
+                    belief_active_by_key.pop(str(key), None)
+                    belief_write_event_ids.append(str(ev.get("event_id") or ""))
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"belief_ack_text": render_belief_retracted_ack_text_v96(belief_id=old_id, key=key)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"forget_belief_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_TEACH_V93:
+            teach_ok = bool(parse.get("teach_ok", False))
+            teach_reason = str(parse.get("reason") or "")
+            if teach_ok:
+                objective_kind = "COMM_RESPOND"
+                lrid = str(parse.get("learned_rule_id") or "")
+                rhs_intent_id = str(parse.get("rhs_intent_id") or "")
+                lhs_raw = str(parse.get("lhs_raw") or "")
+                ack = f'Aprendido: "{lhs_raw}" → {rhs_intent_id} (rule_id={lrid})'
+                ctx2 = {"teach_ack_text": str(ack)}
+            elif teach_reason == "ambiguous":
+                objective_kind = "COMM_CONFIRM"
+                ctx2 = {"ambiguous": list(ctx.get("ambiguous") if isinstance(ctx.get("ambiguous"), list) else [])}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"teach_reject:{teach_reason}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_STYLE_PROFILE_V102:
+            if bool(parse.get("parse_ok", False)):
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"style_profile_text": str(ctx.get("style_profile_text") or render_style_profile_text_v102(style_profile))}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"style_profile_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_TEMPLATES_V102:
+            if bool(parse.get("parse_ok", False)):
+                stats_now = fold_template_stats_v102(templates=list(templates_v102), style_events=list(style_events))
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"templates_text": render_templates_list_text_v102(templates=list(templates_v102), template_stats=dict(stats_now))}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"templates_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_EXPLAIN_STYLE_V102:
+            if bool(parse.get("parse_ok", False)) and str(ctx.get("explain_style_text") or ""):
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"explain_style_text": str(ctx.get("explain_style_text") or "")}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"explain_style_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_TRACE_STYLE_V102:
+            if bool(parse.get("parse_ok", False)) and str(ctx.get("trace_style_text") or ""):
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"trace_style_text": str(ctx.get("trace_style_text") or "")}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"trace_style_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_BINDINGS_LIST_V101:
+            if bool(parse.get("parse_ok", False)):
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"bindings_text": render_bindings_text_v101(_active_bindings_list())}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"bindings_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_EXPLAIN_BINDING_V101:
+            if bool(parse.get("parse_ok", False)):
+                bid = str(parse.get("binding_id") or "")
+                b = _binding_get(str(bid))
+                if not isinstance(b, dict):
+                    objective_kind = "COMM_CORRECT"
+                    ctx2 = {"msg": "binding_not_found"}
+                else:
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"binding_explain_text": render_explain_binding_text_v101(b)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"explain_binding_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_TRACE_REF_V101:
+            if bool(parse.get("parse_ok", False)):
+                tid = str(parse.get("turn_id") or "")
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"trace_ref_text": render_trace_ref_text_v101(turn_id=str(tid), binding_events=list(binding_events))}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"trace_ref_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_PLAN_CREATE_V101:
+            if bool(parse.get("parse_ok", False)):
+                target = str(parse.get("target") or "").strip()
+                if not target:
+                    objective_kind = "COMM_CORRECT"
+                    ctx2 = {"msg": "missing_target"}
+                else:
+                    # Create a goal ledger entry (deterministic, internal) and bind it.
+                    gid = goal_id_v99(conversation_id=str(conversation_id), ts_turn_index=int(ut.get("turn_index") or 0), text=str(target), parent_goal_id="")
+                    ge = GoalEventV99(
+                        conversation_id=str(conversation_id),
+                        ts_turn_index=int(ut.get("turn_index") or 0),
+                        op="GOAL_ADD",
+                        goal_id=str(gid),
+                        parent_goal_id="",
+                        priority=100,
+                        status="active",
+                        text=str(target),
+                        cause_type="user_intent",
+                        cause_id=str(parse.get("parse_sig") or ""),
+                        created_step=int(step),
+                        prev_event_sig=str(prev_goal_event_sig),
+                    ).to_dict()
+                    prev_goal_event_sig = str(ge.get("event_sig") or prev_goal_event_sig)
+                    prev_goal_hash = append_chained_jsonl_v96(
+                        goal_path,
+                        {"time": deterministic_iso(step=int(ge["created_step"])), "step": int(ge["created_step"]), "event": "GOAL", "payload": dict(ge)},
+                        prev_hash=prev_goal_hash,
+                    )
+                    goal_events.append(dict(ge))
+                    goal_write_ids.append(str(gid))
+                    # Bind the goal pointer.
+                    _ensure_binding_create(
+                        turn_id=str(ut.get("turn_id") or ""),
+                        created_turn_index=int(ut.get("turn_index") or 0),
+                        binding_kind="goal",
+                        value={"goal_id": str(gid), "goal_text": str(target)},
+                        value_preview=f"goal:{str(target)}",
+                        provenance={"ledger": "goal_ledger_v99", "source_event_id": str(ge.get("event_id") or "")},
+                    )
+                    # Create a plan object (3 steps) and bind it.
+                    steps = [
+                        f"1) Definir objetivo: {target}",
+                        f"2) Executar ação principal para: {target}",
+                        f"3) Verificar resultado de: {target}",
+                    ]
+                    plan_obj = {"schema_version": 101, "kind": "plan_v101", "goal_id": str(gid), "goal_text": str(target), "steps": list(steps)}
+                    pbid = _ensure_binding_create(
+                        turn_id=str(ut.get("turn_id") or ""),
+                        created_turn_index=int(ut.get("turn_index") or 0),
+                        binding_kind="plan",
+                        value=dict(plan_obj),
+                        value_preview=f"plan(3):{str(target)}",
+                        provenance={"ledger": "plan_v101", "source_event_id": str(_stable_hash_obj(plan_obj))},
+                    )
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"plan_text": "PLAN(3):\n" + "\n".join(steps), "plan_binding_id": str(pbid), "goal_id": str(gid)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"plan_create_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_PLAN_SHORTEN_REF_V101:
+            if bool(parse.get("parse_ok", False)):
+                pron = str(parse.get("pronoun") or "")
+                goals_active_by_id, _gdet = fold_goal_ledger_v99(list(goal_events))
+                goals_active_ids = sorted([str(k) for k in goals_active_by_id.keys() if str(k)], key=str)
+                res = resolve_reference_v101(
+                    pronoun=str(pron),
+                    kind_hint="plan",
+                    bindings_active=_active_bindings_list(),
+                    current_user_turn_index=int(ut.get("turn_index") or 0),
+                    goals_active_ids=list(goals_active_ids),
+                )
+                status = str(res.get("status") or "")
+                if status == "RESOLVED":
+                    chosen_bid = str(res.get("chosen_binding_id") or "")
+                    b = _binding_get(chosen_bid)
+                    if not isinstance(b, dict):
+                        objective_kind = "COMM_CORRECT"
+                        ctx2 = {"msg": "binding_not_found"}
+                    else:
+                        _binding_use(turn_id=str(ut.get("turn_id") or ""), user_turn_index=int(ut.get("turn_index") or 0), resolution=dict(res), chosen_binding_id=str(chosen_bid))
+                        pval = b.get("value") if isinstance(b.get("value"), dict) else {}
+                        gtxt = str(pval.get("goal_text") or "")
+                        gid = str(pval.get("goal_id") or "")
+                        steps2 = [f"1) Executar: {gtxt}", f"2) Verificar: {gtxt}"]
+                        plan2 = {"schema_version": 101, "kind": "plan_v101", "goal_id": str(gid), "goal_text": str(gtxt), "steps": list(steps2)}
+                        _ensure_binding_create(
+                            turn_id=str(ut.get("turn_id") or ""),
+                            created_turn_index=int(ut.get("turn_index") or 0),
+                            binding_kind="plan",
+                            value=dict(plan2),
+                            value_preview=f"plan(2):{str(gtxt)}",
+                            provenance={"ledger": "plan_v101", "source_event_id": str(_stable_hash_obj(plan2))},
+                        )
+                        objective_kind = "COMM_RESPOND"
+                        ctx2 = {"plan_text": "PLAN(2):\n" + "\n".join(steps2)}
+                elif status == "AMBIGUOUS":
+                    ev_amb = make_binding_ambiguous_event_v101(
+                        conversation_id=str(conversation_id),
+                        ts_logical=int(binding_ts_logical),
+                        turn_id=str(ut.get("turn_id") or ""),
+                        pronoun=str(pron),
+                        resolution=dict(res),
+                        created_step=int(step),
+                        prev_event_sig=str(prev_binding_event_sig),
+                    )
+                    _append_binding_event(ev_amb)
+                    objective_kind = "COMM_CONFIRM"
+                    cands = res.get("candidates") if isinstance(res.get("candidates"), list) else []
+                    opts = [f"{i+1}) {str(c.get('value_preview') or '')}" for i, c in enumerate(cands[:3]) if isinstance(c, dict)]
+                    ctx2 = {"msg": "Referência ambígua. Qual você quer dizer? " + "; ".join(opts)}
+                else:
+                    ev_miss = make_binding_miss_event_v101(
+                        conversation_id=str(conversation_id),
+                        ts_logical=int(binding_ts_logical),
+                        turn_id=str(ut.get("turn_id") or ""),
+                        pronoun=str(pron),
+                        resolution=dict(res),
+                        created_step=int(step),
+                        prev_event_sig=str(prev_binding_event_sig),
+                    )
+                    _append_binding_event(ev_miss)
+                    objective_kind = "COMM_ASK_CLARIFY"
+                    ctx2 = {"missing_ref": str(pron)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"shorten_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_GOAL_PRIORITY_HIGH_REF_V101:
+            if bool(parse.get("parse_ok", False)):
+                pron = str(parse.get("pronoun") or "")
+                goals_active_by_id, _gdet = fold_goal_ledger_v99(list(goal_events))
+                goals_active_ids = sorted([str(k) for k in goals_active_by_id.keys() if str(k)], key=str)
+                res = resolve_reference_v101(
+                    pronoun=str(pron),
+                    kind_hint="goal",
+                    bindings_active=_active_bindings_list(),
+                    current_user_turn_index=int(ut.get("turn_index") or 0),
+                    goals_active_ids=list(goals_active_ids),
+                )
+                status = str(res.get("status") or "")
+                if status == "RESOLVED":
+                    chosen_bid = str(res.get("chosen_binding_id") or "")
+                    b = _binding_get(chosen_bid)
+                    if not isinstance(b, dict):
+                        objective_kind = "COMM_CORRECT"
+                        ctx2 = {"msg": "binding_not_found"}
+                    else:
+                        _binding_use(turn_id=str(ut.get("turn_id") or ""), user_turn_index=int(ut.get("turn_index") or 0), resolution=dict(res), chosen_binding_id=str(chosen_bid))
+                        gval = b.get("value") if isinstance(b.get("value"), dict) else {}
+                        gid = str(gval.get("goal_id") or "")
+                        gtxt = str(gval.get("goal_text") or "")
+                        if not gid:
+                            objective_kind = "COMM_CORRECT"
+                            ctx2 = {"msg": "goal_id_missing_in_binding"}
+                        else:
+                            ge2 = GoalEventV99(
+                                conversation_id=str(conversation_id),
+                                ts_turn_index=int(ut.get("turn_index") or 0),
+                                op="GOAL_UPDATE",
+                                goal_id=str(gid),
+                                parent_goal_id="",
+                                priority=200,
+                                status="active",
+                                text=str(gtxt),
+                                cause_type="user_intent",
+                                cause_id=str(parse.get("parse_sig") or ""),
+                                created_step=int(step),
+                                prev_event_sig=str(prev_goal_event_sig),
+                            ).to_dict()
+                            prev_goal_event_sig = str(ge2.get("event_sig") or prev_goal_event_sig)
+                            prev_goal_hash = append_chained_jsonl_v96(
+                                goal_path,
+                                {"time": deterministic_iso(step=int(ge2["created_step"])), "step": int(ge2["created_step"]), "event": "GOAL", "payload": dict(ge2)},
+                                prev_hash=prev_goal_hash,
+                            )
+                            goal_events.append(dict(ge2))
+                            goal_write_ids.append(str(gid))
+                            objective_kind = "COMM_RESPOND"
+                            ctx2 = {"msg": f"OK: goal_priority_high goal_id={gid}"}
+                elif status == "AMBIGUOUS":
+                    ev_amb = make_binding_ambiguous_event_v101(
+                        conversation_id=str(conversation_id),
+                        ts_logical=int(binding_ts_logical),
+                        turn_id=str(ut.get("turn_id") or ""),
+                        pronoun=str(pron),
+                        resolution=dict(res),
+                        created_step=int(step),
+                        prev_event_sig=str(prev_binding_event_sig),
+                    )
+                    _append_binding_event(ev_amb)
+                    objective_kind = "COMM_CONFIRM"
+                    cands = res.get("candidates") if isinstance(res.get("candidates"), list) else []
+                    opts = [f"{i+1}) {str(c.get('value_preview') or '')}" for i, c in enumerate(cands[:3]) if isinstance(c, dict)]
+                    ctx2 = {"msg": "Referência ambígua. Qual você quer dizer? " + "; ".join(opts)}
+                else:
+                    ev_miss = make_binding_miss_event_v101(
+                        conversation_id=str(conversation_id),
+                        ts_logical=int(binding_ts_logical),
+                        turn_id=str(ut.get("turn_id") or ""),
+                        pronoun=str(pron),
+                        resolution=dict(res),
+                        created_step=int(step),
+                        prev_event_sig=str(prev_binding_event_sig),
+                    )
+                    _append_binding_event(ev_miss)
+                    objective_kind = "COMM_ASK_CLARIFY"
+                    ctx2 = {"missing_ref": str(pron)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"priority_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_EXPLAIN_V94:
+            if bool(parse.get("parse_ok", False)) and str(parse.get("explained_plan_id") or ""):
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"explain_text": str(ctx.get("explain_text") or "")}
+            else:
+                r = str(parse.get("reason") or "")
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"explain_reject:{r or 'parse_fail'}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_SYSTEM_V98:
+            if bool(parse.get("parse_ok", False)):
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"system_text": render_system_text_v97(system_spec)}
+            else:
+                r = str(parse.get("reason") or "")
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"system_reject:{r or 'parse_fail'}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_DISCOURSE_V100:
+            if bool(parse.get("parse_ok", False)):
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"discourse_text": render_discourse_text_v100(dict(discourse_state))}
+            else:
+                r = str(parse.get("reason") or "")
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"discourse_reject:{r or 'parse_fail'}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_WHY_REF_V100:
+            if bool(parse.get("parse_ok", False)):
+                keys = sorted([str(k) for k in belief_active_by_key.keys() if isinstance(k, str) and k])
+                if len(keys) >= 2:
+                    objective_kind = "COMM_CONFIRM"
+                    txt = "Qual chave? " + "; ".join(keys[:5])
+                    ctx2 = {"why_ref_text": str(txt), "open_question_keys": list(keys[:5])}
+                elif len(keys) == 1:
+                    objective_kind = "COMM_RESPOND"
+                    txt2 = render_why_belief_text_v98(key=str(keys[0]), belief_events=belief_events, evidence_events=evidence_events, step=int(step))
+                    ctx2 = {"why_ref_text": str(txt2)}
+                else:
+                    objective_kind = "COMM_ADMIT_UNKNOWN"
+                    ctx2 = {}
+            else:
+                r = str(parse.get("reason") or "")
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"why_ref_reject:{r or 'parse_fail'}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_EVIDENCE_ADD_V98:
+            if bool(parse.get("parse_ok", False)):
+                ekey = str(parse.get("evidence_key") or "").strip()
+                eval0 = str(parse.get("evidence_value") or "").strip()
+                # 1) Always append evidence to evidence ledger.
+                ei = EvidenceItemV98(
+                    conversation_id=str(conversation_id),
+                    evidence_kind="OBSERVE",
+                    evidence_key=str(ekey),
+                    evidence_value=str(eval0),
+                    source_turn_id=str(ut.get("turn_id") or ""),
+                    created_step=int(step),
+                ).to_dict()
+                evidence_id = str(ei.get("evidence_id") or "")
+                ee = EvidenceEventV98(
+                    conversation_id=str(conversation_id),
+                    evidence_item=dict(ei),
+                    created_step=int(step),
+                    source_turn_id=str(ut.get("turn_id") or ""),
+                ).to_dict()
+                prev_evidence_hash = append_chained_jsonl_v96(evidence_path, dict(ee), prev_hash=prev_evidence_hash)
+                evidence_events.append(dict(ee))
+                if evidence_id:
+                    evidence_write_ids.append(str(evidence_id))
+
+                # 2) Deterministic belief revision driven by evidence.
+                belief_changed = False
+                ack_lines: List[str] = [render_evidence_added_ack_text_v98(evidence_id=str(evidence_id), key=str(ekey))]
+                if ekey in belief_active_by_key:
+                    old_bid = str(belief_active_by_key.get(ekey) or "")
+                    old_bi = belief_items_by_id.get(old_bid) if old_bid else None
+                    old_val = str(old_bi.get("belief_value") or "") if isinstance(old_bi, dict) else ""
+                    if old_val != eval0:
+                        # RETRACT(old) then ADD(new), both bound to cause evidence.
+                        retract_sem = {
+                            "schema_version": 96,
+                            "kind": "belief_event_v96",
+                            "conversation_id": str(conversation_id),
+                            "event_kind": "RETRACT",
+                            "created_step": int(step),
+                            "created_at": deterministic_iso(step=int(step)),
+                            "source_turn_id": str(ut.get("turn_id") or ""),
+                            "belief_item": None,
+                            "target_belief_id": str(old_bid),
+                            "retract_reason": "evidence_observe",
+                            "cause_evidence_id": str(evidence_id),
+                            "cause_evidence_key": str(ekey),
+                            "cause_evidence_value": str(eval0),
+                        }
+                        rsig = belief_event_sig_v96(dict(retract_sem))
+                        rid = belief_event_id_v96(rsig)
+                        retract_ev = dict(retract_sem, event_sig=str(rsig), event_id=str(rid))
+                        prev_belief_hash = append_chained_jsonl_v96(belief_path, dict(retract_ev), prev_hash=prev_belief_hash)
+                        belief_events.append(dict(retract_ev))
+                        belief_write_event_ids.append(str(retract_ev.get("event_id") or ""))
+                        belief_active_by_key.pop(str(ekey), None)
+
+                        bi_new = BeliefItemV96(
+                            conversation_id=str(conversation_id),
+                            belief_key=str(ekey),
+                            belief_value=str(eval0),
+                            source_turn_id=str(ut.get("turn_id") or ""),
+                            created_step=int(step),
+                        ).to_dict()
+                        new_bid = str(bi_new.get("belief_id") or "")
+                        if new_bid:
+                            belief_items_by_id[new_bid] = dict(bi_new)
+                            belief_active_by_key[str(ekey)] = str(new_bid)
+                        add_sem = {
+                            "schema_version": 96,
+                            "kind": "belief_event_v96",
+                            "conversation_id": str(conversation_id),
+                            "event_kind": "ADD",
+                            "created_step": int(step),
+                            "created_at": deterministic_iso(step=int(step)),
+                            "source_turn_id": str(ut.get("turn_id") or ""),
+                            "belief_item": dict(bi_new),
+                            "target_belief_id": "",
+                            "retract_reason": "",
+                            "cause_evidence_id": str(evidence_id),
+                            "cause_evidence_key": str(ekey),
+                            "cause_evidence_value": str(eval0),
+                        }
+                        asig = belief_event_sig_v96(dict(add_sem))
+                        aid = belief_event_id_v96(asig)
+                        add_ev = dict(add_sem, event_sig=str(asig), event_id=str(aid))
+                        prev_belief_hash = append_chained_jsonl_v96(belief_path, dict(add_ev), prev_hash=prev_belief_hash)
+                        belief_events.append(dict(add_ev))
+                        belief_write_event_ids.append(str(add_ev.get("event_id") or ""))
+                        belief_changed = True
+                        cause_evidence_ids = [str(evidence_id)] if evidence_id else []
+                        ack_lines.append(render_belief_revised_ack_text_v96(key=str(ekey), old_id=str(old_bid), new_id=str(new_bid)))
+                    else:
+                        # Evidence matches current belief: no belief update.
+                        belief_changed = False
+                else:
+                    bi_new = BeliefItemV96(
+                        conversation_id=str(conversation_id),
+                        belief_key=str(ekey),
+                        belief_value=str(eval0),
+                        source_turn_id=str(ut.get("turn_id") or ""),
+                        created_step=int(step),
+                    ).to_dict()
+                    new_bid = str(bi_new.get("belief_id") or "")
+                    if new_bid:
+                        belief_items_by_id[new_bid] = dict(bi_new)
+                        belief_active_by_key[str(ekey)] = str(new_bid)
+                    add_sem = {
+                        "schema_version": 96,
+                        "kind": "belief_event_v96",
+                        "conversation_id": str(conversation_id),
+                        "event_kind": "ADD",
+                        "created_step": int(step),
+                        "created_at": deterministic_iso(step=int(step)),
+                        "source_turn_id": str(ut.get("turn_id") or ""),
+                        "belief_item": dict(bi_new),
+                        "target_belief_id": "",
+                        "retract_reason": "",
+                        "cause_evidence_id": str(evidence_id),
+                        "cause_evidence_key": str(ekey),
+                        "cause_evidence_value": str(eval0),
+                    }
+                    asig = belief_event_sig_v96(dict(add_sem))
+                    aid = belief_event_id_v96(asig)
+                    add_ev = dict(add_sem, event_sig=str(asig), event_id=str(aid))
+                    prev_belief_hash = append_chained_jsonl_v96(belief_path, dict(add_ev), prev_hash=prev_belief_hash)
+                    belief_events.append(dict(add_ev))
+                    belief_write_event_ids.append(str(add_ev.get("event_id") or ""))
+                    belief_changed = True
+                    cause_evidence_ids = [str(evidence_id)] if evidence_id else []
+                    ack_lines.append(render_belief_added_ack_text_v96(belief_id=str(new_bid), key=str(ekey)))
+
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"evidence_text": "\n".join([ln for ln in ack_lines if isinstance(ln, str) and ln])}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"evidence_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_EVIDENCE_LIST_V98:
+            if bool(parse.get("parse_ok", False)):
+                evs_at = [dict(ev) for ev in evidence_events if isinstance(ev, dict) and int(ev.get("created_step", -1) or -1) <= int(step)]
+                evidence_read_ids = sorted(
+                    {
+                        str(it.get("evidence_id") or "")
+                        for ev in evs_at
+                        for it in [ev.get("evidence_item")]
+                        if isinstance(it, dict) and str(it.get("evidence_id") or "")
+                    }
+                )
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"evidences_text": render_evidences_text_v98(evs_at)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"evidences_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_WHY_V98:
+            if bool(parse.get("parse_ok", False)):
+                wkey = str(parse.get("key") or "").strip()
+                beliefs_active2 = _active_beliefs_by_key()
+                if wkey and (wkey in beliefs_active2):
+                    bit = beliefs_active2.get(wkey) if isinstance(beliefs_active2.get(wkey), dict) else {}
+                    belief_read_keys = [str(wkey)]
+                    belief_read_ids = [str(bit.get("belief_id") or "")] if str(bit.get("belief_id") or "") else []
+                    # Best-effort: include the last cause_evidence_id for this key (if any).
+                    ceid = ""
+                    for bev in reversed(list(belief_events)):
+                        if not isinstance(bev, dict):
+                            continue
+                        try:
+                            cstep = int(bev.get("created_step", -1))
+                        except Exception:
+                            cstep = -1
+                        if cstep < 0 or cstep > int(step):
+                            continue
+                        if str(bev.get("event_kind") or "") != "ADD":
+                            continue
+                        bi = bev.get("belief_item")
+                        if not isinstance(bi, dict):
+                            continue
+                        if str(bi.get("belief_key") or "").strip() != str(wkey):
+                            continue
+                        ceid = str(bev.get("cause_evidence_id") or "")
+                        if ceid:
+                            break
+                    if ceid:
+                        evidence_read_ids = [str(ceid)]
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {
+                    "why_text": render_why_belief_text_v98(
+                        key=str(wkey), belief_events=list(belief_events), evidence_events=list(evidence_events), step=int(step)
+                    )
+                }
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"why_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_VERSIONS_V98:
+            if bool(parse.get("parse_ok", False)):
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"versions_text": render_versions_text_v98(repo_root=str(repo_root))}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"versions_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_DOSSIER_V98:
+            if bool(parse.get("parse_ok", False)):
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"dossier_text": render_dossier_text_v100()}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"dossier_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_GOAL_ADD_V99:
+            if bool(parse.get("parse_ok", False)):
+                gtext = str(parse.get("goal_text") or "").strip()
+                if not gtext:
+                    objective_kind = "COMM_CORRECT"
+                    ctx2 = {"msg": "empty_goal_text"}
+                else:
+                    gid = goal_id_v99(conversation_id=str(conversation_id), ts_turn_index=int(ut.get("turn_index") or 0), text=str(gtext), parent_goal_id="")
+                    ev = GoalEventV99(
+                        conversation_id=str(conversation_id),
+                        ts_turn_index=int(ut.get("turn_index") or 0),
+                        op="GOAL_ADD",
+                        goal_id=str(gid),
+                        parent_goal_id="",
+                        priority=100,
+                        status="active",
+                        text=str(gtext),
+                        cause_type="user_intent",
+                        cause_id=str(ut.get("turn_id") or ""),
+                        created_step=int(step),
+                        prev_event_sig=str(prev_goal_event_sig),
+                    ).to_dict()
+                    prev_goal_hash = append_chained_jsonl_v96(
+                        goal_path,
+                        {"time": deterministic_iso(step=int(step)), "step": int(step), "event": "GOAL_EVENT", "payload": dict(ev)},
+                        prev_hash=prev_goal_hash,
+                    )
+                    goal_events.append(dict(ev))
+                    prev_goal_event_sig = str(ev.get("event_sig") or "")
+                    goal_write_ids = [str(gid)]
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"goal_ack_text": render_goal_added_ack_text_v99(str(gid))}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"goal_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_GOAL_LIST_V99:
+            if bool(parse.get("parse_ok", False)):
+                snap = goal_ledger_snapshot_v99(list(goal_events))
+                goals_active = snap.get("goals_active") if isinstance(snap.get("goals_active"), list) else []
+                goal_read_ids = [str(it.get("goal_id") or "") for it in goals_active if isinstance(it, dict) and str(it.get("goal_id") or "")]
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"goals_text": render_goals_text_v99(goals_active)}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"goals_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_GOAL_DONE_V99:
+            if bool(parse.get("parse_ok", False)):
+                target_gid = str(parse.get("goal_id") or "")
+                active_by_id, _gdetails = fold_goal_ledger_v99(list(goal_events))
+                cur = active_by_id.get(target_gid) if isinstance(active_by_id.get(target_gid), dict) else {}
+                if not target_gid or not cur:
+                    objective_kind = "COMM_CORRECT"
+                    ctx2 = {"msg": "missing_goal"}
+                else:
+                    ev = GoalEventV99(
+                        conversation_id=str(conversation_id),
+                        ts_turn_index=int(ut.get("turn_index") or 0),
+                        op="GOAL_DONE",
+                        goal_id=str(target_gid),
+                        parent_goal_id=str(cur.get("parent_goal_id") or ""),
+                        priority=int(cur.get("priority") or 0),
+                        status="done",
+                        text=str(cur.get("text") or ""),
+                        cause_type="user_intent",
+                        cause_id=str(ut.get("turn_id") or ""),
+                        created_step=int(step),
+                        prev_event_sig=str(prev_goal_event_sig),
+                    ).to_dict()
+                    prev_goal_hash = append_chained_jsonl_v96(
+                        goal_path,
+                        {"time": deterministic_iso(step=int(step)), "step": int(step), "event": "GOAL_EVENT", "payload": dict(ev)},
+                        prev_hash=prev_goal_hash,
+                    )
+                    goal_events.append(dict(ev))
+                    prev_goal_event_sig = str(ev.get("event_sig") or "")
+                    goal_read_ids = [str(target_gid)]
+                    goal_write_ids = [str(target_gid)]
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"goal_done_text": render_goal_done_ack_text_v99(str(target_gid))}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"done_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_GOAL_NEXT_V99:
+            if bool(parse.get("parse_ok", False)):
+                active_by_id2, _gdetails2 = fold_goal_ledger_v99(list(goal_events))
+                goals_active2 = [dict(active_by_id2[k]) for k in sorted(active_by_id2.keys(), key=str) if isinstance(active_by_id2.get(k), dict)]
+                goals_active2.sort(key=lambda d: (-int(d.get("priority") or 0), int(d.get("created_ts_turn_index") or 0), str(d.get("goal_id") or "")))
+                if not goals_active2:
+                    ta = {"tick_index": 0, "selected_goal_id": "", "effect": "no_active_goals", "subgoal_id": ""}
+                    goal_tick_actions = [dict(ta)]
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"next_text": render_next_text_v99(dict(ta))}
+                else:
+                    sel = dict(goals_active2[0])
+                    sel_gid = str(sel.get("goal_id") or "")
+                    sub_text = f"subgoal_tick0_for:{sel_gid}"
+                    sub_gid = goal_id_v99(
+                        conversation_id=str(conversation_id),
+                        ts_turn_index=int(ut.get("turn_index") or 0),
+                        text=str(sub_text),
+                        parent_goal_id=str(sel_gid),
+                    )
+                    ev = GoalEventV99(
+                        conversation_id=str(conversation_id),
+                        ts_turn_index=int(ut.get("turn_index") or 0),
+                        op="GOAL_ADD",
+                        goal_id=str(sub_gid),
+                        parent_goal_id=str(sel_gid),
+                        priority=max(0, int(sel.get("priority") or 0) - 1),
+                        status="active",
+                        text=str(sub_text),
+                        cause_type="user_intent",
+                        cause_id=str(ut.get("turn_id") or ""),
+                        created_step=int(step),
+                        prev_event_sig=str(prev_goal_event_sig),
+                    ).to_dict()
+                    prev_goal_hash = append_chained_jsonl_v96(
+                        goal_path,
+                        {"time": deterministic_iso(step=int(step)), "step": int(step), "event": "GOAL_EVENT", "payload": dict(ev)},
+                        prev_hash=prev_goal_hash,
+                    )
+                    goal_events.append(dict(ev))
+                    prev_goal_event_sig = str(ev.get("event_sig") or "")
+                    goal_read_ids = [str(sel_gid)]
+                    goal_write_ids = [str(sub_gid)]
+                    ta2 = {"tick_index": 0, "selected_goal_id": str(sel_gid), "effect": "created_subgoal", "subgoal_id": str(sub_gid)}
+                    goal_tick_actions = [dict(ta2)]
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"next_text": render_next_text_v99(dict(ta2))}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"next_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_GOAL_AUTO_V99:
+            if bool(parse.get("parse_ok", False)):
+                n = int(parse.get("n") or 0)
+                if n <= 0:
+                    objective_kind = "COMM_CORRECT"
+                    ctx2 = {"msg": "auto_bad_n"}
+                else:
+                    tick_actions: List[Dict[str, Any]] = []
+                    for ti in range(int(n)):
+                        active_by_id3, _gdetails3 = fold_goal_ledger_v99(list(goal_events))
+                        goals_active3 = [dict(active_by_id3[k]) for k in sorted(active_by_id3.keys(), key=str) if isinstance(active_by_id3.get(k), dict)]
+                        goals_active3.sort(
+                            key=lambda d: (-int(d.get("priority") or 0), int(d.get("created_ts_turn_index") or 0), str(d.get("goal_id") or ""))
+                        )
+                        if not goals_active3:
+                            tick_actions.append({"tick_index": int(ti), "selected_goal_id": "", "effect": "no_active_goals", "subgoal_id": ""})
+                            continue
+                        sel3 = dict(goals_active3[0])
+                        sel_gid3 = str(sel3.get("goal_id") or "")
+                        sub_text3 = f"subgoal_tick{int(ti)}_for:{sel_gid3}"
+                        sub_gid3 = goal_id_v99(
+                            conversation_id=str(conversation_id),
+                            ts_turn_index=int(ut.get("turn_index") or 0),
+                            text=str(sub_text3),
+                            parent_goal_id=str(sel_gid3),
+                        )
+                        ev3 = GoalEventV99(
+                            conversation_id=str(conversation_id),
+                            ts_turn_index=int(ut.get("turn_index") or 0),
+                            op="GOAL_ADD",
+                            goal_id=str(sub_gid3),
+                            parent_goal_id=str(sel_gid3),
+                            priority=max(0, int(sel3.get("priority") or 0) - 1),
+                            status="active",
+                            text=str(sub_text3),
+                            cause_type="user_intent",
+                            cause_id=str(ut.get("turn_id") or ""),
+                            created_step=int(step),
+                            prev_event_sig=str(prev_goal_event_sig),
+                        ).to_dict()
+                        prev_goal_hash = append_chained_jsonl_v96(
+                            goal_path,
+                            {"time": deterministic_iso(step=int(step)), "step": int(step), "event": "GOAL_EVENT", "payload": dict(ev3)},
+                            prev_hash=prev_goal_hash,
+                        )
+                        goal_events.append(dict(ev3))
+                        prev_goal_event_sig = str(ev3.get("event_sig") or "")
+                        goal_read_ids.append(str(sel_gid3))
+                        goal_write_ids.append(str(sub_gid3))
+                        tick_actions.append(
+                            {"tick_index": int(ti), "selected_goal_id": str(sel_gid3), "effect": "created_subgoal", "subgoal_id": str(sub_gid3)}
+                        )
+                    goal_read_ids = sorted(set([str(x) for x in goal_read_ids if isinstance(x, str) and x]))
+                    goal_write_ids = sorted(set([str(x) for x in goal_write_ids if isinstance(x, str) and x]))
+                    goal_tick_actions = [dict(x) for x in tick_actions]
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"auto_text": render_auto_text_v99(goal_tick_actions, int(n))}
+            else:
+                objective_kind = "COMM_CORRECT"
+                ctx2 = {"msg": f"auto_reject:{str(parse.get('reason') or '')}"}
+
+        elif str(parse.get("intent_id") or "") == INTENT_UNKNOWN_V92:
+            # V102: style-only user messages (meta preference updates) are treated as valid,
+            # deterministic actions when they would otherwise be "no_match". This persists the
+            # style_profile in conversation state without executing DSL state mutations.
+            if (not bool(parse.get("parse_ok", False))) and isinstance(style_profile_updates, list) and style_profile_updates:
+                reasons = [str(u.get("reason") or "") for u in style_profile_updates if isinstance(u, dict)]
+                reasons = sorted(set([r for r in reasons if r]))
+                if "user_confusion_signal" in set(reasons):
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"style_ack_text": "Entendi. Qual parte ficou confusa?"}
+                else:
+                    objective_kind = "COMM_RESPOND"
+                    ctx2 = {"style_ack_text": "OK: estilo atualizado."}
+            else:
+                # Reference resolution attempt for bare deictics/pronouns (fail-closed).
+                toks = [t for t in normalize_text_v96(str(user_text)).lower().split() if t]
+                pron = ""
+                for p in ["isso", "aquilo", "isto", "this", "that", "it"]:
+                    if p in toks:
+                        pron = str(p)
+                        break
+                if pron:
+                    goals_active_by_id, _gdet = fold_goal_ledger_v99(list(goal_events))
+                    goals_active_ids = sorted([str(k) for k in goals_active_by_id.keys() if str(k)], key=str)
+                    kind_hint = infer_kind_hint_v101(tokens=list(toks))
+                    res = resolve_reference_v101(
+                        pronoun=str(pron),
+                        kind_hint=str(kind_hint),
+                        bindings_active=_active_bindings_list(),
+                        current_user_turn_index=int(ut.get("turn_index") or 0),
+                        goals_active_ids=list(goals_active_ids),
+                    )
+                    status = str(res.get("status") or "")
+                    if status == "MISS":
+                        ev_miss = make_binding_miss_event_v101(
+                            conversation_id=str(conversation_id),
+                            ts_logical=int(binding_ts_logical),
+                            turn_id=str(ut.get("turn_id") or ""),
+                            pronoun=str(pron),
+                            resolution=dict(res),
+                            created_step=int(step),
+                            prev_event_sig=str(prev_binding_event_sig),
+                        )
+                        _append_binding_event(ev_miss)
+                        objective_kind = "COMM_ASK_CLARIFY"
+                        ctx2 = {"missing_ref": str(pron), "binding_status": "MISS"}
+                    elif status == "RESOLVED":
+                        chosen_bid = str(res.get("chosen_binding_id") or "")
+                        if chosen_bid:
+                            _binding_use(
+                                turn_id=str(ut.get("turn_id") or ""),
+                                user_turn_index=int(ut.get("turn_index") or 0),
+                                resolution=dict(res),
+                                chosen_binding_id=str(chosen_bid),
+                            )
+                        objective_kind = "COMM_CONFIRM"
+                        ctx2 = {"confirm_text": f"Você quis dizer: {chosen_bid}?" if chosen_bid else "Confirme.", "binding_status": "RESOLVED"}
+                    else:
+                        ev_amb = make_binding_ambiguous_event_v101(
+                            conversation_id=str(conversation_id),
+                            ts_logical=int(binding_ts_logical),
+                            turn_id=str(ut.get("turn_id") or ""),
+                            pronoun=str(pron),
+                            resolution=dict(res),
+                            created_step=int(step),
+                            prev_event_sig=str(prev_binding_event_sig),
+                        )
+                        _append_binding_event(ev_amb)
+                        objective_kind = "COMM_CONFIRM"
+                        cands = res.get("candidates") if isinstance(res.get("candidates"), list) else []
+                        opts = [f"{i+1}) {str(c.get('value_preview') or '')}" for i, c in enumerate(cands[:3]) if isinstance(c, dict)]
+                        ctx2 = {"confirm_text": "Referência ambígua. Qual você quer dizer? " + "; ".join(opts), "binding_status": "AMBIGUOUS"}
+                else:
+                    objective_kind, ctx2 = _choose_comm_objective_v96(
+                        parse=dict(parse), vars_map=dict(vars_map), last_answer=last_answer, beliefs_by_key=dict(beliefs_active)
+                    )
+
+        else:
+            objective_kind, ctx2 = _choose_comm_objective_v96(
+                parse=dict(parse), vars_map=dict(vars_map), last_answer=last_answer, beliefs_by_key=dict(beliefs_active)
+            )
+
+        # Compound execution (same as V92/V95).
+        compound_stop_after = False
+        if bool(parse.get("compound", False)) and bool(parse.get("parse_ok", False)):
+            ok_comp, agg_text, info = _simulate_compound_execution_v96(
+                parse=dict(parse), vars_map=dict(vars_map), last_answer=last_answer, beliefs_by_key=dict(beliefs_active)
+            )
+            if ok_comp:
+                vars_map = dict(info.get("vars_map") or {})
+                last_answer = info.get("last_answer")
+                compound_stop_after = bool(info.get("stop_after", False))
+                objective_kind = "COMM_RESPOND"
+                ctx2 = {"compound": True, "compound_text": str(agg_text)}
+            else:
+                r = str(info.get("reason") or "")
+                if r == "segment_missing_key":
+                    objective_kind = "COMM_ASK_CLARIFY"
+                    ctx2 = {"missing_key": str(info.get("missing_key") or "")}
+                else:
+                    objective_kind = "COMM_CORRECT"
+                    ctx2 = {"reason": f"compound_exec_fail:{r}"}
+
+        # Apply DSL state mutation for non-compound, parse_ok and complete.
+        slots = parse.get("slots") if isinstance(parse.get("slots"), dict) else {}
+        if (not bool(parse.get("compound", False))) and bool(parse.get("parse_ok", False)) and not (parse.get("missing_slots") or []):
+            if str(parse.get("intent_id") or "") == INTENT_SET_V92:
+                k = str(slots.get("k") or "")
+                v = str(slots.get("v") or "")
+                if k and v:
+                    vars_map[k] = int(v) if _is_int_literal(v) else v
+            elif str(parse.get("intent_id") or "") == INTENT_ADD_V92:
+                a = str(slots.get("a") or "")
+                b = str(slots.get("b") or "")
+                va, _ra = _parse_int_or_var(vars_map=vars_map, tok=a, last_answer=last_answer)
+                vb, _rb = _parse_int_or_var(vars_map=vars_map, tok=b, last_answer=last_answer)
+                if va is not None and vb is not None:
+                    last_answer = int(int(va) + int(vb))
+
+        # GET reads belief if var missing.
+        if str(parse.get("intent_id") or "") == INTENT_GET_V92:
+            k = str(slots.get("k") or "")
+            if k and (k not in vars_map) and (k in beliefs_active):
+                it = beliefs_active.get(k) if isinstance(beliefs_active.get(k), dict) else {}
+                belief_read_keys = [str(k)]
+                belief_read_ids = [str(it.get("belief_id") or "")]
+
+        expected_text, action_inputs, hint_action_id = _build_expected_and_action_inputs_v96(
+            objective_kind=str(objective_kind),
+            parse=dict(parse),
+            vars_map=dict(vars_map),
+            last_answer=last_answer,
+            beliefs_by_key=dict(beliefs_active),
+            ctx=dict(ctx2),
+            user_text=str(user_text),
+        )
+
+        # Response kind for discourse + style.
+        intent_id0 = str(parse.get("intent_id") or "")
+        response_kind = "locked"
+        if str(objective_kind) in {"COMM_RESPOND", "COMM_SUMMARIZE"}:
+            response_kind = "respond"
+        elif str(objective_kind) in {"COMM_ASK_CLARIFY", "COMM_CONFIRM"}:
+            response_kind = "clarify"
+
+        # V102: style candidates (templates + critics) and deterministic selection.
+        binding_status = str(ctx2.get("binding_status") or "")
+        style_build = build_and_select_style_candidates_v102(
+            templates=list(templates_v102),
+            core_text=str(expected_text),
+            response_kind=str(response_kind),
+            style_profile=style_profile,
+            intent_id=str(intent_id0),
+            slots=dict(slots),
+            binding_status=str(binding_status),
+            recent_assistant_texts=[str(t.get("text") or "") for t in reversed(turns) if isinstance(t, dict) and str(t.get("role") or "") == "assistant"][:3],
+            recent_template_ids=list(recent_style_template_ids)[-5:],
+            seed=int(seed),
+            selection_salt=str(ut.get("turn_id") or ""),
+            top_k=8,
+        )
+        style_candidates_topk = style_build.get("candidates_topk") if isinstance(style_build.get("candidates_topk"), list) else []
+        style_selected = style_build.get("selected") if isinstance(style_build.get("selected"), dict) else {}
+        style_selection = style_build.get("selection") if isinstance(style_build.get("selection"), dict) else {}
+        # If this intent is a deterministic renderer/introspection command, do NOT allow style overrides:
+        # the assistant text must match the stable renderer output for verifiers.
+        style_lock_intents = {
+            INTENT_TEACH_V93,
+            INTENT_EXPLAIN_V94,
+            INTENT_NOTE_V96,
+            INTENT_RECALL_V96,
+            INTENT_FORGET_V96,
+            INTENT_BELIEF_ADD_V96,
+            INTENT_BELIEF_REVISE_V96,
+            INTENT_BELIEF_LIST_V96,
+            INTENT_BELIEF_FORGET_V96,
+            INTENT_SYSTEM_V98,
+            INTENT_VERSIONS_V98,
+            INTENT_DOSSIER_V98,
+            INTENT_EVIDENCE_ADD_V98,
+            INTENT_EVIDENCE_LIST_V98,
+            INTENT_WHY_V98,
+            INTENT_GOAL_ADD_V99,
+            INTENT_GOAL_LIST_V99,
+            INTENT_GOAL_DONE_V99,
+            INTENT_GOAL_NEXT_V99,
+            INTENT_GOAL_AUTO_V99,
+            INTENT_DISCOURSE_V100,
+            INTENT_WHY_REF_V100,
+            INTENT_BINDINGS_LIST_V101,
+            INTENT_EXPLAIN_BINDING_V101,
+            INTENT_TRACE_REF_V101,
+            INTENT_PLAN_CREATE_V101,
+            INTENT_PLAN_SHORTEN_REF_V101,
+            INTENT_GOAL_PRIORITY_HIGH_REF_V101,
+            INTENT_STYLE_PROFILE_V102,
+            INTENT_TEMPLATES_V102,
+            INTENT_EXPLAIN_STYLE_V102,
+            INTENT_TRACE_STYLE_V102,
+        }
+        style_allow_override = str(objective_kind) in {"COMM_RESPOND", "COMM_SUMMARIZE", "COMM_CONFIRM"} and str(intent_id0) not in set(
+            [str(x) for x in style_lock_intents]
+        )
+        if style_allow_override and str(style_selected.get("text") or ""):
+            expected_text = str(style_selected.get("text") or "")
+            action_inputs = {"text": str(expected_text)}
+            hint_action_id = "concept_v90_emit_text_v0"
+        else:
+            # Ensure selected matches base output deterministically.
+            style_selection = {"method": "locked", "margin": 0.0, "soft_index": 0}
+            matched = None
+            for c in style_candidates_topk:
+                if isinstance(c, dict) and str(c.get("text") or "") == str(expected_text):
+                    matched = dict(c)
+                    break
+            style_selected = dict(matched) if isinstance(matched, dict) else {"candidate_id": "", "template_id": "tmpl_v102_direct_medium_v0", "text": str(expected_text), "text_sha256": "", "critics": {"ok": True}}
+
+        sel_tid = str(style_selected.get("template_id") or "")
+        if sel_tid:
+            recent_style_template_ids.append(str(sel_tid))
+            recent_style_template_ids = list(recent_style_template_ids[-10:])
+
+        # V100: discourse candidates (>=3) selected deterministically from the final expected text.
+        # Disable wrappers so the style decision remains the single source of truth for wording/format.
+        discourse_base_text = str(expected_text)
+        discourse_candidates_topk = generate_text_candidates_v100(
+            base_text=str(discourse_base_text),
+            response_kind=str(response_kind),
+            allow_wrappers=False,
+        )
+        discourse_selected = dict(discourse_candidates_topk[0]) if discourse_candidates_topk else {}
+
+        chosen_action_id = ""
+        chosen_objective_id = ""
+        chosen_eval_id = ""
+        chosen_ok = False
+        chosen_cost = 0.0
+        assistant_text = ""
+        plan_ranked_candidates: List[Dict[str, Any]] = []
+        plan_attempted_actions: List[Dict[str, Any]] = []
+        plan_objective_kind = ""
+        plan_objective_id = ""
+
+        if str(objective_kind) == "COMM_END":
+            assistant_text = "Encerrado."
+            chosen_action_id = "concept_v90_end_conversation_v0"
+            chosen_objective_id = _objective_act_id("COMM_END")
+            chosen_eval_id = _stable_hash_obj({"turn_id": str(ut.get("turn_id") or ""), "kind": "end"})
+            chosen_ok = True
+            chosen_cost = 0.0
+            plan_ranked_candidates = [{"act_id": chosen_action_id, "expected_success": 1.0, "expected_cost": 0.0}]
+            plan_attempted_actions = [{"act_id": chosen_action_id, "eval_id": chosen_eval_id, "ok": True}]
+            plan_objective_kind = "COMM_END"
+            plan_objective_id = chosen_objective_id
+        else:
+            goal_id = str(objective_kind)
+            goal_kind = str(objective_kind)
+            candidates0 = list_supporting_concepts_for_goal_v89(store=store, goal_id=str(goal_id))
+            ranked = _rank_action_candidates_v96(candidates=list(candidates0), events=list(support_events), goal_id=str(goal_id))
+
+            hint = str(hint_action_id or "")
+            ranked_ids = [str(act_id) for act_id, _claim, _es, _ec in ranked]
+            if hint and hint in set(ranked_ids):
+                ranked.sort(key=lambda t: (0 if str(t[0]) == hint else 1, -float(t[2]), float(t[3]), str(t[0])))
+
+            plan_ranked_candidates = [{"act_id": str(a), "expected_success": _round6(es), "expected_cost": _round6(ec)} for a, _c, es, ec in ranked]
+            plan_objective_kind = str(goal_kind)
+            plan_objective_id = _objective_act_id(str(goal_kind))
+
+            # Attempt in ranked order until objective passes.
+            def _try_actions() -> bool:
+                nonlocal chosen_action_id, chosen_objective_id, chosen_eval_id, chosen_ok, chosen_cost, assistant_text
+                for act_id, _claim, _es, _ec in ranked:
+                    ok_exec, out_text, _meta, cost_used = _execute_action(str(act_id), goal_kind=str(goal_kind), inputs=dict(action_inputs))
+                    eval_id = _stable_hash_obj(
+                        {
+                            "conversation_id": str(conversation_id),
+                            "turn_id": str(ut.get("turn_id") or ""),
+                            "step": int(step),
+                            "objective_kind": str(goal_kind),
+                            "objective_id": str(plan_objective_id),
+                            "act_id": str(act_id),
+                            "expected_text_sig": text_sig_v96(str(expected_text)),
+                            "output_text_sig": text_sig_v96(str(out_text)),
+                        }
+                    )
+                    objective_inputs = {
+                        "__output": str(out_text),
+                        "expected": str(expected_text),
+                        "__goal": str(goal_kind),
+                        "__step": int(step),
+                    }
+                    verdict_ok = False
+                    verdict: Dict[str, Any] = {}
+                    if not ok_exec:
+                        verdict_ok = False
+                        verdict = {
+                            "ok": False,
+                            "score": 0,
+                            "reason": f"action_exec_failed:{str(_meta.get('reason') or '')}",
+                            "details": {"meta": dict(_meta) if isinstance(_meta, dict) else {}},
+                        }
+                    else:
+                        verdict_obj = execute_objective_csv_v88(
+                            store=store,
+                            seed=int(seed),
+                            objective_act_id=str(plan_objective_id),
+                            inputs=dict(objective_inputs),
+                            step=int(step),
+                            goal_kind=str(goal_kind),
+                        )
+                        verdict = verdict_obj.to_dict()
+                        verdict_ok = bool(verdict_obj.ok)
+                    expected_sig = text_sig_v96(str(expected_text))
+                    output_sig = text_sig_v96(str(out_text))
+                    eval_row = {
+                        "kind": "objective_eval_v96",
+                        "time": deterministic_iso(step=int(step)),
+                        "step": int(step),
+                        "eval_id": str(eval_id),
+                        "conversation_id": str(conversation_id),
+                        "turn_id": str(ut.get("turn_id") or ""),
+                        "objective_kind": str(goal_kind),
+                        "objective_id": str(plan_objective_id),
+                        "action_concept_id": str(act_id),
+                        "expected_text": str(expected_text),
+                        "output_text": str(out_text),
+                        "expected_text_sig": str(expected_sig),
+                        "output_text_sig": str(output_sig),
+                        "verdict": dict(verdict),
+                    }
+                    nonlocal prev_evals_hash
+                    prev_evals_hash = append_chained_jsonl_v96(evals_path, dict(eval_row), prev_hash=prev_evals_hash)
+
+                    trial_id = _stable_hash_obj(
+                        {
+                            "conversation_id": str(conversation_id),
+                            "turn_id": str(ut.get("turn_id") or ""),
+                            "step": int(step),
+                            "objective_kind": str(goal_kind),
+                            "objective_id": str(plan_objective_id),
+                            "act_id": str(act_id),
+                            "eval_id": str(eval_id),
+                        }
+                    )
+                    trial_row = {
+                        "kind": "dialogue_trial_v96",
+                        "time": deterministic_iso(step=int(step)),
+                        "step": int(step),
+                        "trial_id": str(trial_id),
+                        "conversation_id": str(conversation_id),
+                        "turn_id": str(ut.get("turn_id") or ""),
+                        "user_turn_id": str(ut.get("turn_id") or ""),
+                        "objective_kind": str(goal_kind),
+                        "objective_id": str(plan_objective_id),
+                        "action_concept_id": str(act_id),
+                        "eval_id": str(eval_id),
+                        "expected_text": str(expected_text),
+                        "expected_text_sig": str(expected_sig),
+                        "assistant_text": str(out_text),
+                        "assistant_text_sig": str(output_sig),
+                        "ok": bool(verdict_ok),
+                        "cost_used": float(cost_used),
+                    }
+                    nonlocal prev_trials_hash
+                    prev_trials_hash = append_chained_jsonl_v96(trials_path, dict(trial_row), prev_hash=prev_trials_hash)
+
+                    support_ev = make_goal_support_evidence_event_v89(
+                        step=int(step),
+                        goal_id=str(goal_kind),
+                        concept_key=str(act_id),
+                        attempt_id=str(trial_id),
+                        ok=bool(verdict_ok),
+                        cost_used=float(cost_used),
+                        note=str(verdict.get("reason") or ""),
+                    )
+                    support_events.append(dict(support_ev))
+
+                    plan_attempted_actions.append({"act_id": str(act_id), "eval_id": str(eval_id), "ok": bool(verdict_ok)})
+
+                    if verdict_ok and ok_exec:
+                        assistant_text = str(out_text)
+                        chosen_action_id = str(act_id)
+                        chosen_objective_id = str(plan_objective_id)
+                        chosen_eval_id = str(eval_id)
+                        chosen_ok = True
+                        chosen_cost = float(cost_used)
+                        return True
+                return False
+
+            ok_any = _try_actions()
+            if not ok_any:
+                objective_kind = "COMM_ADMIT_UNKNOWN"
+                expected_text, action_inputs, hint_action_id = _build_expected_and_action_inputs_v96(
+                    objective_kind=str(objective_kind),
+                    parse=dict(parse),
+                    vars_map=dict(vars_map),
+                    last_answer=last_answer,
+                    beliefs_by_key=dict(_active_beliefs_by_key()),
+                    ctx=dict(ctx2),
+                    user_text=str(user_text),
+                )
+                # Recompute discourse candidates for the new objective/base text (fail-closed).
+                discourse_base_text = str(expected_text)
+                discourse_candidates_topk = generate_text_candidates_v100(
+                    base_text=str(discourse_base_text),
+                    response_kind="locked",
+                    allow_wrappers=False,
+                )
+                discourse_selected = dict(discourse_candidates_topk[0]) if discourse_candidates_topk else {}
+                # minimal fallback attempt: admit_unknown
+                ranked2 = [("concept_v90_admit_unknown_v0", SupportClaimV89(goal_id="COMM_ADMIT_UNKNOWN", prior_success=1.0, prior_strength=1, prior_cost=1.0, note=""))]
+                plan_ranked_candidates = [{"act_id": "concept_v90_admit_unknown_v0", "expected_success": 1.0, "expected_cost": 1.0}]
+                plan_attempted_actions = []
+                ok_exec, out_text, _meta, cost_used = _execute_action("concept_v90_admit_unknown_v0", goal_kind="COMM_ADMIT_UNKNOWN", inputs=dict(action_inputs))
+                eval_id = _stable_hash_obj({"conversation_id": str(conversation_id), "turn_id": str(ut.get("turn_id") or ""), "step": int(step), "kind": "fallback"})
+                plan_attempted_actions.append({"act_id": "concept_v90_admit_unknown_v0", "eval_id": str(eval_id), "ok": bool(ok_exec)})
+                assistant_text = str(out_text) if ok_exec else "Não sei."
+                chosen_action_id = "concept_v90_admit_unknown_v0"
+                chosen_objective_id = _objective_act_id("COMM_ADMIT_UNKNOWN")
+                chosen_eval_id = str(eval_id)
+                chosen_ok = bool(ok_exec)
+                chosen_cost = float(cost_used)
+                plan_objective_kind = "COMM_ADMIT_UNKNOWN"
+                plan_objective_id = chosen_objective_id
+
+        # Create assistant turn.
+        at = TurnV96(
+            conversation_id=str(conversation_id),
+            turn_index=int(turn_index),
+            role="assistant",
+            text=str(assistant_text),
+            created_step=int(step),
+            offset_us=0,
+            objective_id=str(chosen_objective_id),
+            objective_kind=str(plan_objective_kind or objective_kind),
+            action_concept_id=str(chosen_action_id),
+            eval_id=str(chosen_eval_id),
+        ).to_dict()
+        turn_index += 1
+        step += 1
+        turns.append(dict(at))
+        prev_turns_hash = append_chained_jsonl_v96(
+            turns_path,
+            {"time": deterministic_iso(step=int(at["created_step"])), "step": int(at["created_step"]), "event": "TURN", "payload": dict(at)},
+            prev_hash=prev_turns_hash,
+        )
+        transcript.append({"role": "assistant", "text": str(at.get("text") or ""), "turn_id": str(at.get("turn_id") or "")})
+        prev_transcript_hash = append_chained_jsonl_v96(
+            transcript_path,
+            {"time": deterministic_iso(step=int(at["created_step"])), "step": int(at["created_step"]), "event": "UTTERANCE", "payload": dict(transcript[-1])},
+            prev_hash=prev_transcript_hash,
+        )
+
+        # V102: style ledger (templates + critics + selection; inner sig-chain + outer jsonl chain).
+        style_profile_before_dict = style_profile_before.to_dict() if isinstance(style_profile_before, StyleProfileV102) else default_style_profile_v102().to_dict()
+        style_profile_after_dict = style_profile.to_dict() if isinstance(style_profile, StyleProfileV102) else default_style_profile_v102().to_dict()
+        sel_ok = bool(((style_selected.get("critics") or {}).get("ok")) if isinstance(style_selected.get("critics"), dict) else False)
+        style_cause_ids = {
+            "cause_goal_ids": sorted(set(list(goal_read_ids) + list(goal_write_ids))),
+            "cause_belief_ids": sorted(set(list(belief_read_ids))),
+            "cause_evidence_ids": sorted(set(list(evidence_read_ids) + list(evidence_write_ids))),
+        }
+        se = StyleEventV102(
+            conversation_id=str(conversation_id),
+            turn_id=str(at.get("turn_id") or ""),
+            turn_index=int(at.get("turn_index") or 0),
+            event_kind="STYLE_CHOSEN",
+            style_profile_before=dict(style_profile_before_dict),
+            style_profile_after=dict(style_profile_after_dict),
+            candidates_topk=[dict(x) for x in style_candidates_topk if isinstance(x, dict)],
+            selected_candidate_id=str(style_selected.get("candidate_id") or ""),
+            selected_template_id=str(style_selected.get("template_id") or ""),
+            selected_ok=bool(sel_ok),
+            selection=dict(style_selection) if isinstance(style_selection, dict) else {},
+            cause_ids=dict(style_cause_ids),
+            created_step=int(at.get("created_step") or 0),
+            prev_event_sig=str(prev_style_event_sig),
+        ).to_dict()
+        prev_style_hash = append_chained_jsonl_v96(
+            style_path,
+            {"time": deterministic_iso(step=int(at["created_step"])), "step": int(at["created_step"]), "event": "STYLE_EVENT", "payload": dict(se)},
+            prev_hash=prev_style_hash,
+        )
+        style_events.append(dict(se))
+        prev_style_event_sig = str(se.get("event_sig") or "")
+
+        # V100: discourse ledger (variants + fluency metrics) + fragment lifecycle events.
+        discourse_state_before = _deepcopy_json_obj(discourse_state)
+
+        # Update discourse_state deterministically based on the current turn's intent/effects.
+        topic_map = {
+            INTENT_SET_V92: "dsl",
+            INTENT_GET_V92: "dsl",
+            INTENT_ADD_V92: "dsl",
+            INTENT_SUMMARY_V92: "dsl",
+            INTENT_TEACH_V93: "learning",
+            INTENT_EXPLAIN_V94: "explain",
+            INTENT_SYSTEM_V98: "system",
+            INTENT_VERSIONS_V98: "system",
+            INTENT_DOSSIER_V98: "system",
+            INTENT_EVIDENCE_ADD_V98: "evidence",
+            INTENT_EVIDENCE_LIST_V98: "evidence",
+            INTENT_WHY_V98: "belief",
+            INTENT_GOAL_ADD_V99: "goals",
+            INTENT_GOAL_LIST_V99: "goals",
+            INTENT_GOAL_DONE_V99: "goals",
+            INTENT_GOAL_NEXT_V99: "goals",
+            INTENT_GOAL_AUTO_V99: "goals",
+            INTENT_DISCOURSE_V100: "discourse",
+            INTENT_WHY_REF_V100: "discourse",
+        }
+        topic = str(topic_map.get(str(parse.get("intent_id") or ""), "other"))
+        topics = discourse_state.get("active_topics")
+        topics_list = topics if isinstance(topics, list) else []
+        new_topics = [topic] + [str(x) for x in topics_list if isinstance(x, str) and x and str(x) != topic]
+        discourse_state["active_topics"] = list(new_topics[:5])
+
+        # Open questions (only when we asked to clarify).
+        if str(parse.get("intent_id") or "") == INTENT_WHY_REF_V100 and str(objective_kind) in {"COMM_ASK_CLARIFY", "COMM_CONFIRM"}:
+            keys = ctx2.get("open_question_keys") if isinstance(ctx2.get("open_question_keys"), list) else []
+            keys2 = [str(x) for x in keys if isinstance(x, str) and x]
+            oq = {
+                "question_id": _stable_hash_obj({"kind": "why_ref", "turn_id": str(ut.get("turn_id") or ""), "keys": list(keys2)}),
+                "kind": "why_ref",
+                "keys": list(keys2),
+                "created_turn_id": str(ut.get("turn_id") or ""),
+            }
+            oqs = discourse_state.get("open_questions")
+            oqs_list = oqs if isinstance(oqs, list) else []
+            oqs_list.append(dict(oq))
+            # keep last 5, deterministically ordered by question_id
+            oqs_list2 = sorted([dict(x) for x in oqs_list if isinstance(x, dict)], key=lambda d: str(d.get("question_id") or ""))
+            discourse_state["open_questions"] = list(oqs_list2[-5:])
+
+        # Commitments: if evidence caused a belief revision/add, record minimal commitment link.
+        if evidence_write_ids and belief_write_event_ids:
+            commitments = discourse_state.get("commitments")
+            c_list = commitments if isinstance(commitments, list) else []
+            c_list.append(
+                {
+                    "kind": "belief_revision",
+                    "cause_evidence_ids": sorted(set([str(x) for x in evidence_write_ids if isinstance(x, str) and x])),
+                    "belief_write_event_ids": sorted(set([str(x) for x in belief_write_event_ids if isinstance(x, str) and x])),
+                    "turn_id": str(at.get("turn_id") or ""),
+                }
+            )
+            discourse_state["commitments"] = list(c_list[-10:])
+
+        # Ref map: track available belief keys for "isso/that" references.
+        bkeys = sorted([str(k) for k in belief_active_by_key.keys() if isinstance(k, str) and k])
+        discourse_state["ref_map"] = {"isso": list(bkeys), "that": list(bkeys)}
+
+        discourse_state_after = _deepcopy_json_obj(discourse_state)
+
+        # Discourse event (inner sig-chain + outer jsonl chain).
+        sel_candidate_id = str(discourse_selected.get("candidate_id") or "")
+        cause_ids = {
+            "cause_goal_ids": sorted(set(list(goal_read_ids) + list(goal_write_ids))),
+            "cause_belief_ids": sorted(set(list(belief_read_ids))),
+            "cause_evidence_ids": sorted(set(list(evidence_read_ids) + list(evidence_write_ids))),
+        }
+        de = DiscourseEventV100(
+            conversation_id=str(conversation_id),
+            turn_id=str(at.get("turn_id") or ""),
+            turn_index=int(at.get("turn_index") or 0),
+            discourse_state_before=dict(discourse_state_before),
+            discourse_state_after=dict(discourse_state_after),
+            candidates_topk=[dict(x) for x in discourse_candidates_topk if isinstance(x, dict)][:8],
+            selected_candidate_id=str(sel_candidate_id),
+            cause_ids=dict(cause_ids),
+            created_step=int(at.get("created_step") or 0),
+            prev_event_sig=str(prev_discourse_event_sig),
+        ).to_dict()
+        prev_discourse_hash = append_chained_jsonl_v96(
+            discourse_path,
+            {"time": deterministic_iso(step=int(at["created_step"])), "step": int(at["created_step"]), "event": "DISCOURSE_EVENT", "payload": dict(de)},
+            prev_hash=prev_discourse_hash,
+        )
+        discourse_events.append(dict(de))
+        prev_discourse_event_sig = str(de.get("event_sig") or "")
+
+        # Fragment USE events for selected candidate, plus deterministic promotion events.
+        sel_frags = discourse_selected.get("fragment_ids") if isinstance(discourse_selected.get("fragment_ids"), list) else []
+        sel_frag_ids = [str(x) for x in sel_frags if isinstance(x, str) and x]
+        sel_score = float(discourse_selected.get("fluency_score") or 0.0)
+        for fid in sorted(set(sel_frag_ids), key=str):
+            fe = FragmentEventV100(
+                conversation_id=str(conversation_id),
+                event_kind="USE",
+                fragment_id=str(fid),
+                turn_id=str(at.get("turn_id") or ""),
+                candidate_id=str(sel_candidate_id),
+                fluency_score=float(sel_score),
+                created_step=int(at.get("created_step") or 0),
+                prev_event_sig=str(prev_fragment_event_sig),
+            ).to_dict()
+            prev_fragment_hash = append_chained_jsonl_v96(
+                fragment_events_path,
+                {"time": deterministic_iso(step=int(at["created_step"])), "step": int(at["created_step"]), "event": "FRAGMENT_EVENT", "payload": dict(fe)},
+                prev_hash=prev_fragment_hash,
+            )
+            fragment_events.append(dict(fe))
+            prev_fragment_event_sig = str(fe.get("event_sig") or "")
+
+        # Promotion check (after USE).
+        if sel_frag_ids:
+            st_by_id = fold_fragment_library_v100(base_fragments=list(base_fragments), fragment_events=list(fragment_events))
+            for fid in sorted(set(sel_frag_ids), key=str):
+                st = st_by_id.get(str(fid))
+                if not isinstance(st, dict):
+                    continue
+                if fragment_should_promote_v100(dict(st)):
+                    fe2 = FragmentEventV100(
+                        conversation_id=str(conversation_id),
+                        event_kind="PROMOTE",
+                        fragment_id=str(fid),
+                        turn_id=str(at.get("turn_id") or ""),
+                        candidate_id=str(sel_candidate_id),
+                        fluency_score=float(sel_score),
+                        created_step=int(at.get("created_step") or 0),
+                        prev_event_sig=str(prev_fragment_event_sig),
+                    ).to_dict()
+                    prev_fragment_hash = append_chained_jsonl_v96(
+                        fragment_events_path,
+                        {"time": deterministic_iso(step=int(at["created_step"])), "step": int(at["created_step"]), "event": "FRAGMENT_EVENT", "payload": dict(fe2)},
+                        prev_hash=prev_fragment_hash,
+                    )
+                    fragment_events.append(dict(fe2))
+                    prev_fragment_event_sig = str(fe2.get("event_sig") or "")
+
+        # Plan record (1 per user turn).
+        notes = "max expected_success, tie-break min expected_cost, tie-break act_id"
+        # Provenance: include learned rule ids used by this parse (if any).
+        prov_learned: List[str] = []
+        mrid = str(parse.get("matched_rule_id") or "")
+        if mrid and mrid in set(learned_rules_active.keys()):
+            prov_learned = [mrid]
+        # TEACH writes a learned rule id (audit) on success.
+        prov_learned_written: List[str] = []
+        if str(parse.get("intent_id") or "") == INTENT_TEACH_V93 and bool(parse.get("teach_ok", False)):
+            lrid = str(parse.get("learned_rule_id") or "")
+            if lrid:
+                prov_learned_written = [lrid]
+
+        ranked_topk = []
+        for rc in list(plan_ranked_candidates)[:8]:
+            if not isinstance(rc, dict):
+                continue
+            act_id = str(rc.get("act_id") or "")
+            es = _round6(rc.get("expected_success"))
+            ec = _round6(rc.get("expected_cost"))
+            score = float(es) / (float(ec) + 1e-9)
+            ranked_topk.append(
+                {
+                    "act_id": str(act_id),
+                    "expected_success": float(es),
+                    "expected_cost": float(ec),
+                    "score": _round6(score),
+                    "reason": "score=expected_success/(expected_cost+eps)",
+                }
+            )
+        ranked_topk.sort(key=lambda d: (-float(d.get("score", 0.0)), str(d.get("act_id") or "")))
+
+        sel_frag_ids2 = discourse_selected.get("fragment_ids") if isinstance(discourse_selected.get("fragment_ids"), list) else []
+        sel_frag_ids_canon = sorted(set([str(x) for x in sel_frag_ids2 if isinstance(x, str) and x]))
+        discourse_plan = {
+            "discourse_event_id": str(de.get("event_id") or "") if isinstance(locals().get("de"), dict) else "",
+            "selected_candidate_id": str(discourse_selected.get("candidate_id") or ""),
+            "selected_text_sha256": str(discourse_selected.get("text_sha256") or ""),
+            "selected_fluency_score": _round6(discourse_selected.get("fluency_score")),
+            "selected_fragment_ids": list(sel_frag_ids_canon),
+            "candidates_topk": [
+                {
+                    "candidate_id": str(c.get("candidate_id") or ""),
+                    "variant_id": str(c.get("variant_id") or ""),
+                    "text_sha256": str(c.get("text_sha256") or ""),
+                    "fluency_score": _round6(c.get("fluency_score")),
+                    "fluency_metrics": dict(c.get("fluency_metrics") or {}) if isinstance(c.get("fluency_metrics"), dict) else {},
+                    "fragment_ids": [str(x) for x in (c.get("fragment_ids") if isinstance(c.get("fragment_ids"), list) else []) if isinstance(x, str) and x],
+                }
+                for c in list(discourse_candidates_topk)[:8]
+                if isinstance(c, dict)
+            ],
+        }
+        style_plan = {
+            "selected_candidate_id": str(style_selected.get("candidate_id") or ""),
+            "selected_template_id": str(style_selected.get("template_id") or ""),
+            "selected_text_sha256": str(style_selected.get("text_sha256") or ""),
+            "selected_fluency_score": _round6(style_selected.get("fluency_score")),
+            "selection": dict(style_selection) if isinstance(style_selection, dict) else {},
+            "candidates_topk": [
+                {
+                    "candidate_id": str(c.get("candidate_id") or ""),
+                    "template_id": str(c.get("template_id") or ""),
+                    "text_sha256": str(c.get("text_sha256") or ""),
+                    "fluency_score": _round6(c.get("fluency_score")),
+                    "ok": bool(((c.get("critics") or {}).get("ok")) if isinstance(c.get("critics"), dict) else False),
+                }
+                for c in list(style_candidates_topk)[:8]
+                if isinstance(c, dict)
+            ],
+        }
+
+        plan_sem = {
+            "schema_version": 100,
+            "kind": "action_plan_v100",
+            "conversation_id": str(conversation_id),
+            "user_turn_id": str(ut.get("turn_id") or ""),
+            "user_turn_index": int(ut.get("turn_index") or 0),
+            "intent_id": str(parse.get("intent_id") or ""),
+            "parse_sig": str(parse.get("parse_sig") or ""),
+            "objective_kind": str(plan_objective_kind or objective_kind),
+            "objective_id": str(plan_objective_id or chosen_objective_id),
+            "ranked_candidates": list(plan_ranked_candidates),
+            "attempted_actions": list(plan_attempted_actions),
+            "chosen_action_id": str(chosen_action_id),
+            "chosen_eval_id": str(chosen_eval_id),
+            "chosen_ok": bool(chosen_ok),
+            "notes": str(notes),
+            "created_step": int(step),
+            "discourse": dict(discourse_plan),
+            "style": dict(style_plan),
+            "memory_read_ids": sorted(set([str(x) for x in list(memory_read_ids) if isinstance(x, str) and x])),
+            "memory_write_event_ids": sorted(set([str(x) for x in list(memory_write_event_ids) if isinstance(x, str) and x])),
+            "belief_read_keys": sorted(set([str(x) for x in list(belief_read_keys) if isinstance(x, str) and x])),
+            "belief_read_ids": sorted(set([str(x) for x in list(belief_read_ids) if isinstance(x, str) and x])),
+            "belief_write_event_ids": sorted(set([str(x) for x in list(belief_write_event_ids) if isinstance(x, str) and x])),
+            "evidence_read_ids": sorted(set([str(x) for x in list(evidence_read_ids) if isinstance(x, str) and x])),
+            "evidence_write_ids": sorted(set([str(x) for x in list(evidence_write_ids) if isinstance(x, str) and x])),
+            "goal_read_ids": sorted(set([str(x) for x in list(goal_read_ids) if isinstance(x, str) and x])),
+            "goal_write_ids": sorted(set([str(x) for x in list(goal_write_ids) if isinstance(x, str) and x])),
+            "goal_tick_actions": [dict(x) for x in list(goal_tick_actions) if isinstance(x, dict)],
+            "candidates_topk": list(ranked_topk),
+            "selected_intent_id": str(chosen_action_id),
+            "provenance": {
+                "learned_rule_ids": list(sorted(set(prov_learned))),
+                "learned_rule_ids_written": list(sorted(set(prov_learned_written))),
+                "fragment_ids_used": list(sel_frag_ids_canon),
+                "style_template_id": str(style_selected.get("template_id") or ""),
+                "cause_evidence_ids": sorted(set([str(x) for x in list(cause_evidence_ids) if isinstance(x, str) and x])),
+                "belief_read_keys": sorted(set([str(x) for x in list(belief_read_keys) if isinstance(x, str) and x])),
+                "belief_read_ids": sorted(set([str(x) for x in list(belief_read_ids) if isinstance(x, str) and x])),
+                "belief_write_event_ids": sorted(set([str(x) for x in list(belief_write_event_ids) if isinstance(x, str) and x])),
+                "memory_read_ids": sorted(set([str(x) for x in list(memory_read_ids) if isinstance(x, str) and x])),
+                "memory_write_event_ids": sorted(set([str(x) for x in list(memory_write_event_ids) if isinstance(x, str) and x])),
+                "evidence_read_ids": sorted(set([str(x) for x in list(evidence_read_ids) if isinstance(x, str) and x])),
+                "evidence_write_ids": sorted(set([str(x) for x in list(evidence_write_ids) if isinstance(x, str) and x])),
+                "goal_ids": sorted(
+                    set(
+                        [str(x) for x in list(goal_read_ids) if isinstance(x, str) and x]
+                        + [str(x) for x in list(goal_write_ids) if isinstance(x, str) and x]
+                    )
+                ),
+            },
+        }
+        plan_sig = _stable_hash_obj(plan_sem)
+        plan_obj = dict(plan_sem, plan_sig=str(plan_sig), plan_id=str(action_plan_id_v96(plan_sig)))
+        prev_plans_hash = append_chained_jsonl_v96(plans_path, dict(plan_obj), prev_hash=prev_plans_hash)
+        action_plans.append(dict(plan_obj))
+
+        trials.append(
+            {
+                "objective_kind": str(plan_objective_kind or objective_kind),
+                "user_turn_id": str(ut.get("turn_id") or ""),
+                "assistant_turn_id": str(at.get("turn_id") or ""),
+                "ok": bool(chosen_ok),
+                "cost_used": float(chosen_cost),
+            }
+        )
+
+        teach_rejected = str(parse.get("intent_id") or "") == "INTENT_TEACH" and not bool(parse.get("teach_ok", False))
+        if str(plan_objective_kind or objective_kind) not in {"COMM_ASK_CLARIFY", "COMM_CONFIRM"} and not bool(teach_rejected):
+            end_idx = int(turn_index) - 1
+            start_idx = max(0, end_idx - (6 - 1))
+            tail_turn_ids = [str(turns[i]["turn_id"]) for i in range(start_idx, end_idx + 1)]
+            lra = sorted(learned_rules_active.keys())
+            mem_active = sorted([mid for mid, okv in memory_active_ids.items() if bool(okv)], key=str)
+            beliefs_active_keys = sorted([str(k) for k in belief_active_by_key.keys() if str(k)], key=str)
+            goals_active_by_id, _gdet = fold_goal_ledger_v99(list(goal_events))
+            goals_active_ids = sorted([str(k) for k in goals_active_by_id.keys() if str(k)], key=str)
+            frag_states = fold_fragment_library_v100(base_fragments=list(base_fragments), fragment_events=list(fragment_events))
+            frag_promoted = sorted([fid for fid, st in frag_states.items() if isinstance(st, dict) and str(st.get("promotion_state") or "") == "promoted"], key=str)
+            st = ConversationStateV96(
+                conversation_id=str(conversation_id),
+                state_index=int(state_index),
+                prev_state_id=str(states[-1]["state_id"] if states else ""),
+                active_goals=[],
+                bindings={
+                    "vars": {str(k): vars_map.get(k) for k in sorted(vars_map.keys(), key=str)},
+                    "last_answer": last_answer,
+                    "learned_rules_active": list(lra),
+                    "learned_rule_count": int(len(lra)),
+                    "memory_active": list(mem_active),
+                    "memory_active_count": int(len(mem_active)),
+                    "belief_active_keys": list(beliefs_active_keys),
+                    "belief_active_count": int(len(beliefs_active_keys)),
+                    "goal_active_ids": list(goals_active_ids),
+                    "goal_active_count": int(len(goals_active_ids)),
+                    "style_profile": style_profile.to_dict() if isinstance(style_profile, StyleProfileV102) else default_style_profile_v102().to_dict(),
+                    "discourse_state": dict(discourse_state),
+                    "fragment_promoted_ids": list(frag_promoted),
+                    "fragment_promoted_count": int(len(frag_promoted)),
+                },
+                tail_turn_ids=list(tail_turn_ids),
+                last_user_turn_id=str(ut.get("turn_id") or ""),
+                last_assistant_turn_id=str(at.get("turn_id") or ""),
+                created_step=int(step),
+                last_step=int(step),
+            ).to_dict()
+            state_index += 1
+            step += 1
+            states.append(dict(st))
+            prev_states_hash = append_chained_jsonl_v96(
+                states_path,
+                {"time": deterministic_iso(step=int(st["created_step"])), "step": int(st["created_step"]), "event": "STATE", "payload": dict(st)},
+                prev_hash=prev_states_hash,
+            )
+
+        if bool(compound_stop_after) or str(parse.get("intent_id") or "") == INTENT_END_V92:
+            break
+
+    # Goal ledger snapshot (derived; write-once WORM).
+    if os.path.exists(goal_snapshot_path):
+        _fail(f"goal_snapshot_exists:{goal_snapshot_path}")
+    goal_snapshot = goal_ledger_snapshot_v99(list(goal_events))
+    tmpgs = goal_snapshot_path + ".tmp"
+    with open(tmpgs, "w", encoding="utf-8") as f:
+        f.write(json.dumps(goal_snapshot, ensure_ascii=False, indent=2, sort_keys=True))
+        f.write("\n")
+    os.replace(tmpgs, goal_snapshot_path)
+
+    # Fragment library snapshot (derived; write-once WORM).
+    if os.path.exists(fragment_snapshot_path):
+        _fail(f"fragment_snapshot_exists:{fragment_snapshot_path}")
+    frag_snapshot = fragment_library_snapshot_v100(base_fragments=list(base_fragments), fragment_events=list(fragment_events))
+    tmpfs = fragment_snapshot_path + ".tmp"
+    with open(tmpfs, "w", encoding="utf-8") as f:
+        f.write(json.dumps(frag_snapshot, ensure_ascii=False, indent=2, sort_keys=True))
+        f.write("\n")
+    os.replace(tmpfs, fragment_snapshot_path)
+
+    # Binding snapshot (derived; write-once WORM).
+    if os.path.exists(binding_snapshot_path):
+        _fail(f"binding_snapshot_exists:{binding_snapshot_path}")
+    binding_snapshot = binding_snapshot_v101(list(binding_events))
+    tmpbs = binding_snapshot_path + ".tmp"
+    with open(tmpbs, "w", encoding="utf-8") as f:
+        f.write(json.dumps(binding_snapshot, ensure_ascii=False, indent=2, sort_keys=True))
+        f.write("\n")
+    os.replace(tmpbs, binding_snapshot_path)
+
+    # Template library snapshot (derived from style events; write-once WORM).
+    if os.path.exists(template_snapshot_path):
+        _fail(f"template_snapshot_exists:{template_snapshot_path}")
+    template_snapshot = template_library_snapshot_v102(templates=list(templates_v102), style_events=list(style_events))
+    tmpts = template_snapshot_path + ".tmp"
+    with open(tmpts, "w", encoding="utf-8") as f:
+        f.write(json.dumps(template_snapshot, ensure_ascii=False, indent=2, sort_keys=True))
+        f.write("\n")
+    os.replace(tmpts, template_snapshot_path)
+
+    binding_chain_hash = binding_chain_hash_v101(list(binding_events))
+
+    chains = {
+        "turns_chain_ok": bool(verify_chained_jsonl_v96(turns_path)),
+        "parses_chain_ok": bool(verify_chained_jsonl_v96(parses_path)),
+        "learned_chain_ok": bool(verify_chained_jsonl_v96(learned_path)) if os.path.exists(learned_path) else True,
+        "plans_chain_ok": bool(verify_chained_jsonl_v96(plans_path)),
+        "memory_chain_ok": bool(verify_chained_jsonl_v96(memory_path)),
+        "belief_chain_ok": bool(verify_chained_jsonl_v96(belief_path)),
+        "evidence_chain_ok": bool(verify_chained_jsonl_v96(evidence_path)),
+        "goal_chain_ok": bool(verify_chained_jsonl_v96(goal_path)),
+        "discourse_chain_ok": bool(verify_chained_jsonl_v96(discourse_path)),
+        "fragment_chain_ok": bool(verify_chained_jsonl_v96(fragment_events_path)),
+        "binding_chain_ok": bool(verify_chained_jsonl_v96(binding_events_path)),
+        "style_chain_ok": bool(verify_chained_jsonl_v96(style_path)),
+        "states_chain_ok": bool(verify_chained_jsonl_v96(states_path)) if os.path.exists(states_path) else True,
+        "trials_chain_ok": bool(verify_chained_jsonl_v96(trials_path)),
+        "evals_chain_ok": bool(verify_chained_jsonl_v96(evals_path)),
+        "transcript_chain_ok": bool(verify_chained_jsonl_v96(transcript_path)),
+        "template_snapshot_exists": bool(os.path.exists(template_snapshot_path)),
+    }
+    ok_chain, chain_reason, chain_details = verify_conversation_chain_v102(
+        turns=list(turns),
+        states=list(states),
+        parse_events=list(parse_events),
+        trials=list(trials),
+        learned_rule_events=list(learned_rule_events),
+        action_plans=list(action_plans),
+        memory_events=list(memory_events),
+        belief_events=list(belief_events),
+        evidence_events=list(evidence_events),
+        goal_events=list(goal_events),
+        goal_snapshot=dict(goal_snapshot),
+        discourse_events=list(discourse_events),
+        fragment_events=list(fragment_events),
+        binding_events=list(binding_events),
+        binding_snapshot=dict(binding_snapshot),
+        style_events=list(style_events),
+        template_snapshot=dict(template_snapshot),
+        tail_k=6,
+        repo_root=str(repo_root),
+    )
+
+    transcript_hash = compute_transcript_hash_v96(turns)
+    state_chain_hash = compute_state_chain_hash_v96(states)
+    parse_chain_hash = compute_parse_chain_hash_v96(parse_events)
+    learned_chain_hash = compute_learned_chain_hash_v96(learned_rule_events)
+    plan_chain_hash = compute_plan_chain_hash_v96(action_plans)
+    memory_chain_hash = compute_memory_chain_hash_v96(memory_events)
+    belief_chain_hash = compute_belief_chain_hash_v96(belief_events)
+    evidence_chain_hash = compute_evidence_chain_hash_v98(evidence_events)
+    goal_chain_hash = compute_goal_chain_hash_v99(list(goal_events))
+    discourse_chain_hash = compute_discourse_chain_hash_v100(list(discourse_events))
+    fragment_chain_hash = compute_fragment_chain_hash_v100(list(fragment_events))
+    style_chain_hash = compute_style_chain_hash_v102(list(style_events))
+    system_spec_sha256 = sha256_file(system_spec_path)
+    binding_chain_hash = str(chain_details.get("binding_chain_hash") or binding_chain_hash)
+
+    verify_obj = {
+        "ok": bool(all(chains.values())) and bool(ok_chain),
+        "chains": dict(chains),
+        "chain_invariants": {"ok": bool(ok_chain), "reason": str(chain_reason), "details": dict(chain_details)},
+        "store_hash": str(store_hash),
+        "system_spec_sha256": str(system_spec_sha256),
+        "transcript_hash": str(transcript_hash),
+        "state_chain_hash": str(state_chain_hash),
+        "parse_chain_hash": str(parse_chain_hash),
+        "learned_chain_hash": str(learned_chain_hash),
+        "plan_chain_hash": str(plan_chain_hash),
+        "memory_chain_hash": str(memory_chain_hash),
+        "belief_chain_hash": str(belief_chain_hash),
+        "evidence_chain_hash": str(evidence_chain_hash),
+        "goal_chain_hash": str(goal_chain_hash),
+        "discourse_chain_hash": str(discourse_chain_hash),
+        "fragment_chain_hash": str(fragment_chain_hash),
+        "binding_chain_hash": str(binding_chain_hash),
+        "style_chain_hash": str(style_chain_hash),
+    }
+    tmpv = verify_path + ".tmp"
+    with open(tmpv, "w", encoding="utf-8") as f:
+        f.write(json.dumps(verify_obj, ensure_ascii=False, indent=2, sort_keys=True))
+        f.write("\n")
+    os.replace(tmpv, verify_path)
+
+    manifest_core = {
+        "schema_version": 5,
+        "conversation_id": str(conversation_id),
+        "seed": int(seed),
+        "store_hash": str(store_hash),
+        "grammar_hash": str(grammar_snapshot.get("grammar_hash") or ""),
+        "system_spec_sha256": str(system_spec_sha256),
+        "transcript_hash": str(transcript_hash),
+        "state_chain_hash": str(state_chain_hash),
+        "parse_chain_hash": str(parse_chain_hash),
+        "learned_chain_hash": str(learned_chain_hash),
+        "plan_chain_hash": str(plan_chain_hash),
+        "memory_chain_hash": str(memory_chain_hash),
+        "belief_chain_hash": str(belief_chain_hash),
+        "evidence_chain_hash": str(evidence_chain_hash),
+        "goal_chain_hash": str(goal_chain_hash),
+        "discourse_chain_hash": str(discourse_chain_hash),
+        "fragment_chain_hash": str(fragment_chain_hash),
+        "binding_chain_hash": str(binding_chain_hash),
+        "style_chain_hash": str(style_chain_hash),
+        "verify_ok": bool(verify_obj.get("ok", False)),
+        "sha256": {
+            "store_jsonl": str(sha256_file(store_path)),
+            "intent_grammar_snapshot_json": str(sha256_file(grammar_snapshot_path)),
+            "system_spec_snapshot_json": str(system_spec_sha256),
+            "conversation_turns_jsonl": str(sha256_file(turns_path)),
+            "intent_parses_jsonl": str(sha256_file(parses_path)),
+            "learned_intent_rules_jsonl": str(sha256_file(learned_path)) if os.path.exists(learned_path) else "",
+            "action_plans_jsonl": str(sha256_file(plans_path)),
+            "memory_events_jsonl": str(sha256_file(memory_path)),
+            "belief_events_jsonl": str(sha256_file(belief_path)),
+            "evidence_events_jsonl": str(sha256_file(evidence_path)),
+            "goal_events_jsonl": str(sha256_file(goal_path)),
+            "goal_ledger_snapshot_json": str(sha256_file(goal_snapshot_path)),
+            "discourse_events_jsonl": str(sha256_file(discourse_path)),
+            "fragment_events_jsonl": str(sha256_file(fragment_events_path)),
+            "fragment_library_snapshot_json": str(sha256_file(fragment_snapshot_path)),
+            "binding_events_jsonl": str(sha256_file(binding_events_path)),
+            "binding_snapshot_json": str(sha256_file(binding_snapshot_path)),
+            "style_events_jsonl": str(sha256_file(style_path)),
+            "template_library_snapshot_v102_json": str(sha256_file(template_snapshot_path)),
+            "conversation_states_jsonl": str(sha256_file(states_path)) if os.path.exists(states_path) else "",
+            "dialogue_trials_jsonl": str(sha256_file(trials_path)),
+            "objective_evals_jsonl": str(sha256_file(evals_path)),
+            "transcript_jsonl": str(sha256_file(transcript_path)),
+            "verify_chain_v102_json": str(sha256_file(verify_path)),
+        },
+    }
+    tmpm = manifest_path + ".tmp"
+    with open(tmpm, "w", encoding="utf-8") as f:
+        f.write(json.dumps(manifest_core, ensure_ascii=False, indent=2, sort_keys=True))
+        f.write("\n")
+    os.replace(tmpm, manifest_path)
+    ledger_hash = sha256_file(manifest_path)
+
+    user_turns_total = (len(turns) + 1) // 2 if turns else 0
+    parses_ok = sum(
+        1
+        for p in parse_events
+        if isinstance(p, dict) and isinstance(p.get("payload"), dict) and bool(p["payload"].get("parse_ok", False))
+    )
+    clarifications = sum(1 for tr in trials if isinstance(tr, dict) and str(tr.get("objective_kind") or "") == "COMM_ASK_CLARIFY")
+    unknowns = sum(
+        1
+        for p in parse_events
+        if isinstance(p, dict) and isinstance(p.get("payload"), dict) and str(p["payload"].get("intent_id") or "") == INTENT_UNKNOWN_V92
+    )
+
+    beliefs_add_total = sum(
+        1
+        for p in parse_events
+        if isinstance(p, dict) and isinstance(p.get("payload"), dict) and str(p["payload"].get("intent_id") or "") == INTENT_BELIEF_ADD_V96
+    )
+    beliefs_revise_total = sum(
+        1
+        for p in parse_events
+        if isinstance(p, dict) and isinstance(p.get("payload"), dict) and str(p["payload"].get("intent_id") or "") == INTENT_BELIEF_REVISE_V96
+    )
+    beliefs_list_total = sum(
+        1
+        for p in parse_events
+        if isinstance(p, dict) and isinstance(p.get("payload"), dict) and str(p["payload"].get("intent_id") or "") == INTENT_BELIEF_LIST_V96
+    )
+    beliefs_forget_total = sum(
+        1
+        for p in parse_events
+        if isinstance(p, dict) and isinstance(p.get("payload"), dict) and str(p["payload"].get("intent_id") or "") == INTENT_BELIEF_FORGET_V96
+    )
+
+    core = {
+        "schema_version": 5,
+        "seed": int(seed),
+        "store_hash": str(store_hash),
+        "system_spec_sha256": str(system_spec_sha256),
+        "transcript_hash": str(transcript_hash),
+        "state_chain_hash": str(state_chain_hash),
+        "parse_chain_hash": str(parse_chain_hash),
+        "learned_chain_hash": str(learned_chain_hash),
+        "plan_chain_hash": str(plan_chain_hash),
+        "memory_chain_hash": str(memory_chain_hash),
+        "belief_chain_hash": str(belief_chain_hash),
+        "evidence_chain_hash": str(evidence_chain_hash),
+        "goal_chain_hash": str(goal_chain_hash),
+        "discourse_chain_hash": str(discourse_chain_hash),
+        "fragment_chain_hash": str(fragment_chain_hash),
+        "binding_chain_hash": str(binding_chain_hash),
+        "style_chain_hash": str(style_chain_hash),
+        "ledger_hash": str(ledger_hash),
+        "turns_total": int(len(turns)),
+        "user_turns_total": int(user_turns_total),
+        "states_total": int(len(states)),
+        "plans_total": int(len(action_plans)),
+        "memory_events_total": int(len(memory_events)),
+        "belief_events_total": int(len(belief_events)),
+        "evidence_events_total": int(len(evidence_events)),
+        "goal_events_total": int(len(goal_events)),
+        "discourse_events_total": int(len(discourse_events)),
+        "fragment_events_total": int(len(fragment_events)),
+        "binding_events_total": int(len(binding_events)),
+        "style_events_total": int(len(style_events)),
+        "parses_total": int(len(parse_events)),
+        "parses_ok": int(parses_ok),
+        "clarifications": int(clarifications),
+        "unknowns": int(unknowns),
+        "belief_add_total": int(beliefs_add_total),
+        "belief_revise_total": int(beliefs_revise_total),
+        "belief_list_total": int(beliefs_list_total),
+        "belief_forget_total": int(beliefs_forget_total),
+        "verify_ok": bool(verify_obj.get("ok", False)),
+    }
+    summary_sha256 = sha256_hex(canonical_json_dumps(core).encode("utf-8"))
+    summary = dict(core, summary_sha256=str(summary_sha256))
+    tmps = summary_path + ".tmp"
+    with open(tmps, "w", encoding="utf-8") as f:
+        f.write(json.dumps(summary, ensure_ascii=False, indent=2, sort_keys=True))
+        f.write("\n")
+    os.replace(tmps, summary_path)
+
+    return {
+        "schema_version": 5,
+        "out_dir": str(out_dir),
+        "conversation_id": str(conversation_id),
+        "store_hash": str(store_hash),
+        "system_spec_sha256": str(system_spec_sha256),
+        "transcript_hash": str(transcript_hash),
+        "state_chain_hash": str(state_chain_hash),
+        "parse_chain_hash": str(parse_chain_hash),
+        "learned_chain_hash": str(learned_chain_hash),
+        "plan_chain_hash": str(plan_chain_hash),
+        "memory_chain_hash": str(memory_chain_hash),
+        "belief_chain_hash": str(belief_chain_hash),
+        "evidence_chain_hash": str(evidence_chain_hash),
+        "goal_chain_hash": str(goal_chain_hash),
+        "discourse_chain_hash": str(discourse_chain_hash),
+        "fragment_chain_hash": str(fragment_chain_hash),
+        "binding_chain_hash": str(binding_chain_hash),
+        "style_chain_hash": str(style_chain_hash),
+        "ledger_hash": str(ledger_hash),
+        "summary_sha256": str(summary_sha256),
+        "paths": {
+            "store_jsonl": str(store_path),
+            "grammar_snapshot_json": str(grammar_snapshot_path),
+            "system_spec_snapshot_json": str(system_spec_path),
+            "turns_jsonl": str(turns_path),
+            "parses_jsonl": str(parses_path),
+            "learned_rules_jsonl": str(learned_path),
+            "plans_jsonl": str(plans_path),
+            "memory_events_jsonl": str(memory_path),
+            "belief_events_jsonl": str(belief_path),
+            "evidence_events_jsonl": str(evidence_path),
+            "goal_events_jsonl": str(goal_path),
+            "goal_ledger_snapshot_json": str(goal_snapshot_path),
+            "discourse_events_jsonl": str(discourse_path),
+            "fragment_events_jsonl": str(fragment_events_path),
+            "fragment_library_snapshot_json": str(fragment_snapshot_path),
+            "binding_events_jsonl": str(binding_events_path),
+            "binding_snapshot_json": str(binding_snapshot_path),
+            "style_events_jsonl": str(style_path),
+            "template_library_snapshot_v102_json": str(template_snapshot_path),
+            "states_jsonl": str(states_path),
+            "trials_jsonl": str(trials_path),
+            "evals_jsonl": str(evals_path),
+            "transcript_jsonl": str(transcript_path),
+            "verify_json": str(verify_path),
+            "manifest_json": str(manifest_path),
+            "summary_json": str(summary_path),
+        },
+    }
--- /dev/null	2026-01-13 23:10:59
+++ atos_core/conversation_v102.py	2026-01-13 23:09:56
@@ -0,0 +1,307 @@
+from __future__ import annotations
+
+import json
+from typing import Any, Dict, List, Optional, Sequence, Tuple
+
+from .act import canonical_json_dumps
+from .conversation_v101 import verify_conversation_chain_v101
+from .discourse_templates_v102 import TemplateV102, base_templates_v102, render_templates_list_text_v102
+from .intent_grammar_v100 import INTENT_DISCOURSE_V100
+from .intent_grammar_v102 import (
+    INTENT_EXPLAIN_STYLE_V102,
+    INTENT_STYLE_PROFILE_V102,
+    INTENT_TEMPLATES_V102,
+    INTENT_TRACE_STYLE_V102,
+)
+from .style_ledger_v102 import compute_style_chain_hash_v102, fold_template_stats_v102, template_library_snapshot_v102, verify_style_event_sig_v102
+from .style_profile_v102 import StyleProfileV102, coerce_style_profile_v102, default_style_profile_v102, render_style_profile_text_v102
+from .style_selector_v102 import explain_style_text_v102
+
+
+def _canon_str_list(items: Any) -> List[str]:
+    out: List[str] = []
+    if not isinstance(items, list):
+        return out
+    for x in items:
+        if isinstance(x, str) and x:
+            out.append(str(x))
+    return sorted(set(out))
+
+
+def render_trace_style_text_v102(*, turn_id: str, style_events: Sequence[Dict[str, Any]]) -> str:
+    tid = str(turn_id or "")
+    for ev in style_events:
+        if isinstance(ev, dict) and str(ev.get("turn_id") or "") == tid:
+            return f"TRACE_STYLE: turn_id={tid} style_event_id={str(ev.get('event_id') or '')}"
+    return f"TRACE_STYLE: turn_id={tid} style_event_id="
+
+
+def render_dossier_text_v102() -> str:
+    """
+    Deterministic, audit-oriented dossier (V102). Adds style ledger invariants.
+    """
+    lines: List[str] = []
+    lines.append("DOSSIER (V102):")
+    lines.append("1) Record-keeping: WORM write-once files + append-only hash-chained JSONL logs.")
+    lines.append("2) Replay: run verifier scripts on run_dir (e.g., scripts/verify_conversation_chain_v102.py --run_dir <RUN_DIR>).")
+    lines.append("3) Determinismo: seed=0; canonical_json_dumps; explicit sorting; no wall-clock time.")
+    lines.append("4) Style layer: style_events.jsonl (hash-chained + event_sig) with candidates TOP-K, critics, selection, and style_chain_hash.")
+    lines.append("5) Fail-closed: if all style candidates fail critics, fallback safe response is emitted and logged.")
+    lines.append("6) No-hybridization: verifier scans atos_core/ and scripts/ for forbidden ML/LLM imports.")
+    return "\n".join(lines)
+
+
+def verify_conversation_chain_v102(
+    *,
+    turns: Sequence[Dict[str, Any]],
+    states: Sequence[Dict[str, Any]],
+    parse_events: Sequence[Dict[str, Any]],
+    trials: Sequence[Dict[str, Any]],
+    learned_rule_events: Sequence[Dict[str, Any]],
+    action_plans: Sequence[Dict[str, Any]],
+    memory_events: Sequence[Dict[str, Any]],
+    belief_events: Sequence[Dict[str, Any]],
+    evidence_events: Sequence[Dict[str, Any]],
+    goal_events: Sequence[Dict[str, Any]],
+    goal_snapshot: Dict[str, Any],
+    discourse_events: Sequence[Dict[str, Any]],
+    fragment_events: Sequence[Dict[str, Any]],
+    binding_events: Sequence[Dict[str, Any]],
+    binding_snapshot: Dict[str, Any],
+    style_events: Sequence[Dict[str, Any]],
+    template_snapshot: Dict[str, Any],
+    tail_k: int,
+    repo_root: str,
+) -> Tuple[bool, str, Dict[str, Any]]:
+    """
+    V102 invariants:
+      - All V101 invariants must hold (backwards compatible).
+      - style_events: signature chain ok; selected candidate matches assistant text; deterministic sorting.
+      - template_snapshot matches fold(style_events).
+      - Deterministic renderers for style_profile/templates/explain_style/trace_style.
+    """
+    ok0, reason0, details0 = verify_conversation_chain_v101(
+        turns=turns,
+        states=states,
+        parse_events=parse_events,
+        trials=trials,
+        learned_rule_events=learned_rule_events,
+        action_plans=action_plans,
+        memory_events=memory_events,
+        belief_events=belief_events,
+        evidence_events=evidence_events,
+        goal_events=goal_events,
+        goal_snapshot=dict(goal_snapshot),
+        discourse_events=discourse_events,
+        fragment_events=fragment_events,
+        binding_events=binding_events,
+        binding_snapshot=dict(binding_snapshot),
+        tail_k=int(tail_k),
+        repo_root=str(repo_root),
+    )
+    if not ok0:
+        return False, str(reason0), dict(details0)
+
+    # Turn indices helpers.
+    by_turn_id: Dict[str, Dict[str, Any]] = {}
+    by_index: Dict[int, Dict[str, Any]] = {}
+    max_idx = -1
+    for t in turns:
+        if not isinstance(t, dict):
+            continue
+        tid = str(t.get("turn_id") or "")
+        if tid:
+            by_turn_id[tid] = dict(t)
+        try:
+            idx = int(t.get("turn_index", -1))
+        except Exception:
+            idx = -1
+        if idx >= 0:
+            by_index[idx] = dict(t)
+            max_idx = max(max_idx, int(idx))
+
+    parses_by_turn_id: Dict[str, Dict[str, Any]] = {}
+    for pe in parse_events:
+        if not isinstance(pe, dict):
+            continue
+        tid = str(pe.get("turn_id") or "")
+        payload = pe.get("payload") if isinstance(pe.get("payload"), dict) else {}
+        if tid:
+            parses_by_turn_id[tid] = dict(payload)
+
+    # State by user turn id (existing invariant: absent for clarifications/confirmations).
+    state_by_user_turn_id: Dict[str, Dict[str, Any]] = {}
+    for st in states:
+        if not isinstance(st, dict):
+            continue
+        utid = str(st.get("last_user_turn_id") or "")
+        if utid:
+            state_by_user_turn_id[utid] = dict(st)
+
+    # Verify style event sig chain and selection correctness.
+    prev_sig = ""
+    prev_after: Optional[Dict[str, Any]] = None
+    for i, ev in enumerate(list(style_events)):
+        if not isinstance(ev, dict):
+            return False, "style_event_not_dict", {"index": int(i)}
+        ok_ev, rreason, rdetails = verify_style_event_sig_v102(dict(ev))
+        if not ok_ev:
+            return False, str(rreason), dict(rdetails)
+        if str(ev.get("prev_event_sig") or "") != str(prev_sig):
+            return False, "style_prev_event_sig_mismatch", {"index": int(i)}
+        prev_sig = str(ev.get("event_sig") or "")
+
+        before = ev.get("style_profile_before") if isinstance(ev.get("style_profile_before"), dict) else {}
+        after = ev.get("style_profile_after") if isinstance(ev.get("style_profile_after"), dict) else {}
+        if prev_after is not None and canonical_json_dumps(dict(before)) != canonical_json_dumps(dict(prev_after)):
+            return False, "style_profile_chain_mismatch", {"index": int(i)}
+        prev_after = dict(after)
+
+        turn_id = str(ev.get("turn_id") or "")
+        at = by_turn_id.get(turn_id)
+        if not isinstance(at, dict):
+            return False, "style_turn_missing", {"turn_id": turn_id}
+        if str(at.get("role") or "") != "assistant":
+            return False, "style_turn_not_assistant", {"turn_id": turn_id}
+
+        sel_id = str(ev.get("selected_candidate_id") or "")
+        cands = ev.get("candidates_topk") if isinstance(ev.get("candidates_topk"), list) else []
+        cand_by_id: Dict[str, Dict[str, Any]] = {}
+        for c in cands:
+            if isinstance(c, dict) and str(c.get("candidate_id") or ""):
+                cand_by_id[str(c.get("candidate_id") or "")] = dict(c)
+        if sel_id and sel_id not in cand_by_id:
+            return False, "style_selected_candidate_missing", {"turn_id": turn_id}
+        if sel_id:
+            sel = cand_by_id[sel_id]
+            got_sha = str(sel.get("text_sha256") or "")
+            # recompute sha from assistant text (stored sha in candidate is stable hash, not file hash).
+            # Candidate sha is computed by style_critics_v102.text_sha256_v102: sha256_hex(text_bytes).
+            from .style_critics_v102 import text_sha256_v102  # local import to avoid cycles
+
+            at_text = str(at.get("text") or "")
+            at_sha = text_sha256_v102(at_text)
+            if got_sha != at_sha:
+                return False, "style_selected_text_sha_mismatch", {"turn_id": turn_id}
+
+        # Verify candidates sorted deterministically by stored fields.
+        def _rk(c: Dict[str, Any]) -> Tuple[Any, ...]:
+            okc = bool(((c.get("critics") or {}).get("ok")) if isinstance(c.get("critics"), dict) else False)
+            m = c.get("fluency_metrics") if isinstance(c.get("fluency_metrics"), dict) else {}
+            return (
+                0 if okc else 1,
+                -float(c.get("fluency_score") or 0.0),
+                int(m.get("words") or 0),
+                str(c.get("template_id") or ""),
+                str(c.get("text_sha256") or ""),
+                str(c.get("candidate_id") or ""),
+            )
+
+        got_ids = [str(c.get("candidate_id") or "") for c in cands if isinstance(c, dict)]
+        want_ids = [str(c.get("candidate_id") or "") for c in sorted([dict(x) for x in cands if isinstance(x, dict)], key=_rk)]
+        if got_ids != want_ids:
+            return False, "style_candidates_not_sorted", {"turn_id": turn_id}
+
+        sel_meta = ev.get("selection") if isinstance(ev.get("selection"), dict) else {}
+        method = str(sel_meta.get("method") or "")
+        if method == "argmax":
+            # must pick the first ok candidate.
+            ok_ids = [cid for cid in want_ids if cid and bool(((cand_by_id.get(cid, {}).get("critics") or {}).get("ok")))]
+            if ok_ids and sel_id and sel_id != ok_ids[0]:
+                return False, "style_argmax_not_top1", {"turn_id": turn_id}
+        elif method == "soft":
+            # must pick top3[soft_index] among ok candidates.
+            try:
+                sidx = int(sel_meta.get("soft_index") or 0)
+            except Exception:
+                sidx = 0
+            ok_ids = [cid for cid in want_ids if cid and bool(((cand_by_id.get(cid, {}).get("critics") or {}).get("ok")))]
+            top3 = ok_ids[:3]
+            if top3:
+                want = top3[min(max(sidx, 0), len(top3) - 1)]
+                if sel_id != want:
+                    return False, "style_soft_selection_mismatch", {"turn_id": turn_id}
+        elif method == "fallback":
+            # ok
+            pass
+        elif method == "locked":
+            # Selection was intentionally locked to the base/core text (no style override).
+            pass
+        else:
+            return False, "style_unknown_selection_method", {"turn_id": turn_id, "method": method}
+
+    # Template snapshot must match fold from events.
+    templates = base_templates_v102()
+    want_stats = fold_template_stats_v102(templates=list(templates), style_events=list(style_events))
+    want_snap = template_library_snapshot_v102(templates=list(templates), style_events=list(style_events))
+    if canonical_json_dumps(dict(template_snapshot)) != canonical_json_dumps(dict(want_snap)):
+        return False, "template_snapshot_mismatch", {"want": str(want_snap.get("snapshot_sig") or ""), "got": str(template_snapshot.get("snapshot_sig") or "")}
+
+    # Cross-check deterministic renderers for style introspection commands.
+    # For each user turn, if intent is one of the style commands, assistant text must match renderer.
+    for i in range(0, max_idx + 1, 2):
+        ut = by_index.get(i)
+        at = by_index.get(i + 1)
+        if not isinstance(ut, dict) or not isinstance(at, dict):
+            continue
+        utid = str(ut.get("turn_id") or "")
+        payload = parses_by_turn_id.get(utid)
+        if not isinstance(payload, dict):
+            continue
+        iid = str(payload.get("intent_id") or "")
+        if iid == INTENT_STYLE_PROFILE_V102:
+            st = state_by_user_turn_id.get(utid, {})
+            bnd = st.get("bindings") if isinstance(st.get("bindings"), dict) else {}
+            prof = coerce_style_profile_v102(bnd.get("style_profile"))
+            want = render_style_profile_text_v102(prof)
+            if str(at.get("text") or "") != str(want):
+                return False, "style_profile_text_mismatch", {"turn_id": utid}
+        if iid == INTENT_TEMPLATES_V102:
+            # `templates` must render the stats as-of that turn (prefix of style events),
+            # because the assistant cannot "know" future uses.
+            try:
+                at_idx = int(at.get("turn_index", -1))
+            except Exception:
+                at_idx = -1
+            prefix_style_events: List[Dict[str, Any]] = []
+            if at_idx >= 0:
+                for sev in style_events:
+                    if not isinstance(sev, dict):
+                        continue
+                    sev_tid = str(sev.get("turn_id") or "")
+                    sev_turn = by_turn_id.get(sev_tid)
+                    if not isinstance(sev_turn, dict):
+                        continue
+                    try:
+                        sev_idx = int(sev_turn.get("turn_index", -1))
+                    except Exception:
+                        sev_idx = -1
+                    if sev_idx >= 0 and sev_idx < at_idx:
+                        prefix_style_events.append(dict(sev))
+            stats_now = fold_template_stats_v102(templates=list(templates), style_events=list(prefix_style_events))
+            want = render_templates_list_text_v102(templates=list(templates), template_stats=dict(stats_now))
+            if str(at.get("text") or "") != str(want):
+                return False, "templates_text_mismatch", {"turn_id": utid}
+        if iid == INTENT_EXPLAIN_STYLE_V102:
+            turn_id = str(payload.get("turn_id") or "")
+            target_ev = None
+            for sev in style_events:
+                if isinstance(sev, dict) and str(sev.get("turn_id") or "") == turn_id:
+                    target_ev = dict(sev)
+                    break
+            if target_ev is None:
+                return False, "explain_style_missing_event", {"turn_id": utid, "target_turn_id": turn_id}
+            want = explain_style_text_v102(style_event=dict(target_ev))
+            if str(at.get("text") or "") != str(want):
+                return False, "explain_style_text_mismatch", {"turn_id": utid}
+        if iid == INTENT_TRACE_STYLE_V102:
+            turn_id = str(payload.get("turn_id") or "")
+            want = render_trace_style_text_v102(turn_id=str(turn_id), style_events=list(style_events))
+            if str(at.get("text") or "") != str(want):
+                return False, "trace_style_text_mismatch", {"turn_id": utid}
+
+    dd = dict(details0)
+    dd["style_events_total"] = int(len(style_events))
+    dd["style_chain_hash"] = str(compute_style_chain_hash_v102(style_events))
+    dd["template_snapshot_sig"] = str(want_snap.get("snapshot_sig") or "")
+    return True, "ok", dd
--- /dev/null	2026-01-13 23:10:59
+++ atos_core/discourse_templates_v102.py	2026-01-13 22:24:31
@@ -0,0 +1,333 @@
+from __future__ import annotations
+
+import json
+from dataclasses import dataclass
+from typing import Any, Dict, List, Optional, Sequence, Tuple
+
+from .act import canonical_json_dumps, sha256_hex
+from .style_profile_v102 import (
+    EXAMPLE_NO,
+    EXAMPLE_YES,
+    STRUCT_BULLETS,
+    STRUCT_PLAIN,
+    STRUCT_STEPS,
+    StyleProfileV102,
+    VERBOSITY_LONG,
+    VERBOSITY_SHORT,
+)
+
+
+def _stable_hash_obj(obj: Any) -> str:
+    return sha256_hex(canonical_json_dumps(obj).encode("utf-8"))
+
+
+def template_id_v102(name: str) -> str:
+    return str(name)
+
+
+@dataclass(frozen=True)
+class TemplateV102:
+    template_id: str
+    name: str
+    roles: List[str]
+    constraints: Dict[str, Any]
+    slots: List[str]
+
+    def to_dict(self) -> Dict[str, Any]:
+        body = {
+            "schema_version": 102,
+            "kind": "discourse_template_v102",
+            "template_id": str(self.template_id),
+            "name": str(self.name),
+            "roles": [str(x) for x in self.roles if isinstance(x, str) and x],
+            "constraints": dict(self.constraints) if isinstance(self.constraints, dict) else {},
+            "slots": [str(x) for x in self.slots if isinstance(x, str) and x],
+        }
+        body["template_sig"] = _stable_hash_obj(body)
+        body["mdl_cost_bytes"] = int(len(canonical_json_dumps(body).encode("utf-8")))
+        return dict(body)
+
+
+def base_templates_v102() -> List[TemplateV102]:
+    """
+    Deterministic seed template library (>=8).
+    Templates are "objects" (not free-form text); rendering happens in code, but
+    template_id/name/constraints/slots are explicit and hashable.
+    """
+    out: List[TemplateV102] = []
+    out.append(
+        TemplateV102(
+            template_id=template_id_v102("tmpl_v102_direct_short_v0"),
+            name="Direto (curto)",
+            roles=["respond", "confirm", "summarize"],
+            constraints={"structure": [STRUCT_PLAIN], "verbosity": [VERBOSITY_SHORT]},
+            slots=["CORE"],
+        )
+    )
+    out.append(
+        TemplateV102(
+            template_id=template_id_v102("tmpl_v102_direct_medium_v0"),
+            name="Direto (médio)",
+            roles=["respond", "confirm", "summarize"],
+            constraints={"structure": [STRUCT_PLAIN], "verbosity": ["MEDIUM"]},
+            slots=["CORE"],
+        )
+    )
+    out.append(
+        TemplateV102(
+            template_id=template_id_v102("tmpl_v102_short_plus_detail_v0"),
+            name="Curto + 1 detalhe",
+            roles=["respond", "summarize"],
+            constraints={"structure": [STRUCT_PLAIN], "verbosity": [VERBOSITY_SHORT, "MEDIUM"]},
+            slots=["CORE", "FOLLOWUP_Q"],
+        )
+    )
+    out.append(
+        TemplateV102(
+            template_id=template_id_v102("tmpl_v102_steps_v0"),
+            name="Passos (1/2/3)",
+            roles=["respond", "summarize", "confirm"],
+            constraints={"structure": [STRUCT_STEPS], "verbosity": [VERBOSITY_LONG, "MEDIUM"]},
+            slots=["CORE_STEPS", "EXAMPLE"],
+        )
+    )
+    out.append(
+        TemplateV102(
+            template_id=template_id_v102("tmpl_v102_bullets_v0"),
+            name="Bullets",
+            roles=["respond", "summarize"],
+            constraints={"structure": [STRUCT_BULLETS], "verbosity": [VERBOSITY_LONG, "MEDIUM"]},
+            slots=["CORE_BULLETS", "EXAMPLE"],
+        )
+    )
+    out.append(
+        TemplateV102(
+            template_id=template_id_v102("tmpl_v102_transition_core_v0"),
+            name="Transição suave + core",
+            roles=["respond", "summarize"],
+            constraints={"structure": [STRUCT_PLAIN], "verbosity": ["MEDIUM", VERBOSITY_LONG]},
+            slots=["TRANSITION", "CORE"],
+        )
+    )
+    out.append(
+        TemplateV102(
+            template_id=template_id_v102("tmpl_v102_clarify_ambiguous_v0"),
+            name="Clarificação (ambíguo/miss)",
+            roles=["clarify", "confirm"],
+            constraints={"requires_question": True},
+            slots=["CLARIFY"],
+        )
+    )
+    out.append(
+        TemplateV102(
+            template_id=template_id_v102("tmpl_v102_confusion_reexplain_v0"),
+            name="Reexplicar (confusão detectada)",
+            roles=["respond", "summarize", "confirm"],
+            constraints={"verbosity": [VERBOSITY_LONG]},
+            slots=["CORE", "EXAMPLE", "FOLLOWUP_Q"],
+        )
+    )
+    out.append(
+        TemplateV102(
+            template_id=template_id_v102("tmpl_v102_fallback_safe_v0"),
+            name="Fallback seguro",
+            roles=["respond", "clarify", "confirm"],
+            constraints={"fallback": True},
+            slots=["CORE", "FOLLOWUP_Q"],
+        )
+    )
+    out.sort(key=lambda t: str(t.template_id))
+    return out
+
+
+def template_by_id_v102(templates: Sequence[TemplateV102]) -> Dict[str, TemplateV102]:
+    out: Dict[str, TemplateV102] = {}
+    for t in templates:
+        if isinstance(t, TemplateV102) and str(t.template_id):
+            out[str(t.template_id)] = t
+    return dict(out)
+
+
+def is_template_compatible_v102(
+    *,
+    template: TemplateV102,
+    response_kind: str,
+    style_profile: StyleProfileV102,
+    binding_status: str,
+) -> bool:
+    roles = set([str(x) for x in template.roles if isinstance(x, str)])
+    rk = str(response_kind or "")
+    if rk and rk not in roles:
+        return False
+
+    c = template.constraints if isinstance(template.constraints, dict) else {}
+    # Clarification templates only when binding ambiguous/miss or response_kind is clarify/confirm.
+    if bool(c.get("requires_question", False)):
+        if rk not in {"clarify", "confirm"}:
+            return False
+        if str(binding_status or "") not in {"AMBIGUOUS", "MISS"} and rk != "clarify":
+            return False
+
+    # Apply style profile filters if provided.
+    allowed_struct = c.get("structure")
+    if isinstance(allowed_struct, list) and allowed_struct:
+        if str(style_profile.structure_preference) not in set([str(x) for x in allowed_struct]):
+            return False
+    allowed_verb = c.get("verbosity")
+    if isinstance(allowed_verb, list) and allowed_verb:
+        if str(style_profile.verbosity_preference) not in set([str(x) for x in allowed_verb]):
+            return False
+
+    return True
+
+
+def _split_lines(core_text: str) -> List[str]:
+    lines = [str(x).strip() for x in str(core_text).splitlines()]
+    return [x for x in lines if x]
+
+
+def _render_steps(lines: Sequence[str]) -> str:
+    out: List[str] = []
+    for i, ln in enumerate([str(x) for x in lines if isinstance(x, str) and x], start=1):
+        out.append(f"{i}) {ln}")
+    return "\n".join(out) if out else ""
+
+
+def _render_bullets(lines: Sequence[str]) -> str:
+    out: List[str] = []
+    for ln in [str(x) for x in lines if isinstance(x, str) and x]:
+        out.append(f"- {ln}")
+    return "\n".join(out) if out else ""
+
+
+def _example_for_context(intent_id: str, slots: Dict[str, Any]) -> str:
+    """
+    Deterministic minimal examples (no new facts).
+    """
+    iid = str(intent_id or "")
+    if iid == "INTENT_SET":
+        k = str(slots.get("k") or "x")
+        v = str(slots.get("v") or "4")
+        return f"Exemplo: set {k} to {v}"
+    if iid == "INTENT_GET":
+        k = str(slots.get("k") or "x")
+        return f"Exemplo: get {k}"
+    if iid == "INTENT_ADD":
+        a = str(slots.get("a") or "x")
+        b = str(slots.get("b") or "y")
+        return f"Exemplo: add {a} and {b}"
+    if iid == "INTENT_SUMMARY":
+        return "Exemplo: summary"
+    if iid == "INTENT_END":
+        return "Exemplo: end"
+    return ""
+
+
+def render_template_v102(
+    *,
+    template_id: str,
+    core_text: str,
+    response_kind: str,
+    style_profile: StyleProfileV102,
+    intent_id: str,
+    slots: Dict[str, Any],
+    binding_status: str,
+) -> Dict[str, Any]:
+    """
+    Render a template to text deterministically.
+    Returns: {"text": str, "fragment_ids": [...], "slots_filled": {...}}
+    """
+    tid = str(template_id or "")
+    core = str(core_text or "")
+    rk = str(response_kind or "")
+    bp = style_profile
+    lines = _split_lines(core)
+
+    frag_ids: List[str] = []
+    slots_filled: Dict[str, Any] = {}
+
+    if tid == "tmpl_v102_direct_short_v0":
+        return {"text": core, "fragment_ids": frag_ids, "slots_filled": slots_filled}
+
+    if tid == "tmpl_v102_direct_medium_v0":
+        return {"text": core, "fragment_ids": frag_ids, "slots_filled": slots_filled}
+
+    if tid == "tmpl_v102_short_plus_detail_v0":
+        follow = "Se quiser, posso detalhar."
+        return {"text": core + "\n" + follow, "fragment_ids": frag_ids, "slots_filled": {"FOLLOWUP_Q": follow}}
+
+    if tid == "tmpl_v102_steps_v0":
+        body = _render_steps(lines if lines else [core])
+        ex = _example_for_context(str(intent_id), dict(slots)) if bp.example_preference == EXAMPLE_YES else ""
+        if ex:
+            body = body + "\n" + ex
+        return {"text": body, "fragment_ids": frag_ids, "slots_filled": {"EXAMPLE": ex}}
+
+    if tid == "tmpl_v102_bullets_v0":
+        body = _render_bullets(lines if lines else [core])
+        ex = _example_for_context(str(intent_id), dict(slots)) if bp.example_preference == EXAMPLE_YES else ""
+        if ex:
+            body = body + "\n" + ex
+        return {"text": body, "fragment_ids": frag_ids, "slots_filled": {"EXAMPLE": ex}}
+
+    if tid == "tmpl_v102_transition_core_v0":
+        # Deterministic transition variants keyed by tone preference.
+        if bp.tone_preference == "FORMAL":
+            trans = "Sobre este ponto:"
+        elif bp.tone_preference == "INFORMAL":
+            trans = "Sobre isso:"
+        else:
+            trans = "Indo direto ao ponto:"
+        return {"text": trans + " " + core, "fragment_ids": frag_ids, "slots_filled": {"TRANSITION": trans}}
+
+    if tid == "tmpl_v102_clarify_ambiguous_v0":
+        # Ensure question mark exists (critics will also enforce).
+        prefix = "Para eu agir com precisão:"
+        text = core
+        if not core.startswith(prefix):
+            text = prefix + " " + core
+        if "?" not in text:
+            text = text.rstrip(".") + "?"
+        return {"text": text, "fragment_ids": frag_ids, "slots_filled": {"CLARIFY": text}}
+
+    if tid == "tmpl_v102_confusion_reexplain_v0":
+        ex = _example_for_context(str(intent_id), dict(slots)) if bp.example_preference == EXAMPLE_YES else ""
+        follow = "Faz sentido?"
+        text = core
+        if ex:
+            text = text + "\n" + ex
+        text = text + "\n" + follow
+        return {"text": text, "fragment_ids": frag_ids, "slots_filled": {"EXAMPLE": ex, "FOLLOWUP_Q": follow}}
+
+    if tid == "tmpl_v102_fallback_safe_v0":
+        follow = "Pode esclarecer o que você quer dizer?"
+        text = core
+        if rk in {"clarify", "confirm"}:
+            if "?" not in text:
+                text = text.rstrip(".") + "?"
+        text = text + "\n" + follow
+        return {"text": text, "fragment_ids": frag_ids, "slots_filled": {"FOLLOWUP_Q": follow}}
+
+    # Unknown template: fail-closed caller should fallback.
+    return {"text": core, "fragment_ids": frag_ids, "slots_filled": slots_filled, "unknown_template": True}
+
+
+def render_templates_list_text_v102(*, templates: Sequence[TemplateV102], template_stats: Dict[str, Any]) -> str:
+    """
+    Deterministic renderer for `templates` introspection.
+    """
+    lines: List[str] = ["TEMPLATES:"]
+    stats = template_stats if isinstance(template_stats, dict) else {}
+    for i, t in enumerate(list(templates), start=1):
+        if not isinstance(t, TemplateV102):
+            continue
+        st = stats.get(str(t.template_id)) if isinstance(stats.get(str(t.template_id)), dict) else {}
+        uses = int(st.get("uses", 0) or 0)
+        avg = float(st.get("avg_score", 0.0) or 0.0)
+        fail = float(st.get("fail_rate", 0.0) or 0.0)
+        promo = str(st.get("promotion_state") or "candidate")
+        lines.append(f"{i}) id={t.template_id} name={json.dumps(t.name, ensure_ascii=False)} uses={uses} avg_score={avg:.6f} fail_rate={fail:.6f} state={promo}")
+    if len(lines) == 1:
+        return "TEMPLATES: (empty)"
+    return "\n".join(lines)
+
--- /dev/null	2026-01-13 23:10:59
+++ atos_core/intent_grammar_v102.py	2026-01-13 22:27:30
@@ -0,0 +1,90 @@
+from __future__ import annotations
+
+import unicodedata
+from typing import Any, Dict
+
+
+INTENT_STYLE_PROFILE_V102 = "INTENT_STYLE_PROFILE"
+INTENT_TEMPLATES_V102 = "INTENT_TEMPLATES"
+INTENT_EXPLAIN_STYLE_V102 = "INTENT_EXPLAIN_STYLE"
+INTENT_TRACE_STYLE_V102 = "INTENT_TRACE_STYLE"
+
+
+def _strip_accents(text: str) -> str:
+    s = unicodedata.normalize("NFD", str(text))
+    return "".join(ch for ch in s if unicodedata.category(ch) != "Mn")
+
+
+def _norm_prefix(text: str) -> str:
+    return _strip_accents(str(text or "")).lower().strip()
+
+
+def is_style_profile_command_v102(user_text: str) -> bool:
+    s = _norm_prefix(user_text)
+    return bool(s in {"style_profile", "style profile", "perfil", "perfil de estilo", "estilo"})
+
+
+def parse_style_profile_command_v102(user_text: str) -> Dict[str, Any]:
+    s = _norm_prefix(user_text)
+    if not is_style_profile_command_v102(s):
+        return {"recognized": False}
+    return {"recognized": True, "ok": True, "reason": "ok", "prefix": s.split(" ")[0] if s else "style_profile"}
+
+
+def is_templates_command_v102(user_text: str) -> bool:
+    s = _norm_prefix(user_text)
+    return bool(s in {"templates", "modelos", "templates:", "modelos:"})
+
+
+def parse_templates_command_v102(user_text: str) -> Dict[str, Any]:
+    s = _norm_prefix(user_text)
+    if not is_templates_command_v102(s):
+        return {"recognized": False}
+    # Fail-closed on payload.
+    if ":" in s and s not in {"templates:", "modelos:"}:
+        return {"recognized": True, "ok": False, "reason": "bad_syntax_payload_not_allowed", "prefix": s.split(":")[0]}
+    return {"recognized": True, "ok": True, "reason": "ok", "prefix": s.split(":")[0]}
+
+
+def is_explain_style_command_v102(user_text: str) -> bool:
+    s = _norm_prefix(user_text)
+    return bool(s.startswith("explain_style") or s.startswith("explain style") or s.startswith("explique_estilo") or s.startswith("explique estilo"))
+
+
+def parse_explain_style_command_v102(user_text: str) -> Dict[str, Any]:
+    raw = str(user_text or "").strip()
+    s = _norm_prefix(raw)
+    if not is_explain_style_command_v102(s):
+        return {"recognized": False}
+    # Accept forms: "explain_style <turn_id>" or "explique estilo <turn_id>".
+    parts = s.replace("explain_style", "explain_style").replace("explain style", "explain_style").replace("explique_estilo", "explain_style").replace("explique estilo", "explain_style").split()
+    if len(parts) == 1:
+        return {"recognized": True, "ok": False, "reason": "missing_turn_id", "turn_id": ""}
+    if len(parts) != 2:
+        return {"recognized": True, "ok": False, "reason": "bad_arity", "turn_id": ""}
+    turn_id = str(parts[1] or "")
+    if not turn_id:
+        return {"recognized": True, "ok": False, "reason": "missing_turn_id", "turn_id": ""}
+    return {"recognized": True, "ok": True, "reason": "ok", "turn_id": turn_id}
+
+
+def is_trace_style_command_v102(user_text: str) -> bool:
+    s = _norm_prefix(user_text)
+    return bool(s.startswith("trace_style") or s.startswith("trace style") or s.startswith("tracar_estilo") or s.startswith("tracar estilo"))
+
+
+def parse_trace_style_command_v102(user_text: str) -> Dict[str, Any]:
+    raw = str(user_text or "").strip()
+    s = _norm_prefix(raw)
+    if not is_trace_style_command_v102(s):
+        return {"recognized": False}
+    parts = s.replace("trace style", "trace_style").replace("tracar estilo", "trace_style").replace("tracar_estilo", "trace_style").split()
+    if len(parts) == 1:
+        return {"recognized": True, "ok": False, "reason": "missing_turn_id", "turn_id": ""}
+    if len(parts) != 2:
+        return {"recognized": True, "ok": False, "reason": "bad_arity", "turn_id": ""}
+    turn_id = str(parts[1] or "")
+    if not turn_id:
+        return {"recognized": True, "ok": False, "reason": "missing_turn_id", "turn_id": ""}
+    return {"recognized": True, "ok": True, "reason": "ok", "turn_id": turn_id}
+
--- /dev/null	2026-01-13 23:10:59
+++ atos_core/style_critics_v102.py	2026-01-13 22:25:09
@@ -0,0 +1,160 @@
+from __future__ import annotations
+
+from typing import Any, Dict, List, Sequence, Tuple
+
+from .act import canonical_json_dumps, sha256_hex
+from .style_profile_v102 import StyleProfileV102, VERBOSITY_LONG, VERBOSITY_SHORT
+
+
+def _round6(x: Any) -> float:
+    try:
+        return float(round(float(x), 6))
+    except Exception:
+        return 0.0
+
+
+def _tokens(text: str) -> List[str]:
+    return [t for t in str(text or "").lower().split() if t]
+
+
+def _trigrams(tokens: Sequence[str]) -> List[Tuple[str, str, str]]:
+    toks = [str(t) for t in tokens if isinstance(t, str)]
+    return list(zip(toks, toks[1:], toks[2:])) if len(toks) >= 3 else []
+
+
+def _trigram_overlap_ratio(a: str, b: str) -> float:
+    ta = set(_trigrams(_tokens(a)))
+    tb = set(_trigrams(_tokens(b)))
+    if not ta or not tb:
+        return 0.0
+    inter = len(ta.intersection(tb))
+    denom = float(min(len(ta), len(tb)))
+    return float(inter) / denom if denom > 0 else 0.0
+
+
+def _prefix2(text: str) -> str:
+    toks = _tokens(text)
+    return " ".join(toks[:2])
+
+
+def _critic_result(*, critic_id: str, status: str, score_delta: float, metrics: Dict[str, Any], reason: str) -> Dict[str, Any]:
+    return {
+        "critic_id": str(critic_id),
+        "status": str(status),
+        "score_delta": _round6(score_delta),
+        "metrics": dict(metrics) if isinstance(metrics, dict) else {},
+        "reason": str(reason),
+    }
+
+
+def run_critics_v102(
+    *,
+    candidate_text: str,
+    response_kind: str,
+    style_profile: StyleProfileV102,
+    binding_status: str,
+    recent_assistant_texts: Sequence[str],
+    recent_template_ids: Sequence[str],
+    template_id: str,
+) -> Dict[str, Any]:
+    """
+    Deterministic critics (fail-closed on clarity issues).
+    Returns:
+      {"ok": bool, "total_score_delta": float, "results": [...], "metrics": {...}}
+    """
+    text = str(candidate_text or "")
+    rk = str(response_kind or "")
+    bs = str(binding_status or "")
+
+    results: List[Dict[str, Any]] = []
+    total = 0.0
+
+    toks = _tokens(text)
+    words = len(toks)
+    chars = len(text)
+    lines = len(text.splitlines())
+
+    # Critic: clarity for ambiguous/miss references.
+    needs_q = (rk in {"clarify", "confirm"}) or (bs in {"AMBIGUOUS", "MISS"})
+    has_q = "?" in text
+    if needs_q and not has_q:
+        results.append(_critic_result(critic_id="clarity_question", status="FAIL", score_delta=-1.0, metrics={"needs_question": True}, reason="missing_question_mark"))
+        total -= 1.0
+    else:
+        results.append(_critic_result(critic_id="clarity_question", status="PASS", score_delta=0.0, metrics={"needs_question": bool(needs_q), "has_question": bool(has_q)}, reason="ok"))
+
+    # Critic: length vs verbosity preference.
+    if style_profile.verbosity_preference == VERBOSITY_SHORT and words > 24:
+        delta = -0.10 * float(max(0, words - 24))
+        results.append(_critic_result(critic_id="length_short", status="WARN", score_delta=delta, metrics={"words": int(words)}, reason="too_long_for_short"))
+        total += float(delta)
+    elif style_profile.verbosity_preference == VERBOSITY_LONG and words < 8:
+        results.append(_critic_result(critic_id="length_long", status="WARN", score_delta=-0.20, metrics={"words": int(words)}, reason="too_short_for_long"))
+        total -= 0.20
+    else:
+        results.append(_critic_result(critic_id="length", status="PASS", score_delta=0.0, metrics={"words": int(words)}, reason="ok"))
+
+    # Critic: repetition with recent assistant turns (ngram overlap).
+    recent = [str(x) for x in recent_assistant_texts if isinstance(x, str) and x]
+    overlap_max = 0.0
+    for prev in recent[:3]:
+        overlap_max = max(overlap_max, _trigram_overlap_ratio(prev, text))
+    if overlap_max >= 0.80 and len(recent) > 0:
+        # Hard fail on near-duplicate.
+        results.append(_critic_result(critic_id="repeat_trigram", status="FAIL", score_delta=-1.0, metrics={"overlap_max": _round6(overlap_max)}, reason="near_duplicate"))
+        total -= 1.0
+    else:
+        penalty = -0.40 * float(overlap_max)
+        status = "WARN" if overlap_max >= 0.40 else "PASS"
+        results.append(_critic_result(critic_id="repeat_trigram", status=status, score_delta=penalty, metrics={"overlap_max": _round6(overlap_max)}, reason="ok"))
+        total += float(penalty)
+
+    # Critic: repeated prefix opener.
+    pref = _prefix2(text)
+    pref_prev = [_prefix2(x) for x in recent[:3] if isinstance(x, str)]
+    repeats = sum(1 for p in pref_prev if p and p == pref)
+    if repeats >= 2 and pref:
+        results.append(_critic_result(critic_id="repeat_prefix", status="WARN", score_delta=-0.30, metrics={"prefix": pref, "repeats": int(repeats)}, reason="prefix_repeated"))
+        total -= 0.30
+    else:
+        results.append(_critic_result(critic_id="repeat_prefix", status="PASS", score_delta=0.0, metrics={"prefix": pref, "repeats": int(repeats)}, reason="ok"))
+
+    # Critic: template overuse.
+    recent_t = [str(x) for x in recent_template_ids if isinstance(x, str) and x]
+    consecutive = 0
+    for t in reversed(recent_t):
+        if t == str(template_id):
+            consecutive += 1
+        else:
+            break
+    if consecutive >= 2:
+        results.append(_critic_result(critic_id="template_repeat", status="WARN", score_delta=-0.25, metrics={"consecutive": int(consecutive)}, reason="template_overused"))
+        total -= 0.25
+    else:
+        results.append(_critic_result(critic_id="template_repeat", status="PASS", score_delta=0.0, metrics={"consecutive": int(consecutive)}, reason="ok"))
+
+    ok = all(str(r.get("status") or "") != "FAIL" for r in results)
+    metrics = {"words": int(words), "chars": int(chars), "lines": int(lines), "binding_status": bs, "response_kind": rk}
+    return {"ok": bool(ok), "total_score_delta": _round6(total), "results": list(results), "metrics": dict(metrics)}
+
+
+def fluency_score_v102(*, base_score: float, critics: Dict[str, Any]) -> float:
+    """
+    Deterministic aggregate score in [0, 1].
+    """
+    score = float(base_score)
+    delta = float(critics.get("total_score_delta") or 0.0)
+    score = score + delta
+    if not bool(critics.get("ok", False)):
+        score = min(score, 0.0)
+    score = max(0.0, min(1.0, score))
+    return _round6(score)
+
+
+def text_sha256_v102(text: str) -> str:
+    return sha256_hex(str(text or "").encode("utf-8"))
+
+
+def candidate_sig_v102(body: Dict[str, Any]) -> str:
+    return sha256_hex(canonical_json_dumps(body).encode("utf-8"))
+
--- /dev/null	2026-01-13 23:10:59
+++ atos_core/style_ledger_v102.py	2026-01-13 22:27:02
@@ -0,0 +1,206 @@
+from __future__ import annotations
+
+import hashlib
+from dataclasses import dataclass
+from typing import Any, Dict, List, Optional, Sequence, Tuple
+
+from .act import canonical_json_dumps, deterministic_iso, sha256_hex
+from .discourse_templates_v102 import TemplateV102
+
+
+def _stable_hash_obj(obj: Any) -> str:
+    return sha256_hex(canonical_json_dumps(obj).encode("utf-8"))
+
+
+def style_event_id_v102(event_sig: str) -> str:
+    return f"style_event_v102_{str(event_sig)}"
+
+
+def _style_event_sig_v102(*, prev_event_sig: str, event_body: Dict[str, Any]) -> str:
+    payload = str(prev_event_sig or "") + canonical_json_dumps(event_body)
+    return sha256_hex(payload.encode("utf-8"))
+
+
+@dataclass(frozen=True)
+class StyleEventV102:
+    conversation_id: str
+    turn_id: str
+    turn_index: int
+    event_kind: str
+    style_profile_before: Dict[str, Any]
+    style_profile_after: Dict[str, Any]
+    candidates_topk: List[Dict[str, Any]]
+    selected_candidate_id: str
+    selected_template_id: str
+    selected_ok: bool
+    selection: Dict[str, Any]
+    cause_ids: Dict[str, Any]
+    created_step: int
+    prev_event_sig: str
+
+    def to_dict(self) -> Dict[str, Any]:
+        body = {
+            "schema_version": 102,
+            "kind": "style_event_v102",
+            "conversation_id": str(self.conversation_id),
+            "turn_id": str(self.turn_id),
+            "turn_index": int(self.turn_index),
+            "event_kind": str(self.event_kind),
+            "style_profile_before": dict(self.style_profile_before) if isinstance(self.style_profile_before, dict) else {},
+            "style_profile_after": dict(self.style_profile_after) if isinstance(self.style_profile_after, dict) else {},
+            "candidates_topk": [dict(x) for x in self.candidates_topk if isinstance(x, dict)],
+            "selected_candidate_id": str(self.selected_candidate_id),
+            "selected_template_id": str(self.selected_template_id),
+            "selected_ok": bool(self.selected_ok),
+            "selection": dict(self.selection) if isinstance(self.selection, dict) else {},
+            "cause_ids": dict(self.cause_ids) if isinstance(self.cause_ids, dict) else {},
+            "created_step": int(self.created_step),
+            "created_at": deterministic_iso(step=int(self.created_step)),
+        }
+        sig = _style_event_sig_v102(prev_event_sig=str(self.prev_event_sig or ""), event_body=dict(body))
+        return dict(body, prev_event_sig=str(self.prev_event_sig or ""), event_sig=str(sig), event_id=str(style_event_id_v102(sig)))
+
+
+def verify_style_event_sig_v102(ev: Dict[str, Any]) -> Tuple[bool, str, Dict[str, Any]]:
+    if not isinstance(ev, dict):
+        return False, "style_event_not_dict", {}
+    prev_sig = str(ev.get("prev_event_sig") or "")
+    want_sig = str(ev.get("event_sig") or "")
+    body = dict(ev)
+    body.pop("prev_event_sig", None)
+    body.pop("event_sig", None)
+    body.pop("event_id", None)
+    got_sig = _style_event_sig_v102(prev_event_sig=str(prev_sig), event_body=body)
+    if got_sig != want_sig:
+        return False, "style_event_sig_mismatch", {"want": str(want_sig), "got": str(got_sig)}
+    if str(ev.get("event_id") or "") != style_event_id_v102(want_sig):
+        return False, "style_event_id_mismatch", {"want": style_event_id_v102(want_sig), "got": str(ev.get("event_id") or "")}
+    return True, "ok", {}
+
+
+def compute_style_chain_hash_v102(style_events: Sequence[Dict[str, Any]]) -> str:
+    ids: List[str] = []
+    for ev in style_events:
+        if not isinstance(ev, dict):
+            continue
+        ids.append(str(ev.get("event_id") or ""))
+    return sha256_hex(canonical_json_dumps(ids).encode("utf-8"))
+
+
+def fold_template_stats_v102(
+    *,
+    templates: Sequence[TemplateV102],
+    style_events: Sequence[Dict[str, Any]],
+) -> Dict[str, Dict[str, Any]]:
+    """
+    Deterministic stats derived from STYLE_CHOSEN events.
+    """
+    stats: Dict[str, Dict[str, Any]] = {}
+    for t in templates:
+        if not isinstance(t, TemplateV102):
+            continue
+        stats[str(t.template_id)] = {
+            "template_id": str(t.template_id),
+            "uses": 0,
+            "ok_uses": 0,
+            "fail_uses": 0,
+            "score_sum": 0.0,
+            "avg_score": 0.0,
+            "fail_rate": 0.0,
+            "promotion_state": "candidate",
+            "mdl_cost_bytes": int(len(canonical_json_dumps(t.to_dict()).encode("utf-8"))),
+            "mdl_savings_estimate_bytes": 0,
+        }
+
+    for ev in style_events:
+        if not isinstance(ev, dict):
+            continue
+        if str(ev.get("event_kind") or "") != "STYLE_CHOSEN":
+            continue
+        tid = str(ev.get("selected_template_id") or "")
+        if tid not in stats:
+            continue
+        st = dict(stats[tid])
+        st["uses"] = int(st.get("uses") or 0) + 1
+        if bool(ev.get("selected_ok", False)):
+            st["ok_uses"] = int(st.get("ok_uses") or 0) + 1
+        else:
+            st["fail_uses"] = int(st.get("fail_uses") or 0) + 1
+        # Record the selected candidate's score (if present).
+        cands = ev.get("candidates_topk") if isinstance(ev.get("candidates_topk"), list) else []
+        sel_id = str(ev.get("selected_candidate_id") or "")
+        score = None
+        for c in cands:
+            if isinstance(c, dict) and str(c.get("candidate_id") or "") == sel_id:
+                try:
+                    score = float(c.get("fluency_score") or 0.0)
+                except Exception:
+                    score = 0.0
+                break
+        if score is not None:
+            st["score_sum"] = float(st.get("score_sum") or 0.0) + float(score)
+        stats[tid] = dict(st)
+
+    # Finalize derived stats and promotion state.
+    for tid in sorted(stats.keys(), key=str):
+        st = dict(stats[tid])
+        uses = int(st.get("uses") or 0)
+        ok = int(st.get("ok_uses") or 0)
+        fail = int(st.get("fail_uses") or 0)
+        avg = float(st.get("score_sum") or 0.0) / float(ok) if ok > 0 else 0.0
+        fail_rate = float(fail) / float(uses) if uses > 0 else 0.0
+        st["avg_score"] = float(round(avg, 6))
+        st["fail_rate"] = float(round(fail_rate, 6))
+
+        promo = "candidate"
+        # Minimal deterministic pressure (MVP):
+        # promote if used enough and performs well; demote/retire if consistently bad.
+        if uses >= 3 and avg >= 0.85 and fail_rate <= 0.34:
+            promo = "promoted"
+        if uses >= 3 and (avg <= 0.30 or fail_rate >= 0.67):
+            promo = "retired"
+        st["promotion_state"] = str(promo)
+        stats[tid] = dict(st)
+
+    return dict(stats)
+
+
+def template_library_snapshot_v102(
+    *,
+    templates: Sequence[TemplateV102],
+    style_events: Sequence[Dict[str, Any]],
+) -> Dict[str, Any]:
+    stats = fold_template_stats_v102(templates=list(templates), style_events=list(style_events))
+    items: List[Dict[str, Any]] = []
+    for t in templates:
+        if not isinstance(t, TemplateV102):
+            continue
+        td = t.to_dict()
+        st = stats.get(str(t.template_id)) if isinstance(stats.get(str(t.template_id)), dict) else {}
+        items.append(
+            {
+                "template_id": str(t.template_id),
+                "name": str(t.name),
+                "roles": list(td.get("roles") or []),
+                "constraints": dict(td.get("constraints") or {}),
+                "slots": list(td.get("slots") or []),
+                "template_sig": str(td.get("template_sig") or ""),
+                "mdl_cost_bytes": int(td.get("mdl_cost_bytes") or 0),
+                "stats": dict(st),
+            }
+        )
+    snap = {"schema_version": 102, "kind": "template_library_snapshot_v102", "templates": list(items)}
+    snap_sig = _stable_hash_obj(snap)
+    return dict(snap, snapshot_sig=str(snap_sig))
+
+
+def sha256_file_bytes_v102(path: str) -> str:
+    h = hashlib.sha256()
+    with open(path, "rb") as f:
+        while True:
+            b = f.read(1024 * 1024)
+            if not b:
+                break
+            h.update(b)
+    return h.hexdigest()
+
--- /dev/null	2026-01-13 23:10:59
+++ atos_core/style_profile_v102.py	2026-01-13 22:23:25
@@ -0,0 +1,249 @@
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Any, Dict, List, Optional, Sequence, Tuple
+
+from .act import canonical_json_dumps, sha256_hex
+from .intent_grammar_v92 import tokenize_user_text_v92
+
+
+def _stable_hash_obj(obj: Any) -> str:
+    return sha256_hex(canonical_json_dumps(obj).encode("utf-8"))
+
+
+VERBOSITY_SHORT = "SHORT"
+VERBOSITY_MEDIUM = "MEDIUM"
+VERBOSITY_LONG = "LONG"
+
+TONE_NEUTRAL = "NEUTRAL"
+TONE_INFORMAL = "INFORMAL"
+TONE_FORMAL = "FORMAL"
+
+STRUCT_PLAIN = "PLAIN"
+STRUCT_BULLETS = "BULLETS"
+STRUCT_STEPS = "STEPS"
+
+EXAMPLE_YES = "YES"
+EXAMPLE_NO = "NO"
+
+CLARIFY_LOW = "LOW"
+CLARIFY_MEDIUM = "MEDIUM"
+CLARIFY_HIGH = "HIGH"
+
+
+def _contains_phrase(tokens: Sequence[str], phrase: Sequence[str]) -> bool:
+    if not phrase:
+        return False
+    toks = [str(x) for x in tokens if isinstance(x, str)]
+    ph = [str(x) for x in phrase if isinstance(x, str)]
+    if len(toks) < len(ph):
+        return False
+    for i in range(0, len(toks) - len(ph) + 1):
+        if toks[i : i + len(ph)] == ph:
+            return True
+    return False
+
+
+def _canon_enum(val: Any, allowed: Sequence[str], default: str) -> str:
+    v = str(val or "")
+    return v if v in set([str(x) for x in allowed]) else str(default)
+
+
+@dataclass(frozen=True)
+class StyleProfileV102:
+    verbosity_preference: str
+    tone_preference: str
+    structure_preference: str
+    example_preference: str
+    clarification_tolerance: str
+    user_confusion_recent: bool
+    confusion_count: int
+    last_update_reason: str
+    last_update_turn_id: str
+
+    def to_dict(self) -> Dict[str, Any]:
+        sem = {
+            "schema_version": 102,
+            "kind": "style_profile_v102",
+            "verbosity_preference": str(self.verbosity_preference),
+            "tone_preference": str(self.tone_preference),
+            "structure_preference": str(self.structure_preference),
+            "example_preference": str(self.example_preference),
+            "clarification_tolerance": str(self.clarification_tolerance),
+            "user_confusion_recent": bool(self.user_confusion_recent),
+            "confusion_count": int(self.confusion_count),
+            "last_update_reason": str(self.last_update_reason),
+            "last_update_turn_id": str(self.last_update_turn_id),
+        }
+        sig = style_profile_sig_v102(sem)
+        return dict(sem, style_profile_sig=str(sig))
+
+
+def style_profile_sig_v102(profile_sem_sig: Dict[str, Any]) -> str:
+    d = dict(profile_sem_sig)
+    d.pop("style_profile_sig", None)
+    return sha256_hex(canonical_json_dumps(d).encode("utf-8"))
+
+
+def default_style_profile_v102() -> StyleProfileV102:
+    return StyleProfileV102(
+        verbosity_preference=VERBOSITY_MEDIUM,
+        tone_preference=TONE_NEUTRAL,
+        structure_preference=STRUCT_PLAIN,
+        example_preference=EXAMPLE_NO,
+        clarification_tolerance=CLARIFY_MEDIUM,
+        user_confusion_recent=False,
+        confusion_count=0,
+        last_update_reason="default",
+        last_update_turn_id="",
+    )
+
+
+def coerce_style_profile_v102(d: Any) -> StyleProfileV102:
+    if not isinstance(d, dict):
+        return default_style_profile_v102()
+    return StyleProfileV102(
+        verbosity_preference=_canon_enum(d.get("verbosity_preference"), [VERBOSITY_SHORT, VERBOSITY_MEDIUM, VERBOSITY_LONG], VERBOSITY_MEDIUM),
+        tone_preference=_canon_enum(d.get("tone_preference"), [TONE_NEUTRAL, TONE_INFORMAL, TONE_FORMAL], TONE_NEUTRAL),
+        structure_preference=_canon_enum(d.get("structure_preference"), [STRUCT_PLAIN, STRUCT_BULLETS, STRUCT_STEPS], STRUCT_PLAIN),
+        example_preference=_canon_enum(d.get("example_preference"), [EXAMPLE_YES, EXAMPLE_NO], EXAMPLE_NO),
+        clarification_tolerance=_canon_enum(d.get("clarification_tolerance"), [CLARIFY_LOW, CLARIFY_MEDIUM, CLARIFY_HIGH], CLARIFY_MEDIUM),
+        user_confusion_recent=bool(d.get("user_confusion_recent", False)),
+        confusion_count=int(d.get("confusion_count", 0) or 0),
+        last_update_reason=str(d.get("last_update_reason") or "coerced"),
+        last_update_turn_id=str(d.get("last_update_turn_id") or ""),
+    )
+
+
+def derive_style_profile_update_v102(
+    *,
+    prev: StyleProfileV102,
+    user_text: str,
+    user_turn_id: str,
+) -> Tuple[StyleProfileV102, List[Dict[str, Any]]]:
+    """
+    Deterministic style update rules (explicit; no ML):
+      - "curto/resumo/short/brief" => verbosity SHORT
+      - "detalhado/passo a passo/step by step" => verbosity LONG + STEPS
+      - "tópicos/bullets" => BULLETS
+      - "exemplo/example" => example YES
+      - confusion signals ("não entendi", "nao entendi", "??") => user_confusion_recent True + counter
+    If multiple triggers occur in the same text, precedence is:
+      detailed/steps > short > bullets > example.
+    """
+    toks = tokenize_user_text_v92(str(user_text))
+    toks_set = set([str(t) for t in toks])
+
+    wants_short = bool(toks_set.intersection({"curto", "resumo", "short", "brief", "conciso"}))
+    wants_bullets = bool(toks_set.intersection({"bullets", "topicos", "tópicos"})) or _contains_phrase(toks, ["show", "variables"])
+
+    wants_steps = False
+    if _contains_phrase(toks, ["passo", "a", "passo"]):
+        wants_steps = True
+    if _contains_phrase(toks, ["step", "by", "step"]):
+        wants_steps = True
+    if bool(toks_set.intersection({"detalhado", "detalhes", "detailed", "detailedly", "detalha"})):
+        wants_steps = True
+
+    wants_example = bool(toks_set.intersection({"exemplo", "example"}))
+
+    confusion = False
+    if _contains_phrase(toks, ["nao", "entendi"]) or _contains_phrase(toks, ["não", "entendi"]):
+        confusion = True
+    if "??" in str(user_text):
+        confusion = True
+    if bool(toks_set.intersection({"confuso", "confusa"})):
+        confusion = True
+
+    updates: List[Dict[str, Any]] = []
+    prof = prev
+
+    # Apply precedence: steps/detailed > short > bullets > example.
+    if wants_steps:
+        prof = StyleProfileV102(
+            verbosity_preference=VERBOSITY_LONG,
+            tone_preference=str(prev.tone_preference),
+            structure_preference=STRUCT_STEPS,
+            example_preference=EXAMPLE_YES if wants_example else str(prev.example_preference),
+            clarification_tolerance=str(prev.clarification_tolerance),
+            user_confusion_recent=bool(prev.user_confusion_recent),
+            confusion_count=int(prev.confusion_count),
+            last_update_reason="user_requested_detailed_steps",
+            last_update_turn_id=str(user_turn_id),
+        )
+        updates.append({"kind": "STYLE_PROFILE_UPDATE", "reason": "user_requested_detailed_steps"})
+    elif wants_short:
+        prof = StyleProfileV102(
+            verbosity_preference=VERBOSITY_SHORT,
+            tone_preference=str(prev.tone_preference),
+            structure_preference=STRUCT_PLAIN,
+            example_preference=str(prev.example_preference),
+            clarification_tolerance=str(prev.clarification_tolerance),
+            user_confusion_recent=bool(prev.user_confusion_recent),
+            confusion_count=int(prev.confusion_count),
+            last_update_reason="user_requested_short",
+            last_update_turn_id=str(user_turn_id),
+        )
+        updates.append({"kind": "STYLE_PROFILE_UPDATE", "reason": "user_requested_short"})
+
+    if wants_bullets and prof.structure_preference != STRUCT_BULLETS:
+        prof = StyleProfileV102(
+            verbosity_preference=str(prof.verbosity_preference),
+            tone_preference=str(prof.tone_preference),
+            structure_preference=STRUCT_BULLETS,
+            example_preference=str(prof.example_preference),
+            clarification_tolerance=str(prof.clarification_tolerance),
+            user_confusion_recent=bool(prof.user_confusion_recent),
+            confusion_count=int(prof.confusion_count),
+            last_update_reason="user_requested_bullets",
+            last_update_turn_id=str(user_turn_id),
+        )
+        updates.append({"kind": "STYLE_PROFILE_UPDATE", "reason": "user_requested_bullets"})
+
+    if wants_example and prof.example_preference != EXAMPLE_YES:
+        prof = StyleProfileV102(
+            verbosity_preference=str(prof.verbosity_preference),
+            tone_preference=str(prof.tone_preference),
+            structure_preference=str(prof.structure_preference),
+            example_preference=EXAMPLE_YES,
+            clarification_tolerance=str(prof.clarification_tolerance),
+            user_confusion_recent=bool(prof.user_confusion_recent),
+            confusion_count=int(prof.confusion_count),
+            last_update_reason="user_requested_example",
+            last_update_turn_id=str(user_turn_id),
+        )
+        updates.append({"kind": "STYLE_PROFILE_UPDATE", "reason": "user_requested_example"})
+
+    if confusion:
+        prof = StyleProfileV102(
+            verbosity_preference=str(prof.verbosity_preference),
+            tone_preference=str(prof.tone_preference),
+            structure_preference=str(prof.structure_preference),
+            example_preference=str(prof.example_preference),
+            clarification_tolerance=str(prof.clarification_tolerance),
+            user_confusion_recent=True,
+            confusion_count=int(prof.confusion_count) + 1,
+            last_update_reason="user_confusion_signal",
+            last_update_turn_id=str(user_turn_id),
+        )
+        updates.append({"kind": "STYLE_PROFILE_UPDATE", "reason": "user_confusion_signal"})
+
+    return prof, list(updates)
+
+
+def render_style_profile_text_v102(profile: StyleProfileV102) -> str:
+    """
+    Deterministic renderer for `style_profile` introspection.
+    """
+    p = profile
+    lines: List[str] = []
+    lines.append("STYLE_PROFILE:")
+    lines.append(f"verbosity={p.verbosity_preference}")
+    lines.append(f"tone={p.tone_preference}")
+    lines.append(f"structure={p.structure_preference}")
+    lines.append(f"example={p.example_preference}")
+    lines.append(f"clarification_tolerance={p.clarification_tolerance}")
+    lines.append(f"user_confusion_recent={str(bool(p.user_confusion_recent)).lower()} confusion_count={int(p.confusion_count)}")
+    lines.append(f"last_update_reason={p.last_update_reason} last_update_turn_id={p.last_update_turn_id}")
+    return "\n".join(lines)
+
--- /dev/null	2026-01-13 23:10:59
+++ atos_core/style_selector_v102.py	2026-01-13 22:26:16
@@ -0,0 +1,283 @@
+from __future__ import annotations
+
+import json
+from typing import Any, Dict, List, Optional, Sequence, Tuple
+
+from .act import canonical_json_dumps, sha256_hex
+from .discourse_templates_v102 import TemplateV102, is_template_compatible_v102, render_template_v102
+from .style_critics_v102 import fluency_score_v102, run_critics_v102, text_sha256_v102
+from .style_profile_v102 import (
+    EXAMPLE_YES,
+    STRUCT_BULLETS,
+    STRUCT_PLAIN,
+    STRUCT_STEPS,
+    StyleProfileV102,
+    VERBOSITY_LONG,
+    VERBOSITY_SHORT,
+)
+
+
+def _round6(x: Any) -> float:
+    try:
+        return float(round(float(x), 6))
+    except Exception:
+        return 0.0
+
+
+def _stable_hash_obj(obj: Any) -> str:
+    return sha256_hex(canonical_json_dumps(obj).encode("utf-8"))
+
+
+def style_candidate_id_v102(*, template_id: str, text_sha256: str, variant_id: str) -> str:
+    body = {"schema_version": 102, "template_id": str(template_id), "text_sha256": str(text_sha256), "variant_id": str(variant_id)}
+    return f"style_cand_v102_{_stable_hash_obj(body)}"
+
+
+def _base_score_v102(*, template_id: str, style_profile: StyleProfileV102, response_kind: str, binding_status: str) -> float:
+    score = 0.80
+    if style_profile.verbosity_preference == VERBOSITY_SHORT and template_id.endswith("direct_short_v0"):
+        score += 0.05
+    if style_profile.verbosity_preference == VERBOSITY_LONG and ("steps" in template_id or "confusion" in template_id):
+        score += 0.05
+    if style_profile.structure_preference == STRUCT_STEPS and "steps" in template_id:
+        score += 0.05
+    if style_profile.structure_preference == STRUCT_BULLETS and "bullets" in template_id:
+        score += 0.05
+    if style_profile.structure_preference == STRUCT_PLAIN and ("direct" in template_id or "transition" in template_id):
+        score += 0.02
+    if response_kind in {"clarify", "confirm"} and binding_status in {"AMBIGUOUS", "MISS"} and "clarify" in template_id:
+        score += 0.08
+    if bool(style_profile.user_confusion_recent) and "confusion" in template_id:
+        score += 0.10
+    score = max(0.0, min(1.0, score))
+    return _round6(score)
+
+
+def _soft_choice_index_v102(*, seed: int, salt: str, candidates: Sequence[Dict[str, Any]]) -> int:
+    """
+    Deterministic soft selection among the top candidates when scores are close.
+    Uses rank-based integer weights and a hash-derived pseudo-RNG.
+    """
+    ids = [str(c.get("candidate_id") or "") for c in candidates if isinstance(c, dict)]
+    body = {"seed": int(seed), "salt": str(salt), "ids": list(ids)}
+    h = sha256_hex(canonical_json_dumps(body).encode("utf-8"))
+    # Use first 8 hex chars as a stable integer.
+    try:
+        r = int(h[:8], 16)
+    except Exception:
+        r = 0
+    weights = [3, 2, 1, 1, 1][: len(ids)]
+    total = sum(weights) if weights else 1
+    pick = r % total
+    acc = 0
+    for i, w in enumerate(weights):
+        acc += int(w)
+        if pick < acc:
+            return int(i)
+    return 0
+
+
+def build_and_select_style_candidates_v102(
+    *,
+    templates: Sequence[TemplateV102],
+    core_text: str,
+    response_kind: str,
+    style_profile: StyleProfileV102,
+    intent_id: str,
+    slots: Dict[str, Any],
+    binding_status: str,
+    recent_assistant_texts: Sequence[str],
+    recent_template_ids: Sequence[str],
+    seed: int,
+    selection_salt: str,
+    top_k: int = 8,
+) -> Dict[str, Any]:
+    """
+    Returns:
+      {
+        "candidates_topk": [...sorted...],
+        "selected": {...},
+        "selection": {"method": "...", "margin": float, "soft_index": int},
+      }
+    Candidate schema is stable and audit-friendly.
+    """
+    rk = str(response_kind or "")
+    bs = str(binding_status or "")
+    prof = style_profile
+    slots2 = dict(slots) if isinstance(slots, dict) else {}
+
+    # Filter compatible templates; always keep fallback template as an option.
+    compatibles: List[TemplateV102] = []
+    fallback: Optional[TemplateV102] = None
+    for t in templates:
+        if not isinstance(t, TemplateV102):
+            continue
+        if bool(t.constraints.get("fallback", False)):
+            fallback = t
+        if is_template_compatible_v102(template=t, response_kind=rk, style_profile=prof, binding_status=bs):
+            compatibles.append(t)
+
+    # Ensure at least 5 templates compete (even if style filters are narrow).
+    if len(compatibles) < 5:
+        extra = [t for t in templates if isinstance(t, TemplateV102) and t not in compatibles]
+        extra.sort(key=lambda t: str(t.template_id))
+        for t in extra:
+            compatibles.append(t)
+            if len(compatibles) >= 5:
+                break
+
+    candidates: List[Dict[str, Any]] = []
+    for t in compatibles:
+        rend = render_template_v102(
+            template_id=str(t.template_id),
+            core_text=str(core_text),
+            response_kind=rk,
+            style_profile=prof,
+            intent_id=str(intent_id),
+            slots=dict(slots2),
+            binding_status=bs,
+        )
+        text = str(rend.get("text") or "")
+        tsha = text_sha256_v102(text)
+        base = _base_score_v102(template_id=str(t.template_id), style_profile=prof, response_kind=rk, binding_status=bs)
+        critics = run_critics_v102(
+            candidate_text=str(text),
+            response_kind=rk,
+            style_profile=prof,
+            binding_status=bs,
+            recent_assistant_texts=list(recent_assistant_texts),
+            recent_template_ids=list(recent_template_ids),
+            template_id=str(t.template_id),
+        )
+        score = fluency_score_v102(base_score=float(base), critics=dict(critics))
+        cid = style_candidate_id_v102(template_id=str(t.template_id), text_sha256=str(tsha), variant_id="v102")
+        candidates.append(
+            {
+                "schema_version": 102,
+                "kind": "style_candidate_v102",
+                "candidate_id": str(cid),
+                "template_id": str(t.template_id),
+                "renderer_id": "style_selector_v102",
+                "variant_id": "v102",
+                "text": str(text),
+                "text_sha256": str(tsha),
+                "base_score": float(base),
+                "critics": dict(critics),
+                "fluency_score": float(score),
+                "fluency_metrics": dict(critics.get("metrics") or {}),
+                "fragment_ids": [str(x) for x in rend.get("fragment_ids") or [] if isinstance(x, str) and x],
+                "slots_filled": dict(rend.get("slots_filled") or {}) if isinstance(rend.get("slots_filled"), dict) else {},
+            }
+        )
+
+    # Stable deterministic rank: score desc, ok first, template_id asc, sha asc, candidate_id asc.
+    def _rk_c(d: Dict[str, Any]) -> Tuple[Any, ...]:
+        ok = bool(((d.get("critics") or {}).get("ok")) if isinstance(d.get("critics"), dict) else False)
+        m = d.get("fluency_metrics") if isinstance(d.get("fluency_metrics"), dict) else {}
+        return (
+            0 if ok else 1,
+            -float(d.get("fluency_score") or 0.0),
+            int(m.get("words") or 0),
+            str(d.get("template_id") or ""),
+            str(d.get("text_sha256") or ""),
+            str(d.get("candidate_id") or ""),
+        )
+
+    candidates_sorted = sorted(list(candidates), key=_rk_c)
+    candidates_topk = candidates_sorted[: int(top_k)]
+
+    # Choose winner: if no ok candidates, fallback; else hard vs soft.
+    ok_cands = [c for c in candidates_sorted if isinstance(c, dict) and bool(((c.get("critics") or {}).get("ok")) if isinstance(c.get("critics"), dict) else False)]
+
+    selection = {"method": "argmax", "margin": 0.02, "soft_index": 0}
+    chosen: Dict[str, Any] = {}
+    if not ok_cands:
+        if fallback is None:
+            chosen = dict(candidates_topk[0]) if candidates_topk else {"candidate_id": "", "text": str(core_text), "text_sha256": text_sha256_v102(str(core_text))}
+        else:
+            # Render fallback deterministically.
+            rend2 = render_template_v102(
+                template_id=str(fallback.template_id),
+                core_text=str(core_text),
+                response_kind=rk,
+                style_profile=prof,
+                intent_id=str(intent_id),
+                slots=dict(slots2),
+                binding_status=bs,
+            )
+            text2 = str(rend2.get("text") or str(core_text))
+            tsha2 = text_sha256_v102(text2)
+            chosen = {
+                "schema_version": 102,
+                "kind": "style_candidate_v102",
+                "candidate_id": style_candidate_id_v102(template_id=str(fallback.template_id), text_sha256=str(tsha2), variant_id="v102_fallback"),
+                "template_id": str(fallback.template_id),
+                "renderer_id": "style_selector_v102",
+                "variant_id": "v102_fallback",
+                "text": str(text2),
+                "text_sha256": str(tsha2),
+                "base_score": 0.0,
+                "critics": {"ok": True, "total_score_delta": 0.0, "results": [], "metrics": {}},
+                "fluency_score": 0.0,
+                "fluency_metrics": {},
+                "fragment_ids": [],
+                "slots_filled": {},
+            }
+        selection = {"method": "fallback", "margin": 0.0, "soft_index": 0}
+    else:
+        # Consider soft selection only among the top-3 ok candidates when close.
+        top3 = ok_cands[:3]
+        if len(top3) >= 2:
+            s0 = float(top3[0].get("fluency_score") or 0.0)
+            s1 = float(top3[1].get("fluency_score") or 0.0)
+            margin = float(selection["margin"])
+            if abs(s0 - s1) <= margin:
+                idx = _soft_choice_index_v102(seed=int(seed), salt=str(selection_salt), candidates=list(top3))
+                selection = {"method": "soft", "margin": float(margin), "soft_index": int(idx)}
+                chosen = dict(top3[int(idx)])
+            else:
+                chosen = dict(top3[0])
+        else:
+            chosen = dict(ok_cands[0])
+
+    return {
+        "candidates_topk": [dict(x) for x in candidates_topk if isinstance(x, dict)],
+        "selected": dict(chosen),
+        "selection": dict(selection),
+    }
+
+
+def explain_style_text_v102(
+    *,
+    style_event: Dict[str, Any],
+    max_k: int = 5,
+) -> str:
+    """
+    Deterministic explain_style renderer based only on style_event fields.
+    """
+    ev = dict(style_event) if isinstance(style_event, dict) else {}
+    sel = str(ev.get("selected_candidate_id") or "")
+    tid = str(ev.get("selected_template_id") or "")
+    ok = bool(ev.get("selected_ok", False))
+    line1 = f"EXPLAIN_STYLE: chosen={sel} template={tid} ok={str(ok).lower()}"
+
+    cands = ev.get("candidates_topk") if isinstance(ev.get("candidates_topk"), list) else []
+    parts: List[str] = []
+    for i, c in enumerate(cands[: int(max_k)], start=1):
+        if not isinstance(c, dict):
+            continue
+        cid = str(c.get("candidate_id") or "")
+        t = str(c.get("template_id") or "")
+        sc = _round6(c.get("fluency_score"))
+        okc = bool(((c.get("critics") or {}).get("ok")) if isinstance(c.get("critics"), dict) else False)
+        parts.append(f"{i}){cid} tmpl={t} score={sc:.6f} ok={str(okc).lower()}")
+    line2 = "TOPK_STYLE: " + "; ".join(parts) if parts else "TOPK_STYLE:"
+
+    sel_reason = ev.get("selection") if isinstance(ev.get("selection"), dict) else {}
+    method = str(sel_reason.get("method") or "")
+    margin = _round6(sel_reason.get("margin"))
+    sidx = int(sel_reason.get("soft_index") or 0)
+    line3 = f"SELECTION: method={method} margin={margin:.6f} soft_index={sidx}"
+
+    return "\n".join([line1, line2, line3])
+
--- /dev/null	2026-01-13 23:10:59
+++ scripts/smoke_v102_style_profile_templates_soft_selection_dialogue_csv.py	2026-01-13 23:00:26
@@ -0,0 +1,365 @@
+#!/usr/bin/env python3
+from __future__ import annotations
+
+import argparse
+import hashlib
+import json
+import os
+import sys
+from typing import Any, Dict, List, Optional, Tuple
+
+sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
+
+from atos_core.conversation_loop_v102 import run_conversation_v102
+from atos_core.conversation_v102 import verify_conversation_chain_v102
+
+
+def sha256_file(path: str) -> str:
+    h = hashlib.sha256()
+    with open(path, "rb") as f:
+        while True:
+            b = f.read(1024 * 1024)
+            if not b:
+                break
+            h.update(b)
+    return h.hexdigest()
+
+
+def _fail(msg: str, *, code: int = 2) -> None:
+    print(msg, file=sys.stderr)
+    raise SystemExit(code)
+
+
+def ensure_absent(path: str) -> None:
+    if os.path.exists(path):
+        _fail(f"ERROR: path already exists (WORM): {path}")
+
+
+def _read_json(path: str) -> Dict[str, Any]:
+    with open(path, "r", encoding="utf-8") as f:
+        obj = json.load(f)
+    return obj if isinstance(obj, dict) else {}
+
+
+def _read_jsonl(path: str) -> List[Dict[str, Any]]:
+    rows: List[Dict[str, Any]] = []
+    with open(path, "r", encoding="utf-8") as f:
+        for line in f:
+            line = line.strip()
+            if not line:
+                continue
+            rows.append(json.loads(line))
+    return rows
+
+
+def _extract_payloads(path: str) -> List[Dict[str, Any]]:
+    out: List[Dict[str, Any]] = []
+    for r in _read_jsonl(path):
+        payload = r.get("payload")
+        if isinstance(payload, dict):
+            out.append(dict(payload))
+    return out
+
+
+def _extract_parse_events(path: str) -> List[Dict[str, Any]]:
+    out: List[Dict[str, Any]] = []
+    for r in _read_jsonl(path):
+        if not isinstance(r, dict):
+            continue
+        out.append(
+            {
+                "turn_id": str(r.get("turn_id") or ""),
+                "turn_index": int(r.get("turn_index") or 0),
+                "payload": dict(r.get("payload") or {}) if isinstance(r.get("payload"), dict) else {},
+            }
+        )
+    return out
+
+
+def _extract_trials_for_verify(path: str) -> List[Dict[str, Any]]:
+    out: List[Dict[str, Any]] = []
+    for r in _read_jsonl(path):
+        if not isinstance(r, dict):
+            continue
+        out.append({"objective_kind": str(r.get("objective_kind") or ""), "user_turn_id": str(r.get("user_turn_id") or r.get("turn_id") or "")})
+    return out
+
+
+def _extract_learned_events(path: str) -> List[Dict[str, Any]]:
+    if not os.path.exists(path):
+        return []
+    out: List[Dict[str, Any]] = []
+    for r in _read_jsonl(path):
+        if not isinstance(r, dict):
+            continue
+        d = dict(r)
+        d.pop("prev_hash", None)
+        d.pop("entry_hash", None)
+        out.append(d)
+    return out
+
+
+def _strip_chain_fields(path: str) -> List[Dict[str, Any]]:
+    out: List[Dict[str, Any]] = []
+    if not os.path.exists(path):
+        return out
+    for r in _read_jsonl(path):
+        if not isinstance(r, dict):
+            continue
+        d = dict(r)
+        d.pop("prev_hash", None)
+        d.pop("entry_hash", None)
+        out.append(d)
+    return out
+
+
+def _load_for_verify(res: Dict[str, Any]) -> Dict[str, Any]:
+    paths = res.get("paths") if isinstance(res.get("paths"), dict) else {}
+    turns = _extract_payloads(str(paths.get("turns_jsonl") or ""))
+    states_path = str(paths.get("states_jsonl") or "")
+    states = _extract_payloads(states_path) if states_path and os.path.exists(states_path) else []
+    parse_events = _extract_parse_events(str(paths.get("parses_jsonl") or ""))
+    trials = _extract_trials_for_verify(str(paths.get("trials_jsonl") or ""))
+    learned_events = _extract_learned_events(str(paths.get("learned_rules_jsonl") or ""))
+    plans = _strip_chain_fields(str(paths.get("plans_jsonl") or ""))
+    memory_events = _strip_chain_fields(str(paths.get("memory_events_jsonl") or ""))
+    belief_events = _strip_chain_fields(str(paths.get("belief_events_jsonl") or ""))
+    evidence_events = _strip_chain_fields(str(paths.get("evidence_events_jsonl") or ""))
+    goal_events = _extract_payloads(str(paths.get("goal_events_jsonl") or ""))
+    goal_snapshot = _read_json(str(paths.get("goal_ledger_snapshot_json") or ""))
+    discourse_events = _extract_payloads(str(paths.get("discourse_events_jsonl") or ""))
+    fragment_events = _extract_payloads(str(paths.get("fragment_events_jsonl") or ""))
+    binding_events = _strip_chain_fields(str(paths.get("binding_events_jsonl") or ""))
+    binding_snapshot = _read_json(str(paths.get("binding_snapshot_json") or ""))
+    style_events = _extract_payloads(str(paths.get("style_events_jsonl") or ""))
+    template_snapshot = _read_json(str(paths.get("template_library_snapshot_v102_json") or ""))
+    return {
+        "turns": turns,
+        "states": states,
+        "parse_events": parse_events,
+        "trials": trials,
+        "learned_events": learned_events,
+        "plans": plans,
+        "memory_events": memory_events,
+        "belief_events": belief_events,
+        "evidence_events": evidence_events,
+        "goal_events": goal_events,
+        "goal_snapshot": goal_snapshot,
+        "discourse_events": discourse_events,
+        "fragment_events": fragment_events,
+        "binding_events": binding_events,
+        "binding_snapshot": binding_snapshot,
+        "style_events": style_events,
+        "template_snapshot": template_snapshot,
+    }
+
+
+def _assistant_text_at_index(turns: List[Dict[str, Any]], assistant_turn_index: int) -> str:
+    for t in turns:
+        if not isinstance(t, dict):
+            continue
+        if str(t.get("role") or "") != "assistant":
+            continue
+        if int(t.get("turn_index") or -1) == int(assistant_turn_index):
+            return str(t.get("text") or "")
+    return ""
+
+
+def smoke_try(*, out_dir: str, seed: int) -> Dict[str, Any]:
+    # Covers:
+    # - style_profile updates from user phrasing (short -> long/steps -> confusion/example)
+    # - bindings ("isso") ambiguity -> clarify template should win
+    # - TEACH learned rule used immediately
+    # - templates list at end uses derived stats
+    user_turns = [
+        "responde curto",
+        "style_profile",
+        "agora explica bem detalhado",
+        "style_profile",
+        "set x to four",
+        "set y to 8",
+        "add x and y please",
+        "belief: project = IAAA",
+        "crie um plano de 3 passos para x",
+        "isso",
+        "teach: statusvars => summary",
+        "statusvars",
+        "templates",
+        "end now",
+    ]
+    res = run_conversation_v102(user_turn_texts=list(user_turns), out_dir=str(out_dir), seed=int(seed))
+
+    loaded = _load_for_verify(res)
+    repo_root = os.path.dirname(os.path.dirname(__file__))
+
+    ok_good, reason_good, details_good = verify_conversation_chain_v102(
+        turns=loaded["turns"],
+        states=loaded["states"],
+        parse_events=loaded["parse_events"],
+        trials=loaded["trials"],
+        learned_rule_events=loaded["learned_events"],
+        action_plans=loaded["plans"],
+        memory_events=loaded["memory_events"],
+        belief_events=loaded["belief_events"],
+        evidence_events=loaded["evidence_events"],
+        goal_events=loaded["goal_events"],
+        goal_snapshot=dict(loaded["goal_snapshot"]),
+        discourse_events=loaded["discourse_events"],
+        fragment_events=loaded["fragment_events"],
+        binding_events=loaded["binding_events"],
+        binding_snapshot=dict(loaded["binding_snapshot"]),
+        style_events=loaded["style_events"],
+        template_snapshot=dict(loaded["template_snapshot"]),
+        tail_k=6,
+        repo_root=str(repo_root),
+    )
+    if not ok_good:
+        _fail(f"ERROR: verify_conversation_chain_v102 failed: {reason_good} details={json.dumps(details_good, ensure_ascii=False, sort_keys=True)}")
+
+    # Assertions: style_events must exist and have >=5 candidates in at least one event.
+    style_events = loaded["style_events"]
+    if not style_events:
+        _fail("ERROR: expected non-empty style_events")
+    max_cands = max(int(len(ev.get("candidates_topk") or [])) if isinstance(ev, dict) else 0 for ev in style_events)
+    if max_cands < 5:
+        _fail(f"ERROR: expected at least 5 style candidates, got max={max_cands}")
+
+    # Style profile must reflect SHORT after first update (assistant turn index 3 is response to style_profile at user turn index 2).
+    # Turns are 0-based user+assistant alternating; user turn indices are even, assistant are odd.
+    t_style_profile_1 = _assistant_text_at_index(loaded["turns"], 3)
+    if "verbosity=SHORT" not in t_style_profile_1:
+        _fail("ERROR: expected style_profile to include verbosity=SHORT")
+    t_style_profile_2 = _assistant_text_at_index(loaded["turns"], 7)
+    if ("verbosity=LONG" not in t_style_profile_2) or ("structure=STEPS" not in t_style_profile_2):
+        _fail("ERROR: expected style_profile to include verbosity=LONG and structure=STEPS")
+
+    # Learned rule used: after teach, the next parse should have matched_rule_id == learned_rule_id.
+    learned_rule_id = ""
+    for p in loaded["parse_events"]:
+        payload = p.get("payload") if isinstance(p, dict) else {}
+        if isinstance(payload, dict) and str(payload.get("intent_id") or "") == "INTENT_TEACH":
+            if bool(payload.get("teach_ok", False)):
+                learned_rule_id = str(payload.get("learned_rule_id") or "")
+    if not learned_rule_id:
+        _fail("ERROR: expected TEACH to succeed and yield learned_rule_id")
+    used_ok = False
+    for p in loaded["parse_events"]:
+        payload = p.get("payload") if isinstance(p, dict) else {}
+        if not isinstance(payload, dict):
+            continue
+        if str(payload.get("intent_id") or "") == "INTENT_SUMMARY" and str(payload.get("matched_rule_id") or "") == learned_rule_id:
+            used_ok = True
+            break
+    if not used_ok:
+        _fail("ERROR: expected learned rule to be used for statusvars -> SUMMARY")
+
+    # Binding ambiguity: at least one style event should pick a clarify template when we asked "isso".
+    clarify_used = any(isinstance(ev, dict) and "clarify" in str(ev.get("selected_template_id") or "") for ev in style_events)
+    if not clarify_used:
+        _fail("ERROR: expected at least one style selection using a clarify template_id")
+
+    # Variation: at least 2 different templates selected across STYLE_CHOSEN.
+    selected_templates = sorted(
+        set([str(ev.get("selected_template_id") or "") for ev in style_events if isinstance(ev, dict) and str(ev.get("event_kind") or "") == "STYLE_CHOSEN"])
+    )
+    if len([t for t in selected_templates if t]) < 2:
+        _fail(f"ERROR: expected >=2 selected_template_id values, got={selected_templates}")
+
+    # Negative tamper: mutate first style event_sig and ensure verifier fails with deterministic reason.
+    tampered_style_events = [dict(ev) for ev in style_events]
+    tampered_style_events[0]["event_sig"] = "0" * 64
+    ok_bad, reason_bad, _details_bad = verify_conversation_chain_v102(
+        turns=loaded["turns"],
+        states=loaded["states"],
+        parse_events=loaded["parse_events"],
+        trials=loaded["trials"],
+        learned_rule_events=loaded["learned_events"],
+        action_plans=loaded["plans"],
+        memory_events=loaded["memory_events"],
+        belief_events=loaded["belief_events"],
+        evidence_events=loaded["evidence_events"],
+        goal_events=loaded["goal_events"],
+        goal_snapshot=dict(loaded["goal_snapshot"]),
+        discourse_events=loaded["discourse_events"],
+        fragment_events=loaded["fragment_events"],
+        binding_events=loaded["binding_events"],
+        binding_snapshot=dict(loaded["binding_snapshot"]),
+        style_events=tampered_style_events,
+        template_snapshot=dict(loaded["template_snapshot"]),
+        tail_k=6,
+        repo_root=str(repo_root),
+    )
+    if ok_bad:
+        _fail("ERROR: expected verifier to fail on tampered style event_sig")
+    if str(reason_bad) != "style_event_sig_mismatch":
+        _fail(f"ERROR: expected reason=style_event_sig_mismatch got={reason_bad}")
+
+    core = {
+        "store_hash": str(res.get("store_hash") or ""),
+        "transcript_hash": str(res.get("transcript_hash") or ""),
+        "state_chain_hash": str(res.get("state_chain_hash") or ""),
+        "parse_chain_hash": str(res.get("parse_chain_hash") or ""),
+        "learned_chain_hash": str(res.get("learned_chain_hash") or ""),
+        "plan_chain_hash": str(res.get("plan_chain_hash") or ""),
+        "memory_chain_hash": str(res.get("memory_chain_hash") or ""),
+        "belief_chain_hash": str(res.get("belief_chain_hash") or ""),
+        "evidence_chain_hash": str(res.get("evidence_chain_hash") or ""),
+        "goal_chain_hash": str(res.get("goal_chain_hash") or ""),
+        "discourse_chain_hash": str(res.get("discourse_chain_hash") or ""),
+        "fragment_chain_hash": str(res.get("fragment_chain_hash") or ""),
+        "binding_chain_hash": str(res.get("binding_chain_hash") or ""),
+        "style_chain_hash": str(res.get("style_chain_hash") or ""),
+        "ledger_hash": str(res.get("ledger_hash") or ""),
+        "summary_sha256": str(res.get("summary_sha256") or ""),
+    }
+
+    return {
+        "out_dir": str(out_dir),
+        "core": dict(core),
+        "selected_templates": list(selected_templates),
+        "tamper": {"ok": True, "reason": str(reason_bad)},
+        "sha256": {
+            "style_events_jsonl": sha256_file(str(res["paths"]["style_events_jsonl"])),  # type: ignore[index]
+            "template_snapshot_json": sha256_file(str(res["paths"]["template_library_snapshot_v102_json"])),  # type: ignore[index]
+            "verify_chain_json": sha256_file(str(res["paths"]["verify_json"])),  # type: ignore[index]
+            "manifest_json": sha256_file(str(res["paths"]["manifest_json"])),  # type: ignore[index]
+        },
+    }
+
+
+def main() -> None:
+    ap = argparse.ArgumentParser()
+    ap.add_argument("--out_base", required=True)
+    ap.add_argument("--seed", type=int, default=0)
+    args = ap.parse_args()
+
+    out_base = str(args.out_base)
+    seed = int(args.seed)
+
+    out1 = out_base + "_try1"
+    out2 = out_base + "_try2"
+    ensure_absent(out1)
+    ensure_absent(out2)
+
+    r1 = smoke_try(out_dir=out1, seed=seed)
+    r2 = smoke_try(out_dir=out2, seed=seed)
+
+    determinism_ok = bool(r1.get("core") == r2.get("core"))
+    if not determinism_ok:
+        _fail(
+            "ERROR: determinism failed (try1 != try2): "
+            + json.dumps({"try1": r1.get("core"), "try2": r2.get("core")}, ensure_ascii=False, sort_keys=True)
+        )
+
+    out = {
+        "ok": True,
+        "determinism_ok": True,
+        "try1": dict(r1),
+        "try2": dict(r2),
+    }
+    print(json.dumps(out, ensure_ascii=False, indent=2, sort_keys=True))
+
+
+if __name__ == "__main__":
+    main()
+
--- /dev/null	2026-01-13 23:10:59
+++ scripts/verify_conversation_chain_v102.py	2026-01-13 22:59:19
@@ -0,0 +1,266 @@
+#!/usr/bin/env python3
+from __future__ import annotations
+
+import argparse
+import hashlib
+import json
+import os
+import sys
+from typing import Any, Dict, List
+
+sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
+
+from atos_core.conversation_v96 import verify_chained_jsonl_v96
+from atos_core.conversation_v102 import verify_conversation_chain_v102
+
+
+def sha256_file(path: str) -> str:
+    h = hashlib.sha256()
+    with open(path, "rb") as f:
+        while True:
+            b = f.read(1024 * 1024)
+            if not b:
+                break
+            h.update(b)
+    return h.hexdigest()
+
+
+def _read_json(path: str) -> Dict[str, Any]:
+    with open(path, "r", encoding="utf-8") as f:
+        obj = json.load(f)
+    return obj if isinstance(obj, dict) else {}
+
+
+def _read_jsonl(path: str) -> List[Dict[str, Any]]:
+    out: List[Dict[str, Any]] = []
+    if not os.path.exists(path):
+        return out
+    with open(path, "r", encoding="utf-8") as f:
+        for line in f:
+            line = line.strip()
+            if not line:
+                continue
+            out.append(json.loads(line))
+    return out
+
+
+def _extract_payloads(path: str) -> List[Dict[str, Any]]:
+    out: List[Dict[str, Any]] = []
+    for r in _read_jsonl(path):
+        if not isinstance(r, dict):
+            continue
+        payload = r.get("payload")
+        if isinstance(payload, dict):
+            out.append(dict(payload))
+    return out
+
+
+def _extract_parse_events(path: str) -> List[Dict[str, Any]]:
+    out: List[Dict[str, Any]] = []
+    for r in _read_jsonl(path):
+        if not isinstance(r, dict):
+            continue
+        payload = dict(r.get("payload") or {}) if isinstance(r.get("payload"), dict) else {}
+        out.append(
+            {
+                "turn_id": str(r.get("turn_id") or ""),
+                "turn_index": int(r.get("turn_index") or 0),
+                "payload": dict(payload),
+            }
+        )
+    return out
+
+
+def _extract_trials_for_verify(path: str) -> List[Dict[str, Any]]:
+    out: List[Dict[str, Any]] = []
+    for r in _read_jsonl(path):
+        if not isinstance(r, dict):
+            continue
+        out.append(
+            {
+                "objective_kind": str(r.get("objective_kind") or ""),
+                "user_turn_id": str(r.get("user_turn_id") or r.get("turn_id") or ""),
+            }
+        )
+    return out
+
+
+def _extract_learned_events(path: str) -> List[Dict[str, Any]]:
+    if not os.path.exists(path):
+        return []
+    out: List[Dict[str, Any]] = []
+    for r in _read_jsonl(path):
+        if not isinstance(r, dict):
+            continue
+        d = dict(r)
+        d.pop("prev_hash", None)
+        d.pop("entry_hash", None)
+        out.append(d)
+    return out
+
+
+def _strip_chain_fields(path: str) -> List[Dict[str, Any]]:
+    out: List[Dict[str, Any]] = []
+    for r in _read_jsonl(path):
+        if not isinstance(r, dict):
+            continue
+        d = dict(r)
+        d.pop("prev_hash", None)
+        d.pop("entry_hash", None)
+        out.append(d)
+    return out
+
+
+def main() -> None:
+    ap = argparse.ArgumentParser()
+    ap.add_argument("--run_dir", required=True)
+    args = ap.parse_args()
+
+    run_dir = str(args.run_dir)
+    repo_root = os.path.dirname(os.path.dirname(__file__))
+
+    turns_path = os.path.join(run_dir, "conversation_turns.jsonl")
+    parses_path = os.path.join(run_dir, "intent_parses.jsonl")
+    learned_path = os.path.join(run_dir, "learned_intent_rules.jsonl")
+    plans_path = os.path.join(run_dir, "action_plans.jsonl")
+    memory_path = os.path.join(run_dir, "memory_events.jsonl")
+    belief_path = os.path.join(run_dir, "belief_events.jsonl")
+    evidence_path = os.path.join(run_dir, "evidence_events.jsonl")
+    goal_path = os.path.join(run_dir, "goal_events.jsonl")
+    goal_snapshot_path = os.path.join(run_dir, "goal_ledger_snapshot.json")
+    discourse_path = os.path.join(run_dir, "discourse_events.jsonl")
+    fragment_events_path = os.path.join(run_dir, "fragment_events.jsonl")
+    fragment_snapshot_path = os.path.join(run_dir, "fragment_library_snapshot.json")
+    binding_events_path = os.path.join(run_dir, "binding_events.jsonl")
+    binding_snapshot_path = os.path.join(run_dir, "binding_snapshot.json")
+    style_path = os.path.join(run_dir, "style_events.jsonl")
+    template_snapshot_path = os.path.join(run_dir, "template_library_snapshot_v102.json")
+    states_path = os.path.join(run_dir, "conversation_states.jsonl")
+    trials_path = os.path.join(run_dir, "dialogue_trials.jsonl")
+    evals_path = os.path.join(run_dir, "objective_evals.jsonl")
+    transcript_path = os.path.join(run_dir, "transcript.jsonl")
+    system_spec_path = os.path.join(run_dir, "system_spec_snapshot.json")
+    verify_path = os.path.join(run_dir, "verify_chain_v102.json")
+    manifest_path = os.path.join(run_dir, "freeze_manifest_v102.json")
+
+    system_spec_ok = os.path.exists(system_spec_path)
+    system_spec_sha = sha256_file(system_spec_path) if system_spec_ok else ""
+
+    manifest_ok = os.path.exists(manifest_path)
+    manifest_sha = sha256_file(manifest_path) if manifest_ok else ""
+    manifest_sha_obj: Dict[str, Any] = {}
+    if manifest_ok:
+        try:
+            man = _read_json(manifest_path)
+            manifest_sha_obj = man.get("sha256") if isinstance(man.get("sha256"), dict) else {}
+        except Exception:
+            manifest_ok = False
+            manifest_sha_obj = {}
+
+    def _man_sha(key: str) -> str:
+        v = manifest_sha_obj.get(key)
+        return str(v or "")
+
+    chains = {
+        "turns_chain_ok": bool(verify_chained_jsonl_v96(turns_path)),
+        "parses_chain_ok": bool(verify_chained_jsonl_v96(parses_path)),
+        "learned_chain_ok": bool(verify_chained_jsonl_v96(learned_path)) if os.path.exists(learned_path) else True,
+        "plans_chain_ok": bool(verify_chained_jsonl_v96(plans_path)),
+        "memory_chain_ok": bool(verify_chained_jsonl_v96(memory_path)),
+        "belief_chain_ok": bool(verify_chained_jsonl_v96(belief_path)),
+        "evidence_chain_ok": bool(verify_chained_jsonl_v96(evidence_path)),
+        "goal_chain_ok": bool(verify_chained_jsonl_v96(goal_path)),
+        "discourse_chain_ok": bool(verify_chained_jsonl_v96(discourse_path)),
+        "fragment_chain_ok": bool(verify_chained_jsonl_v96(fragment_events_path)),
+        "binding_chain_ok": bool(verify_chained_jsonl_v96(binding_events_path)),
+        "style_chain_ok": bool(verify_chained_jsonl_v96(style_path)),
+        "states_chain_ok": bool(verify_chained_jsonl_v96(states_path)) if os.path.exists(states_path) else True,
+        "trials_chain_ok": bool(verify_chained_jsonl_v96(trials_path)),
+        "evals_chain_ok": bool(verify_chained_jsonl_v96(evals_path)),
+        "transcript_chain_ok": bool(verify_chained_jsonl_v96(transcript_path)),
+        "goal_snapshot_exists": bool(os.path.exists(goal_snapshot_path)),
+        "binding_snapshot_exists": bool(os.path.exists(binding_snapshot_path)),
+        "system_spec_exists": bool(system_spec_ok),
+        "fragment_snapshot_exists": bool(os.path.exists(fragment_snapshot_path)),
+        "template_snapshot_exists": bool(os.path.exists(template_snapshot_path)),
+        "manifest_exists": bool(manifest_ok),
+        "verify_json_exists": bool(os.path.exists(verify_path)),
+        "manifest_system_spec_sha_match": bool(
+            system_spec_ok and manifest_ok and system_spec_sha and system_spec_sha == _man_sha("system_spec_snapshot_json")
+        ),
+        "manifest_style_sha_match": bool(manifest_ok and os.path.exists(style_path) and sha256_file(style_path) == _man_sha("style_events_jsonl")),
+        "manifest_template_snapshot_sha_match": bool(
+            manifest_ok and os.path.exists(template_snapshot_path) and sha256_file(template_snapshot_path) == _man_sha("template_library_snapshot_v102_json")
+        ),
+        "manifest_verify_sha_match": bool(
+            manifest_ok and os.path.exists(verify_path) and sha256_file(verify_path) == _man_sha("verify_chain_v102_json")
+        ),
+    }
+
+    turns = _extract_payloads(turns_path)
+    states = _extract_payloads(states_path) if states_path and os.path.exists(states_path) else []
+    parse_events = _extract_parse_events(parses_path)
+    trials = _extract_trials_for_verify(trials_path)
+    learned_events = _extract_learned_events(learned_path)
+    plans = _strip_chain_fields(plans_path)
+    memory_events = _strip_chain_fields(memory_path)
+    belief_events = _strip_chain_fields(belief_path)
+    evidence_events = _strip_chain_fields(evidence_path)
+    goal_events = _extract_payloads(goal_path)
+    goal_snapshot = _read_json(goal_snapshot_path)
+    discourse_events = _extract_payloads(discourse_path)
+    fragment_events = _extract_payloads(fragment_events_path)
+    binding_events = _strip_chain_fields(binding_events_path)
+    binding_snapshot = _read_json(binding_snapshot_path)
+    style_events = _extract_payloads(style_path)
+    template_snapshot = _read_json(template_snapshot_path)
+
+    ok_inv, reason, details = verify_conversation_chain_v102(
+        turns=turns,
+        states=states,
+        parse_events=parse_events,
+        trials=trials,
+        learned_rule_events=learned_events,
+        action_plans=plans,
+        memory_events=memory_events,
+        belief_events=belief_events,
+        evidence_events=evidence_events,
+        goal_events=goal_events,
+        goal_snapshot=dict(goal_snapshot),
+        discourse_events=discourse_events,
+        fragment_events=fragment_events,
+        binding_events=binding_events,
+        binding_snapshot=dict(binding_snapshot),
+        style_events=style_events,
+        template_snapshot=dict(template_snapshot),
+        tail_k=6,
+        repo_root=str(repo_root),
+    )
+
+    out = {
+        "ok": bool(all(chains.values())) and bool(ok_inv),
+        "chains": dict(chains),
+        "invariants": {"ok": bool(ok_inv), "reason": str(reason), "details": dict(details)},
+        "files": {"system_spec_sha256": str(system_spec_sha), "manifest_sha256": str(manifest_sha)},
+        "counts": {
+            "turns_total": int(len(turns)),
+            "states_total": int(len(states)),
+            "parses_total": int(len(parse_events)),
+            "learned_total": int(len(learned_events)),
+            "plans_total": int(len(plans)),
+            "memory_events_total": int(len(memory_events)),
+            "belief_events_total": int(len(belief_events)),
+            "evidence_events_total": int(len(evidence_events)),
+            "goal_events_total": int(len(goal_events)),
+            "discourse_events_total": int(len(discourse_events)),
+            "fragment_events_total": int(len(fragment_events)),
+            "binding_events_total": int(len(binding_events)),
+            "style_events_total": int(len(style_events)),
+        },
+    }
+    print(json.dumps(out, ensure_ascii=False, indent=2, sort_keys=True))
+
+
+if __name__ == "__main__":
+    main()
+
