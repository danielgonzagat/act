*** Begin Patch
*** Update File: act/atos_core/engine.py
@@
         for i in range(int(max_new_tokens)):
-            trace_context_keys.append(ctx_key(context))
-            penalties = penalty_view(out_tokens + gen_tokens, gen_tokens)
-            emit_trace: Dict[str, Any] = {}
-            candidates = self._emit_candidates(context=context, penalties=penalties, trace=emit_trace)
-
-            exec_pred = emit_trace.get("executed_predictor_ids") or []
-            if isinstance(exec_pred, list):
-                trace_executed_predictor_ids.append([str(x) for x in exec_pred if isinstance(x, str)])
-            else:
-                trace_executed_predictor_ids.append([])
-
-            # Apply rewrite-rule penalties via AtoLang.
-            def _top1_token(cands: Dict[str, Candidate]) -> Optional[str]:
-                if not cands:
-                    return None
-                return min(cands.values(), key=lambda c: (-c.score, c.token, c.source_act)).token
-
-            rr_hits: List[str] = []
-            top_tok = _top1_token(candidates)
-            for rr in self._rewrite_rules:
-                before_tok = top_tok
-                before_score = candidates.get(before_tok).score if before_tok in candidates else None
-                st = self.vm.run(
-                    rr,
-                    context=context,
-                    tables=self._tables,
-                    vocab=self.vocab(),
-                    initial_candidates=candidates,
-                    penalties=penalties,
-                    mode="emit_only",
-                )
-                candidates = st.candidates
-                after_tok = _top1_token(candidates)
-                after_score = candidates.get(before_tok).score if before_tok in candidates else None
-                if after_tok is None:
-                    after_tok = before_tok
-                if (
-                    before_tok is not None
-                    and after_tok is not None
-                    and (
-                        after_tok != before_tok
-                        or (before_score is None)
-                        or (after_score is None)
-                        or abs(float(after_score) - float(before_score)) > 1e-12
-                    )
-                ):
-                    rr_hits.append(str(rr.id))
-                top_tok = after_tok
-            trace_rewrite_rule_hit_ids.append(rr_hits)
-            trace_rewrite_rules_changed_count.append(int(len(rr_hits)))
+            ck = ctx_key(context)
+            trace_context_keys.append(ck)
+            penalties = penalty_view(out_tokens + gen_tokens, gen_tokens)
+
+            router_live_enabled = bool(self.config.router_live_enabled)
+            router_debug = bool(self.config.router_live_debug_compare)
+
+            router_used = False
+            router_fallback = False
+            router_fallback_reason = ""
+            allowed_predictor_ids: List[str] = []
+            gated_predictors: Optional[List[Act]] = None
+
+            if router_live_enabled:
+                table = self._macro_router_table
+                if table is None or not isinstance(table, dict):
+                    router_fallback = True
+                    router_fallback_reason = "router_missing"
+                else:
+                    ctx_sig = f"{mode_state}{SEP}{ck}"
+                    entry = table.get(ctx_sig)
+                    if isinstance(entry, dict):
+                        preds = entry.get("predictors") or []
+                        if isinstance(preds, list):
+                            allowed_predictor_ids = [
+                                str(x) for x in preds if isinstance(x, str) and x
+                            ]
+                    if allowed_predictor_ids:
+                        present = [
+                            pid for pid in allowed_predictor_ids if pid in self._predictor_by_id
+                        ]
+                        if present:
+                            present.sort(key=lambda pid: self._predictor_order.get(pid, 0))
+                            gated_predictors = [self._predictor_by_id[pid] for pid in present]
+                        else:
+                            router_fallback = True
+                            router_fallback_reason = "allowed_missing"
+                    else:
+                        router_fallback = True
+                        router_fallback_reason = "missing_ctx"
+
+            emit_gate: Optional[Dict[str, Any]] = None
+            cand_gate: Optional[Dict[str, Candidate]] = None
+            if gated_predictors is not None:
+                emit_gate = {}
+                cand_gate = self._emit_candidates(
+                    context=context, penalties=penalties, predictors=gated_predictors, trace=emit_gate
+                )
+                if int(emit_gate.get("predictor_emitted", 0) or 0) <= 0:
+                    router_fallback = True
+                    router_fallback_reason = "gate_empty_emit"
+                    emit_gate = None
+                    cand_gate = None
+
+            emit_base: Optional[Dict[str, Any]] = None
+            cand_base: Optional[Dict[str, Candidate]] = None
+            if router_debug or (router_live_enabled and cand_gate is None):
+                emit_base = {}
+                cand_base = self._emit_candidates(context=context, penalties=penalties, trace=emit_base)
+
+            mismatch = False
+            baseline_tok = ""
+            gate_tok = ""
+            if router_debug and cand_gate is not None and cand_base is not None:
+                base_after = _apply_rewrite_rules(
+                    cand_base, record_trace=False, context=context, penalties=penalties
+                )
+                gate_after = _apply_rewrite_rules(
+                    cand_gate, record_trace=False, context=context, penalties=penalties
+                )
+                b_nxt = _select_next(base_after, context=context, penalties=penalties)
+                g_nxt = _select_next(gate_after, context=context, penalties=penalties)
+                baseline_tok = str(b_nxt or "")
+                gate_tok = str(g_nxt or "")
+                mismatch = bool(b_nxt != g_nxt)
+                if mismatch:
+                    router_fallback = True
+                    router_fallback_reason = "mismatch"
+                    emit_gate = None
+                    cand_gate = None
+
+            emit_trace: Dict[str, Any] = {}
+            candidates: Dict[str, Candidate] = {}
+            if cand_gate is not None and emit_gate is not None and not router_fallback:
+                router_used = True
+                emit_trace = emit_gate
+                candidates = cand_gate
+            else:
+                router_used = False
+                if router_live_enabled and not router_fallback:
+                    router_fallback = True
+                    router_fallback_reason = "no_gate"
+                if cand_base is None or emit_base is None:
+                    emit_base = {}
+                    cand_base = self._emit_candidates(
+                        context=context, penalties=penalties, trace=emit_base
+                    )
+                emit_trace = emit_base
+                candidates = cand_base
+
+            exec_pred = emit_trace.get("executed_predictor_ids") or []
+            if isinstance(exec_pred, list):
+                trace_executed_predictor_ids.append([str(x) for x in exec_pred if isinstance(x, str)])
+            else:
+                trace_executed_predictor_ids.append([])
+
+            candidates = _apply_rewrite_rules(
+                candidates, record_trace=True, context=context, penalties=penalties
+            )
 
             # EOS guardrail
             if i < self.config.min_new_tokens_before_eos and "<EOS>" in candidates:
                 candidates["<EOS>"].score -= 1e6
@@
             trace_predictor_emitted.append(int(emit_trace.get("predictor_emitted", 0) or 0))
             trace_candidates_pre.append(int(emit_trace.get("candidates_pre_rewrite", len(candidates)) or 0))
             trace_candidates_post.append(int(len(candidates)))
 
-            nxt: Optional[str] = None
-            if mode == "greedy" and self._selector is not None:
-                st = self.vm.run(
-                    self._selector,
-                    context=context,
-                    tables=self._tables,
-                    vocab=self.vocab(),
-                    initial_candidates=candidates,
-                    penalties=penalties,
-                    mode="select",
-                )
-                nxt = st.selected
-
-            if nxt is None:
-                ordered = sorted(
-                    candidates.values(), key=lambda c: (-c.score, c.token, c.source_act)
-                )
-                if mode == "greedy":
-                    nxt = ordered[0].token
-                else:
-                    mx = ordered[0].score
-                    exps = [math.exp(min(60.0, c.score - mx)) for c in ordered]
-                    s = sum(exps)
-                    r = self.rng.random() * s
-                    acc = 0.0
-                    nxt = ordered[-1].token
-                    for c, e in zip(ordered, exps):
-                        acc += e
-                        if acc >= r:
-                            nxt = c.token
-                            break
+            trace_router_live_used.append(1 if router_used else 0)
+            trace_router_live_fallback.append(1 if router_fallback else 0)
+            trace_router_live_fallback_reason.append(str(router_fallback_reason))
+            trace_router_live_allowed_predictor_ids.append(list(allowed_predictor_ids))
+            trace_router_live_predictors_evaluated.append(int(emit_trace.get("predictor_matched", 0) or 0))
+            trace_baseline_predictors_evaluated.append(
+                int((emit_base or {}).get("predictor_matched", 0) or 0) if router_debug else 0
+            )
+            trace_router_live_mismatch.append(1 if mismatch else 0)
+            trace_router_live_debug_baseline_token.append(baseline_tok)
+            trace_router_live_debug_gate_token.append(gate_tok)
+
+            nxt = _select_next(candidates, context=context, penalties=penalties)
 
             if nxt == "<EOS>":
                 break
*** End Patch