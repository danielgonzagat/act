--- /dev/null	2026-01-12 23:24:59
+++ atos_core/logic_v86.py	2026-01-12 23:15:57
@@ -0,0 +1,274 @@
+from __future__ import annotations
+
+from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple
+
+from .act import canonical_json_dumps, sha256_hex
+
+
+BOOL_DOMAIN_VALUES_V86: List[str] = ["0", "1"]
+
+
+def _stable_hash(obj: Any) -> str:
+    return sha256_hex(canonical_json_dumps(obj).encode("utf-8"))
+
+
+def logic_hash(expr_canon: Dict[str, Any]) -> str:
+    return _stable_hash(expr_canon)
+
+
+def _require_dict(expr: Any) -> Dict[str, Any]:
+    if not isinstance(expr, dict):
+        raise ValueError("expr_not_dict")
+    return expr
+
+
+def _require_str(x: Any, *, field: str) -> str:
+    s = str(x or "")
+    if not s:
+        raise ValueError(f"missing_{field}")
+    return s
+
+
+def _canon_comm_args(args: Sequence[Dict[str, Any]]) -> List[Dict[str, Any]]:
+    # Sort by hash(expr_canon) for deterministic commutative canonicalization.
+    return sorted(list(args), key=lambda a: str(logic_hash(a)))
+
+
+def logic_canon(expr: Any) -> Dict[str, Any]:
+    """
+    Canonicalize a propositional logic AST.
+
+    Supported nodes (dict form):
+      - {"op":"var","name":<str>}
+      - {"op":"not","x":<expr>}
+      - {"op":"and","args":[<expr>,...]}
+      - {"op":"or","args":[<expr>,...]}
+      - {"op":"xor","args":[<expr>,...]}
+      - {"op":"implies","a":<expr>,"b":<expr>}
+      - {"op":"iff","args":[<expr>,<expr>]}   # commutative (binary)
+    """
+    d = _require_dict(expr)
+    op = str(d.get("op") or "")
+    if not op:
+        raise ValueError("missing_op")
+
+    if op == "var":
+        name = _require_str(d.get("name"), field="var_name")
+        return {"op": "var", "name": str(name)}
+
+    if op == "not":
+        x = logic_canon(d.get("x"))
+        return {"op": "not", "x": x}
+
+    if op in {"and", "or", "xor"}:
+        args = d.get("args")
+        if not isinstance(args, list):
+            raise ValueError("bad_args")
+        if len(args) < 2:
+            raise ValueError("bad_args_len")
+        args_c = [logic_canon(a) for a in args]
+        return {"op": str(op), "args": _canon_comm_args(args_c)}
+
+    if op == "implies":
+        a = logic_canon(d.get("a"))
+        b = logic_canon(d.get("b"))
+        return {"op": "implies", "a": a, "b": b}
+
+    if op == "iff":
+        args = d.get("args")
+        if args is None:
+            # Allow legacy {"a":..., "b":...} input.
+            args = [d.get("a"), d.get("b")]
+        if not isinstance(args, list) or len(args) != 2:
+            raise ValueError("bad_iff_args")
+        a = logic_canon(args[0])
+        b = logic_canon(args[1])
+        return {"op": "iff", "args": _canon_comm_args([a, b])}
+
+    raise ValueError(f"unknown_op:{op}")
+
+
+def _parse_domain01(v: Any) -> bool:
+    s = str(v or "")
+    if s == "0":
+        return False
+    if s == "1":
+        return True
+    raise ValueError(f"bad_domain_value:{s}")
+
+
+def _bool_to_domain01(v: bool) -> str:
+    return "1" if bool(v) else "0"
+
+
+def logic_eval(expr_canon: Dict[str, Any], assignment: Dict[str, Any]) -> bool:
+    """
+    Evaluate a canonicalized expr under an assignment where each var value is "0" or "1".
+    """
+    d = _require_dict(expr_canon)
+    op = str(d.get("op") or "")
+    if op == "var":
+        name = _require_str(d.get("name"), field="var_name")
+        if name not in assignment:
+            raise ValueError(f"missing_assignment:{name}")
+        return _parse_domain01(assignment.get(name))
+    if op == "not":
+        return not bool(logic_eval(d["x"], assignment))
+    if op == "and":
+        args = d.get("args")
+        if not isinstance(args, list):
+            raise ValueError("bad_args")
+        return all(bool(logic_eval(a, assignment)) for a in args)
+    if op == "or":
+        args = d.get("args")
+        if not isinstance(args, list):
+            raise ValueError("bad_args")
+        return any(bool(logic_eval(a, assignment)) for a in args)
+    if op == "xor":
+        args = d.get("args")
+        if not isinstance(args, list):
+            raise ValueError("bad_args")
+        acc = 0
+        for a in args:
+            acc ^= 1 if bool(logic_eval(a, assignment)) else 0
+        return bool(acc)
+    if op == "implies":
+        a = bool(logic_eval(d["a"], assignment))
+        b = bool(logic_eval(d["b"], assignment))
+        return (not a) or b
+    if op == "iff":
+        args = d.get("args")
+        if not isinstance(args, list) or len(args) != 2:
+            raise ValueError("bad_iff_args")
+        a = bool(logic_eval(args[0], assignment))
+        b = bool(logic_eval(args[1], assignment))
+        return bool(a == b)
+    raise ValueError(f"unknown_op:{op}")
+
+
+def _norm_domain_values(domain_values: Sequence[str]) -> List[str]:
+    vals = [str(v) for v in domain_values if str(v)]
+    # Deterministic: unique + sort.
+    vals = sorted(set(vals), key=str)
+    if vals != ["0", "1"]:
+        raise ValueError("bad_domain_values")
+    return list(vals)
+
+
+def enumerate_assignments(*, vars: Sequence[str], domain_values: Sequence[str]) -> List[Dict[str, str]]:
+    """
+    Deterministic truth-table assignment order:
+      - vars sorted lexicographically
+      - assignments in binary order (first var is most-significant)
+    """
+    vs = sorted(set(str(v) for v in vars if str(v)), key=str)
+    dv = _norm_domain_values(domain_values)
+    assignments: List[Dict[str, str]] = [{}]
+    for v in vs:
+        nxt: List[Dict[str, str]] = []
+        for a in assignments:
+            for d in dv:
+                a2 = dict(a)
+                a2[str(v)] = str(d)
+                nxt.append(a2)
+        assignments = nxt
+    return list(assignments)
+
+
+def render_output01(*, out01: str, render: Dict[str, Any]) -> str:
+    rk = str(render.get("kind") or "")
+    if rk == "raw01":
+        return str(out01)
+    if rk == "prefix01":
+        prefix = str(render.get("prefix") or "")
+        return f"{prefix}{out01}"
+    raise ValueError("unknown_render_kind")
+
+
+def truth_table(
+    *,
+    vars: Sequence[str],
+    domain_values: Sequence[str],
+    expr: Dict[str, Any],
+    render: Dict[str, Any],
+) -> List[Dict[str, Any]]:
+    expr_c = logic_canon(expr)
+    vs = sorted(set(str(v) for v in vars if str(v)), key=str)
+    dv = _norm_domain_values(domain_values)
+    tt: List[Dict[str, Any]] = []
+    for a in enumerate_assignments(vars=vs, domain_values=dv):
+        out_b = logic_eval(expr_c, a)
+        out01 = _bool_to_domain01(out_b)
+        out_text = render_output01(out01=out01, render=dict(render))
+        tt.append({"inputs": {str(k): str(a.get(k)) for k in vs}, "out": str(out_text)})
+    return tt
+
+
+def truth_table_sha256(*, tt: Sequence[Dict[str, Any]]) -> str:
+    return sha256_hex(canonical_json_dumps(list(tt)).encode("utf-8"))
+
+
+def ensure_bool_primitives_registered() -> None:
+    """
+    Deterministically extend PRIMITIVE_OPS with bool operations over domain strings "0"/"1".
+    This is additive and idempotent.
+    """
+    from .concepts import PRIMITIVE_OPS, PrimitiveOpSpec
+
+    def _to_bit(x: Any) -> int:
+        s = str(x or "").strip()
+        if s == "0":
+            return 0
+        if s == "1":
+            return 1
+        return 0
+
+    def _bit_to_str(b: int) -> str:
+        return "1" if int(b) != 0 else "0"
+
+    def _bool_not01(x: Any) -> str:
+        return _bit_to_str(1 - _to_bit(x))
+
+    def _bool_and01(a: Any, b: Any) -> str:
+        return _bit_to_str(_to_bit(a) & _to_bit(b))
+
+    def _bool_or01(a: Any, b: Any) -> str:
+        return _bit_to_str(_to_bit(a) | _to_bit(b))
+
+    def _bool_xor01(a: Any, b: Any) -> str:
+        return _bit_to_str(_to_bit(a) ^ _to_bit(b))
+
+    def _bool_implies01(a: Any, b: Any) -> str:
+        aa = _to_bit(a)
+        bb = _to_bit(b)
+        return _bit_to_str((1 - aa) | bb)
+
+    def _bool_iff01(a: Any, b: Any) -> str:
+        aa = _to_bit(a)
+        bb = _to_bit(b)
+        return _bit_to_str(1 if aa == bb else 0)
+
+    new_ops: Dict[str, Tuple[PrimitiveOpSpec, Any]] = {
+        "bool_not01": (PrimitiveOpSpec("bool_not01", 1, ("str",), "str"), _bool_not01),
+        "bool_and01": (PrimitiveOpSpec("bool_and01", 2, ("str", "str"), "str"), _bool_and01),
+        "bool_or01": (PrimitiveOpSpec("bool_or01", 2, ("str", "str"), "str"), _bool_or01),
+        "bool_xor01": (PrimitiveOpSpec("bool_xor01", 2, ("str", "str"), "str"), _bool_xor01),
+        "bool_implies01": (PrimitiveOpSpec("bool_implies01", 2, ("str", "str"), "str"), _bool_implies01),
+        "bool_iff01": (PrimitiveOpSpec("bool_iff01", 2, ("str", "str"), "str"), _bool_iff01),
+    }
+
+    for op_id in sorted(new_ops.keys(), key=str):
+        spec, fn = new_ops[op_id]
+        existing = PRIMITIVE_OPS.get(op_id)
+        if existing is None:
+            PRIMITIVE_OPS[op_id] = (spec, fn)
+            continue
+        ex_spec = existing[0]
+        if (
+            str(getattr(ex_spec, "op_id", "")) != str(spec.op_id)
+            or int(getattr(ex_spec, "arity", 0)) != int(spec.arity)
+            or tuple(getattr(ex_spec, "input_types", ())) != tuple(spec.input_types)
+            or str(getattr(ex_spec, "output_type", "")) != str(spec.output_type)
+        ):
+            raise ValueError(f"primitive_conflict:{op_id}")
+
--- /dev/null	2026-01-12 23:24:59
+++ atos_core/pcc_v86.py	2026-01-12 23:16:41
@@ -0,0 +1,224 @@
+from __future__ import annotations
+
+from typing import Any, Dict, List, Optional, Sequence, Tuple
+
+from .act import Act, canonical_json_dumps, sha256_hex
+from .logic_v86 import enumerate_assignments, ensure_bool_primitives_registered, logic_canon, logic_eval, render_output01, truth_table, truth_table_sha256
+from .pcc_v74 import certificate_sig_v2
+from .pcc_v85 import build_certificate_v85, verify_pcc_v85
+from .store import ActStore
+
+
+def _stable_hash(obj: Any) -> str:
+    return sha256_hex(canonical_json_dumps(obj).encode("utf-8"))
+
+
+def _norm_str_list(val: Any) -> List[str]:
+    if not isinstance(val, list):
+        return []
+    out: List[str] = []
+    seen = set()
+    for x in val:
+        s = str(x or "")
+        if not s:
+            continue
+        if s in seen:
+            continue
+        seen.add(s)
+        out.append(s)
+    out.sort(key=str)
+    return out
+
+
+def _is_logic_eligible_act(act: Act) -> bool:
+    mk = act.match if isinstance(getattr(act, "match", None), dict) else {}
+    gks = mk.get("goal_kinds")
+    gks2 = gks if isinstance(gks, list) else []
+    for gk in gks2:
+        if str(gk or "").startswith("v86_logic_"):
+            return True
+    return False
+
+
+def _render_to_out01(out: bool) -> str:
+    return "1" if bool(out) else "0"
+
+
+def _norm_render(render: Dict[str, Any]) -> Dict[str, Any]:
+    rk = str(render.get("kind") or "")
+    if rk == "raw01":
+        return {"kind": "raw01"}
+    if rk == "prefix01":
+        return {"kind": "prefix01", "prefix": str(render.get("prefix") or "")}
+    raise ValueError("bad_render")
+
+
+def _norm_domain_values(domain_values: Any) -> List[str]:
+    if not isinstance(domain_values, list):
+        raise ValueError("bad_domain_values")
+    vals = [str(v) for v in domain_values if str(v)]
+    vals = sorted(set(vals), key=str)
+    if vals != ["0", "1"]:
+        raise ValueError("bad_domain_values")
+    return list(vals)
+
+
+def build_certificate_v86(
+    *,
+    candidate_act: Act,
+    store_base: ActStore,
+    mined_from: Dict[str, Any],
+    vector_specs: Sequence[Dict[str, Any]],
+    seed: int = 0,
+    logic_spec: Optional[Dict[str, Any]] = None,
+) -> Dict[str, Any]:
+    """
+    V86: PCC wrapper that extends V85 with an optional finite-domain logic proof block.
+
+    logic_spec (optional) shape:
+      {
+        "vars": [...],
+        "domain_values": ["0","1"],
+        "expr": <logic AST>,
+        "render": {"kind":"raw01"} | {"kind":"prefix01","prefix":"BOOL="},
+      }
+    """
+    ensure_bool_primitives_registered()
+
+    cert = build_certificate_v85(
+        candidate_act=candidate_act,
+        store_base=store_base,
+        mined_from=mined_from,
+        vector_specs=vector_specs,
+        seed=int(seed),
+    )
+
+    if logic_spec is None:
+        return cert
+
+    vars_raw = logic_spec.get("vars") if isinstance(logic_spec, dict) else None
+    domain_raw = logic_spec.get("domain_values") if isinstance(logic_spec, dict) else None
+    expr_raw = logic_spec.get("expr") if isinstance(logic_spec, dict) else None
+    render_raw = logic_spec.get("render") if isinstance(logic_spec, dict) else None
+
+    vars_norm = _norm_str_list(vars_raw)
+    if not vars_norm:
+        raise ValueError("bad_logic_vars")
+    domain_values = _norm_domain_values(domain_raw)
+    expr_canon = logic_canon(expr_raw)
+    render = _norm_render(render_raw if isinstance(render_raw, dict) else {})
+
+    tt = truth_table(vars=vars_norm, domain_values=domain_values, expr=expr_canon, render=render)
+    tt_sha = truth_table_sha256(tt=tt)
+
+    body = {
+        "schema_version": 1,
+        "vars": list(vars_norm),
+        "domain_values": list(domain_values),
+        "expr": dict(expr_canon),
+        "render": dict(render),
+        "truth_table_sha256": str(tt_sha),
+    }
+    cert["logic_binding"] = {**dict(body), "binding_sig": _stable_hash(body)}
+    cert["certificate_sig"] = certificate_sig_v2(cert)
+    return cert
+
+
+def verify_pcc_v86(
+    *,
+    candidate_act: Act,
+    certificate: Dict[str, Any],
+    store_base: ActStore,
+    seed: int = 0,
+) -> Tuple[bool, str, Dict[str, Any]]:
+    """
+    V86: verify V85 + (optional/required) finite-domain logic proof.
+    """
+    ensure_bool_primitives_registered()
+
+    ok, reason, details = verify_pcc_v85(candidate_act=candidate_act, certificate=certificate, store_base=store_base, seed=int(seed))
+    if not bool(ok):
+        return False, str(reason), dict(details)
+
+    lb = certificate.get("logic_binding") if isinstance(certificate.get("logic_binding"), dict) else None
+    require_logic = bool(isinstance(lb, dict)) or bool(_is_logic_eligible_act(candidate_act))
+    if require_logic and not isinstance(lb, dict):
+        return False, "missing_logic_binding", {}
+    if not require_logic:
+        return True, "ok", dict(details)
+
+    # logic_binding integrity.
+    if int(lb.get("schema_version", 0) or 0) != 1:
+        return False, "bad_logic_schema_version", {}
+
+    want_sig = str(lb.get("binding_sig") or "")
+    body = dict(lb)
+    body.pop("binding_sig", None)
+    got_sig = _stable_hash(body)
+    if want_sig != got_sig:
+        return False, "logic_binding_sig_mismatch", {"want": want_sig, "got": got_sig}
+
+    vars_norm = _norm_str_list(body.get("vars"))
+    if not vars_norm:
+        return False, "bad_logic_vars", {}
+    domain_values = _norm_domain_values(body.get("domain_values"))
+    expr_canon = logic_canon(body.get("expr"))
+    render = _norm_render(body.get("render") if isinstance(body.get("render"), dict) else {})
+    want_tt_sha = str(body.get("truth_table_sha256") or "")
+    if not want_tt_sha:
+        return False, "missing_truth_table_sha256", {}
+    got_tt = truth_table(vars=vars_norm, domain_values=domain_values, expr=expr_canon, render=render)
+    got_tt_sha = truth_table_sha256(tt=got_tt)
+    if want_tt_sha != got_tt_sha:
+        return False, "logic_truth_table_hash_mismatch", {"want": want_tt_sha, "got": got_tt_sha}
+
+    # Exhaustive coverage over assignments: require >=1 vector per assignment.
+    tvs = certificate.get("test_vectors") if isinstance(certificate.get("test_vectors"), list) else []
+    tvs2 = [tv for tv in tvs if isinstance(tv, dict)]
+
+    expected_by_key: Dict[str, str] = {}
+    for a in enumerate_assignments(vars=vars_norm, domain_values=domain_values):
+        out_b = logic_eval(expr_canon, a)
+        out01 = _render_to_out01(out_b)
+        exp = render_output01(out01=out01, render=dict(render))
+        key = _stable_hash({"inputs": {str(k): str(a.get(k)) for k in vars_norm}})
+        expected_by_key[str(key)] = str(exp)
+
+    present: Dict[str, Dict[str, Any]] = {}
+    counterexample = None
+
+    for tv in tvs2:
+        inps = tv.get("inputs") if isinstance(tv.get("inputs"), dict) else {}
+        sub = {str(k): inps.get(str(k)) for k in vars_norm}
+        if any(str(sub.get(k) or "") == "" for k in vars_norm):
+            continue
+        key = _stable_hash({"inputs": {str(k): str(sub.get(k)) for k in vars_norm}})
+        present[str(key)] = {"inputs": {str(k): str(sub.get(k)) for k in vars_norm}}
+        want_exp = expected_by_key.get(str(key))
+        got_exp = str(tv.get("expected") if tv.get("expected") is not None else "")
+        if want_exp is not None and got_exp != str(want_exp) and counterexample is None:
+            counterexample = {"inputs": {str(k): str(sub.get(k)) for k in vars_norm}, "want": str(want_exp), "got": str(got_exp)}
+
+    missing_keys = [k for k in sorted(expected_by_key.keys(), key=str) if k not in present]
+    if missing_keys:
+        missing = [present.get(k) for k in missing_keys if k in present]
+        # present[k] doesn't exist for missing; build deterministically from expected_by_key by enumerating.
+        miss_inputs: List[Dict[str, Any]] = []
+        for a in enumerate_assignments(vars=vars_norm, domain_values=domain_values):
+            key = _stable_hash({"inputs": {str(k): str(a.get(k)) for k in vars_norm}})
+            if key in set(missing_keys):
+                miss_inputs.append({"inputs": {str(k): str(a.get(k)) for k in vars_norm}})
+        return False, "logic_vector_coverage_incomplete", {"missing": miss_inputs, "missing_total": int(len(miss_inputs))}
+
+    if counterexample is not None:
+        return False, "logic_expected_mismatch", dict(counterexample)
+
+    out_details = dict(details) if isinstance(details, dict) else {}
+    out_details["logic_bound"] = True
+    out_details["logic_truth_table_sha256"] = str(want_tt_sha)
+    out_details["logic_vars"] = list(vars_norm)
+    out_details["logic_domain_values"] = list(domain_values)
+    out_details["logic_render"] = dict(render)
+    out_details["logic_vectors_total"] = int(len(tvs2))
+    return True, "ok", out_details
+
--- /dev/null	2026-01-12 23:24:59
+++ atos_core/agent_loop_goals_v86.py	2026-01-12 23:20:08
@@ -0,0 +1,1065 @@
+from __future__ import annotations
+
+import datetime as _dt
+import hashlib
+import json
+import os
+from typing import Any, Dict, List, Optional, Sequence, Tuple
+
+from .act import canonical_json_dumps, deterministic_iso, sha256_hex
+from .agent_loop_v80 import run_goal_spec_v80
+from .goal_act_v75 import goal_sig_v75, goal_v75_is_satisfied, goal_v75_update_from_run, list_goal_acts_v75
+from .goal_spec_v72 import GoalSpecV72
+from .logic_v86 import ensure_bool_primitives_registered, logic_canon, logic_eval, render_output01
+from .mine_promote_v74 import (
+    extract_rep_steps,
+    materialize_composed_act_v74,
+    mine_candidates_v74,
+    mutate_bindings_plus1_numeric,
+)
+from .pcc_v86 import build_certificate_v86, verify_pcc_v86
+from .store import ActStore
+from .trace_v73 import TraceV73, trace_from_agent_loop_v72
+
+
+def _fail(msg: str) -> None:
+    raise ValueError(msg)
+
+
+def ensure_absent(path: str) -> None:
+    if os.path.exists(path):
+        _fail(f"path_exists:{path}")
+
+
+def sha256_file(path: str) -> str:
+    h = hashlib.sha256()
+    with open(path, "rb") as f:
+        while True:
+            b = f.read(1024 * 1024)
+            if not b:
+                break
+            h.update(b)
+    return h.hexdigest()
+
+
+def _sha256_canon(obj: Any) -> str:
+    return sha256_hex(canonical_json_dumps(obj).encode("utf-8"))
+
+
+_EPOCH = _dt.datetime(1970, 1, 1, tzinfo=_dt.timezone.utc)
+
+
+def goal_created_step_v75(goal_act) -> int:
+    """
+    Deterministic created_step derived from goal_act.created_at (deterministic_iso).
+    """
+    try:
+        ts = str(getattr(goal_act, "created_at", "") or "")
+        if not ts:
+            return 0
+        dt = _dt.datetime.fromisoformat(ts)
+        if dt.tzinfo is None:
+            dt = dt.replace(tzinfo=_dt.timezone.utc)
+        return int((dt - _EPOCH).total_seconds())
+    except Exception:
+        return 0
+
+
+def run_dir_sha256_v86(*, run_dir: str) -> str:
+    mg_dir = os.path.join(str(run_dir), "mind_graph")
+    nodes_path = os.path.join(mg_dir, "mind_nodes.jsonl")
+    edges_path = os.path.join(mg_dir, "mind_edges.jsonl")
+    nodes_sha = sha256_file(nodes_path)
+    edges_sha = sha256_file(edges_path)
+    return _sha256_canon({"mind_nodes_sha256": str(nodes_sha), "mind_edges_sha256": str(edges_sha)})
+
+
+def _append_jsonl(path: str, row: Dict[str, Any]) -> None:
+    with open(path, "a", encoding="utf-8") as f:
+        f.write(canonical_json_dumps(row))
+        f.write("\n")
+
+
+def _write_json_once(path: str, obj: Any) -> None:
+    ensure_absent(path)
+    tmp = path + ".tmp"
+    with open(tmp, "w", encoding="utf-8") as f:
+        f.write(json.dumps(obj, ensure_ascii=False, indent=2, sort_keys=True))
+        f.write("\n")
+    os.replace(tmp, path)
+
+
+def goal_spec_v72_from_goal_act_v75(goal_act) -> Tuple[Optional[GoalSpecV72], str]:
+    if goal_act is None or str(getattr(goal_act, "kind", "")) != "goal_v75":
+        return None, "not_goal_v75_act"
+    ev = goal_act.evidence if isinstance(goal_act.evidence, dict) else {}
+    goal = ev.get("goal") if isinstance(ev.get("goal"), dict) else {}
+
+    goal_kind = str(goal.get("goal_kind") or "")
+    bindings = goal.get("bindings") if isinstance(goal.get("bindings"), dict) else {}
+    output_key = str(goal.get("output_key") or "")
+    expected = goal.get("expected")
+    validator_id = str(goal.get("validator_id") or "text_exact")
+    if not output_key:
+        return None, "missing_output_key"
+    return (
+        GoalSpecV72(
+            goal_kind=str(goal_kind),
+            bindings={str(k): bindings.get(k) for k in sorted(bindings.keys(), key=str)},
+            output_key=str(output_key),
+            expected=expected,
+            validator_id=str(validator_id),
+            created_step=0,
+        ),
+        "ok",
+    )
+
+
+def goal_kind_from_goal_act_v75(goal_act) -> str:
+    if goal_act is None or str(getattr(goal_act, "kind", "")) != "goal_v75":
+        return ""
+    ev = goal_act.evidence if isinstance(goal_act.evidence, dict) else {}
+    goal = ev.get("goal") if isinstance(ev.get("goal"), dict) else {}
+    return str(goal.get("goal_kind") or "")
+
+
+def _find_subpath_start(path: Sequence[str], subpath: Sequence[str]) -> Optional[int]:
+    p = [str(x) for x in path]
+    sp = [str(x) for x in subpath]
+    if not sp or len(sp) > len(p):
+        return None
+    for i in range(0, len(p) - len(sp) + 1):
+        if p[i : i + len(sp)] == sp:
+            return int(i)
+    return None
+
+
+def _trace_contains_subpath(trace: TraceV73, subpath: Sequence[str]) -> bool:
+    try:
+        return _find_subpath_start(trace.acts_path(), subpath) is not None
+    except Exception:
+        return False
+
+
+def _candidate_goal_kinds_supported(cand, traces_ok: Sequence[TraceV73]) -> List[str]:
+    kinds: List[str] = []
+    for tr in traces_ok:
+        if not isinstance(tr, TraceV73):
+            continue
+        if _trace_contains_subpath(tr, cand.subpath):
+            k = str(tr.goal_kind or "")
+            if k and k not in kinds:
+                kinds.append(k)
+    kinds.sort(key=str)
+    return kinds
+
+
+def _execute_prefix_state(
+    *,
+    store_base: ActStore,
+    trace: TraceV73,
+    upto_idx: int,
+    seed: int = 0,
+) -> Dict[str, Any]:
+    if int(upto_idx) <= 0:
+        return dict(trace.bindings)
+
+    from .engine import Engine, EngineConfig
+
+    vars_state: Dict[str, Any] = dict(trace.bindings)
+    engine = Engine(store_base, seed=int(seed), config=EngineConfig(enable_contracts=False))
+    steps = list(trace.steps)
+    for i, st in enumerate(steps[: int(upto_idx)]):
+        bm = st.bind_map if isinstance(st.bind_map, dict) else {}
+        inps: Dict[str, Any] = {}
+        for slot in sorted(bm.keys(), key=str):
+            vn = str(bm.get(slot) or "")
+            inps[str(slot)] = vars_state.get(vn)
+        out = engine.execute_concept_csv(
+            concept_act_id=str(st.concept_id),
+            inputs=dict(inps),
+            expected=None,
+            step=int(i),
+            max_depth=8,
+            max_events=512,
+            validate_output=False,
+        )
+        meta = out.get("meta") if isinstance(out, dict) else {}
+        meta = meta if isinstance(meta, dict) else {}
+        out_text = str(meta.get("output_text") or out.get("output") or "")
+        vars_state[str(st.produces)] = out_text
+    return dict(vars_state)
+
+
+def _expected_for_steps(
+    *,
+    store_base: ActStore,
+    steps: Sequence,
+    start_state: Dict[str, Any],
+    seed: int = 0,
+) -> str:
+    from .mine_promote_v74 import execute_steps_expected_output
+
+    return execute_steps_expected_output(store_base=store_base, steps=steps, bindings=start_state, seed=int(seed))
+
+
+LOGIC_VARS_V86: List[str] = ["a", "b"]
+LOGIC_DOMAIN_V86: List[str] = ["0", "1"]
+LOGIC_EXPR_XOR_AB_V86: Dict[str, Any] = {
+    "op": "xor",
+    "args": [{"op": "var", "name": "a"}, {"op": "var", "name": "b"}],
+}
+
+# Render prefixes per goal_kind (used when output_key == "out").
+GOAL_KIND_PREFIX_V86: Dict[str, str] = {
+    "v86_logic_sum": "BOOL=",
+    "v86_logic_total": "TBOOL=",
+}
+
+
+def _is_logic_goal_kind(kind: str) -> bool:
+    return str(kind or "").startswith("v86_logic_")
+
+
+def _candidate_logic_spec_v86(*, kinds: Sequence[str], output_key: str) -> Tuple[Optional[Dict[str, Any]], str]:
+    kinds2 = [str(k) for k in kinds if str(k)]
+    kinds2 = sorted(set(kinds2), key=str)
+    if not kinds2:
+        return None, "no_goal_kinds"
+    if not all(_is_logic_goal_kind(k) for k in kinds2):
+        return None, "not_logic_kind"
+
+    render: Dict[str, Any] = {}
+    if str(output_key) == "bit":
+        render = {"kind": "raw01"}
+    elif str(output_key) == "out":
+        if len(kinds2) != 1:
+            return None, "ambiguous_prefix_for_multi_kind_out"
+        prefix = GOAL_KIND_PREFIX_V86.get(str(kinds2[0]), "")
+        if not prefix:
+            return None, "unknown_goal_kind_prefix"
+        render = {"kind": "prefix01", "prefix": str(prefix)}
+    else:
+        return None, "unknown_output_key_for_logic"
+
+    return (
+        {
+            "vars": list(LOGIC_VARS_V86),
+            "domain_values": list(LOGIC_DOMAIN_V86),
+            "expr": dict(LOGIC_EXPR_XOR_AB_V86),
+            "render": dict(render),
+        },
+        "ok",
+    )
+
+
+def _build_vector_specs_logic_v86(
+    *,
+    act_candidate,
+    kinds: Sequence[str],
+    logic_spec: Dict[str, Any],
+) -> Tuple[Optional[List[Dict[str, Any]]], str]:
+    # Determine candidate input keys deterministically.
+    input_keys: List[str] = []
+    if isinstance(act_candidate.evidence, dict):
+        iface = act_candidate.evidence.get("interface") if isinstance(act_candidate.evidence.get("interface"), dict) else {}
+        iface = iface if isinstance(iface, dict) else {}
+        in_schema = iface.get("input_schema") if isinstance(iface.get("input_schema"), dict) else {}
+        input_keys = [str(k) for k in sorted(in_schema.keys(), key=str)]
+    if not input_keys:
+        return None, "missing_candidate_input_schema"
+
+    kinds2 = [str(k) for k in kinds if str(k)]
+    kinds2 = sorted(set(kinds2), key=str)
+    if not kinds2:
+        return None, "no_goal_kinds"
+
+    vars_norm = [str(v) for v in logic_spec.get("vars") if str(v)]
+    vars_norm = sorted(set(vars_norm), key=str)
+    expr_canon = logic_canon(logic_spec.get("expr"))
+    render = logic_spec.get("render") if isinstance(logic_spec.get("render"), dict) else {}
+
+    primary_kind = str(kinds2[0])
+    vectors: List[Dict[str, Any]] = []
+
+    def _expected_for_assignment(assn: Dict[str, Any]) -> str:
+        out_b = logic_eval(expr_canon, assn)
+        out01 = "1" if bool(out_b) else "0"
+        return str(render_output01(out01=out01, render=dict(render)))
+
+    assignments = []
+    # Deterministic truth-table order (vars sorted; binary order).
+    from .logic_v86 import enumerate_assignments
+
+    try:
+        assignments = enumerate_assignments(vars=vars_norm, domain_values=list(LOGIC_DOMAIN_V86))
+    except Exception:
+        return None, "bad_logic_domain"
+
+    for a in assignments:
+        inputs = {k: str(a.get(k)) for k in input_keys}
+        if any(k not in a for k in input_keys):
+            return None, "candidate_inputs_not_subset_of_logic_vars"
+        expected = _expected_for_assignment(a)
+        ctx_sig = _sha256_canon({"logic": True, "goal_kind": str(primary_kind), "inputs": inputs, "expected": expected})
+        vectors.append({"context_id": f"logic:{primary_kind}:{ctx_sig}", "goal_kind": str(primary_kind), "inputs": dict(inputs), "expected": str(expected)})
+
+    # Ensure at least one vector per additional goal_kind (V82), without exploding vectors.
+    a0 = assignments[0] if assignments else {}
+    for extra_kind in kinds2[1:]:
+        inputs0 = {k: str(a0.get(k)) for k in input_keys}
+        expected0 = _expected_for_assignment(a0)
+        ctx_sig = _sha256_canon({"logic": True, "goal_kind": str(extra_kind), "inputs": inputs0, "expected": expected0})
+        vectors.append({"context_id": f"logic:{extra_kind}:{ctx_sig}", "goal_kind": str(extra_kind), "inputs": dict(inputs0), "expected": str(expected0)})
+
+    if len(vectors) < 3:
+        return None, "not_enough_logic_vectors"
+    return list(vectors), "ok"
+
+
+def _build_vector_specs_generic_v86(
+    *,
+    store_base: ActStore,
+    act_candidate,
+    cand,
+    traces_ok: Sequence[TraceV73],
+    kinds: Sequence[str],
+    seed: int,
+    max_base_vectors: int = 3,
+) -> Tuple[Optional[List[Dict[str, Any]]], str]:
+    """
+    Generic deterministic vector_specs builder (V85-style).
+    """
+    input_keys: List[str] = []
+    if isinstance(act_candidate.evidence, dict):
+        iface = act_candidate.evidence.get("interface") if isinstance(act_candidate.evidence.get("interface"), dict) else {}
+        iface = iface if isinstance(iface, dict) else {}
+        in_schema = iface.get("input_schema") if isinstance(iface.get("input_schema"), dict) else {}
+        input_keys = [str(k) for k in sorted(in_schema.keys(), key=str)]
+
+    support_set = set(str(x) for x in (cand.contexts or []) if str(x))
+    support_traces = [t for t in traces_ok if isinstance(t, TraceV73) and str(t.context_id) in support_set]
+    support_traces.sort(key=lambda t: str(t.trace_sig()))
+    if not support_traces:
+        return None, "insufficient_support_traces"
+
+    kinds2 = [str(k) for k in kinds if str(k)]
+    kinds2 = sorted(set(kinds2), key=str)
+    if not kinds2:
+        return None, "insufficient_vector_goal_kind_coverage_global_kind_coverage_fail"
+
+    chosen_by_kind: Dict[str, TraceV73] = {}
+    for gk in kinds2:
+        cands = [t for t in support_traces if str(t.goal_kind) == str(gk) and _trace_contains_subpath(t, cand.subpath)]
+        cands.sort(key=lambda t: str(t.trace_sig()))
+        if not cands:
+            return None, "insufficient_vector_goal_kind_coverage_global_kind_coverage_fail"
+        chosen_by_kind[str(gk)] = cands[0]
+
+    used_trace_sigs = set()
+    base_vectors: List[Dict[str, Any]] = []
+    for gk in kinds2:
+        tr = chosen_by_kind[str(gk)]
+        used_trace_sigs.add(str(tr.trace_sig()))
+        start = _find_subpath_start(tr.acts_path(), cand.subpath)
+        if start is None:
+            return None, "insufficient_vector_goal_kind_coverage_global_kind_coverage_fail"
+        state0 = _execute_prefix_state(store_base=store_base, trace=tr, upto_idx=int(start), seed=int(seed))
+        sub_steps = list(tr.steps)[int(start) : int(start) + int(len(cand.subpath))]
+        exp = _expected_for_steps(store_base=store_base, steps=sub_steps, start_state=state0, seed=int(seed))
+        inputs = {k: state0.get(k) for k in input_keys}
+        ctx_sig = _sha256_canon({"goal_kind": str(gk), "ctx": str(tr.context_id), "sub_sig": str(cand.sub_sig), "inputs": inputs})
+        base_vectors.append(
+            {
+                "context_id": f"{gk}:{tr.context_id}:{ctx_sig}",
+                "goal_kind": str(gk),
+                "inputs": dict(inputs),
+                "expected": str(exp),
+            }
+        )
+
+    for tr in support_traces:
+        if len(base_vectors) >= int(max_base_vectors):
+            break
+        if str(tr.trace_sig()) in used_trace_sigs:
+            continue
+        start = _find_subpath_start(tr.acts_path(), cand.subpath)
+        if start is None:
+            continue
+        gk = str(tr.goal_kind or "")
+        if not gk:
+            continue
+        state0 = _execute_prefix_state(store_base=store_base, trace=tr, upto_idx=int(start), seed=int(seed))
+        sub_steps = list(tr.steps)[int(start) : int(start) + int(len(cand.subpath))]
+        exp = _expected_for_steps(store_base=store_base, steps=sub_steps, start_state=state0, seed=int(seed))
+        inputs = {k: state0.get(k) for k in input_keys}
+        ctx_sig = _sha256_canon({"goal_kind": str(gk), "ctx": str(tr.context_id), "sub_sig": str(cand.sub_sig), "inputs": inputs})
+        base_vectors.append(
+            {
+                "context_id": f"{gk}:{tr.context_id}:{ctx_sig}",
+                "goal_kind": str(gk),
+                "inputs": dict(inputs),
+                "expected": str(exp),
+            }
+        )
+        used_trace_sigs.add(str(tr.trace_sig()))
+
+    base_kind = kinds2[0]
+    base_trace = chosen_by_kind[base_kind]
+    start0 = _find_subpath_start(base_trace.acts_path(), cand.subpath)
+    if start0 is None:
+        return None, "insufficient_vector_goal_kind_coverage_global_kind_coverage_fail"
+    mutated_bindings = mutate_bindings_plus1_numeric(bindings=dict(base_trace.bindings), key_preference=["x", "y"])
+    trace_mut = TraceV73(
+        context_id=str(base_trace.context_id),
+        goal_sig=str(base_trace.goal_sig),
+        goal_id=str(base_trace.goal_id),
+        goal_kind=str(base_trace.goal_kind),
+        bindings=dict(mutated_bindings),
+        output_key=str(base_trace.output_key),
+        expected=base_trace.expected,
+        validator_id=str(base_trace.validator_id),
+        steps=list(base_trace.steps),
+        outcome=dict(base_trace.outcome),
+        cost_units=dict(base_trace.cost_units),
+    )
+    state_mut = _execute_prefix_state(store_base=store_base, trace=trace_mut, upto_idx=int(start0), seed=int(seed))
+    sub_steps0 = list(base_trace.steps)[int(start0) : int(start0) + int(len(cand.subpath))]
+    exp_mut = _expected_for_steps(store_base=store_base, steps=sub_steps0, start_state=state_mut, seed=int(seed))
+    inputs_mut = {k: state_mut.get(k) for k in input_keys}
+    extra_ctx = _sha256_canon({"extra": True, "goal_kind": str(base_trace.goal_kind), "sub_sig": str(cand.sub_sig), "inputs": inputs_mut})
+    base_vectors.append(
+        {
+            "context_id": f"extra:{base_trace.goal_kind}:{extra_ctx}",
+            "goal_kind": str(base_trace.goal_kind),
+            "inputs": dict(inputs_mut),
+            "expected": str(exp_mut),
+        }
+    )
+
+    uniq: Dict[str, Dict[str, Any]] = {}
+    for v in base_vectors:
+        gk = str(v.get("goal_kind") or "")
+        inp = v.get("inputs") if isinstance(v.get("inputs"), dict) else {}
+        exp = str(v.get("expected") or "")
+        sig = _sha256_canon({"goal_kind": str(gk), "inputs": {str(k): inp.get(k) for k in sorted(inp.keys(), key=str)}, "expected": str(exp)})
+        if sig not in uniq:
+            uniq[sig] = v
+    vectors = [uniq[k] for k in sorted(uniq.keys(), key=str)]
+
+    present_kinds = sorted(set(str(v.get("goal_kind") or "") for v in vectors if str(v.get("goal_kind") or "")), key=str)
+    for gk in kinds2:
+        if str(gk) not in set(present_kinds):
+            return None, "insufficient_vector_goal_kind_coverage_global_kind_coverage_fail"
+    if len(vectors) < 3:
+        return None, "insufficient_vector_specs_after_dedup"
+
+    return list(vectors), "ok"
+
+
+def _compression_points_from_events(rows: Sequence[Dict[str, Any]]) -> List[Dict[str, Any]]:
+    points: List[Dict[str, Any]] = []
+    idxs: List[int] = []
+    for i, r in enumerate(rows):
+        if not isinstance(r, dict):
+            continue
+        if str(r.get("event_kind") or "") == "promotion_attempt" and str(r.get("decision") or "") == "promoted":
+            idxs.append(int(i))
+
+    for i, ev_idx in enumerate(idxs):
+        before = None
+        for r in reversed(list(rows[:ev_idx])):
+            if not isinstance(r, dict):
+                continue
+            if str(r.get("event_kind") or "") != "goal_attempt":
+                continue
+            before = int(r.get("steps_total", 0) or 0)
+            break
+        after = None
+        for r in list(rows[ev_idx + 1 :]):
+            if not isinstance(r, dict):
+                continue
+            if str(r.get("event_kind") or "") != "goal_attempt":
+                continue
+            after = int(r.get("steps_total", 0) or 0)
+            break
+        if before is None or after is None:
+            continue
+        points.append(
+            {
+                "promotion_index": int(i),
+                "steps_before": int(before),
+                "steps_after": int(after),
+                "delta_steps": int(int(before) - int(after)),
+            }
+        )
+    return points
+
+
+def run_goals_v86(
+    *,
+    store: ActStore,
+    seed: int,
+    out_dir: str,
+    max_rounds: int = 10,
+    max_goals_per_round: int = 1,
+    enable_promotion: bool = True,
+    promotion_budget_bits: int = 2048,
+    promotion_min_traces: int = 2,
+    promotion_top_k: int = 8,
+    max_promotions_per_run: int = 3,
+    promotion_kind_diversity_min: int = 1,
+) -> Dict[str, Any]:
+    """
+    V86: V85 loop + PCC logic-bound verification (finite-domain proof when applicable).
+    """
+    ensure_bool_primitives_registered()
+
+    ensure_absent(out_dir)
+    os.makedirs(out_dir, exist_ok=False)
+
+    events_path = os.path.join(out_dir, "goals_v86_events.jsonl")
+    ensure_absent(events_path)
+
+    traces: List[TraceV73] = []
+    attempts_total = 0
+    promoted_total = 0
+    used_bits = 0
+
+    promotions_dir = os.path.join(out_dir, "promotion")
+    promotions_path = os.path.join(promotions_dir, "v86_promotions.jsonl")
+    candidates_dir = os.path.join(out_dir, "candidates")
+    traces_path = os.path.join(out_dir, "traces_v86.json")
+    mined_path = os.path.join(out_dir, "mined_candidates_v86.json")
+    curve_path = os.path.join(out_dir, "compression_curve.json")
+
+    store_hash_init = str(store.content_hash())
+    step_ctr = 0
+    events_buf: List[Dict[str, Any]] = []
+    window_start_idx = 0
+
+    def _emit_event(row: Dict[str, Any]) -> None:
+        nonlocal step_ctr
+        body = dict(row)
+        body["created_at"] = deterministic_iso(step=int(step_ctr))
+        _append_jsonl(events_path, body)
+        events_buf.append(dict(body))
+        step_ctr += 1
+
+    def _emit_promo_row(row: Dict[str, Any]) -> None:
+        os.makedirs(promotions_dir, exist_ok=True)
+        _append_jsonl(promotions_path, row)
+
+    for r in range(0, int(max_rounds)):
+        goals = list_goal_acts_v75(store)
+        pending = [g for g in goals if not goal_v75_is_satisfied(g)]
+        pending.sort(key=lambda a: (int(goal_created_step_v75(a)), str(getattr(a, "id", ""))))
+
+        if not pending:
+            break
+
+        to_run = pending[: int(max_goals_per_round)]
+        skipped = pending[int(max_goals_per_round) :]
+
+        for g in skipped:
+            store_hash_before = str(store.content_hash())
+            _emit_event(
+                {
+                    "round": int(r),
+                    "event_kind": "goal_skipped",
+                    "promotion_index": -1,
+                    "goal_id": str(getattr(g, "id", "")),
+                    "goal_sig": str(goal_sig_v75(g)),
+                    "goal_kind": str(goal_kind_from_goal_act_v75(g)),
+                    "goal_created_step": int(goal_created_step_v75(g)),
+                    "decision": "skipped",
+                    "reason": "max_goals_per_round",
+                    "plan_sig": "",
+                    "trace_sig": "",
+                    "steps_total": 0,
+                    "run_dir_sha256": "",
+                    "candidate_id": "",
+                    "certificate_sig": "",
+                    "overhead_bits": 0,
+                    "gain_bits_est": 0,
+                    "used_bits_after": int(used_bits),
+                    "store_hash_before": str(store_hash_before),
+                    "store_hash_after": str(store_hash_before),
+                }
+            )
+
+        for g in to_run:
+            store_hash_before = str(store.content_hash())
+            goal_spec, reason = goal_spec_v72_from_goal_act_v75(g)
+            goal_kind = str(goal_kind_from_goal_act_v75(g))
+            goal_step = int(goal_created_step_v75(g))
+            if goal_spec is None:
+                _emit_event(
+                    {
+                        "round": int(r),
+                        "event_kind": "goal_attempt",
+                        "promotion_index": -1,
+                        "goal_id": str(getattr(g, "id", "")),
+                        "goal_sig": str(goal_sig_v75(g)),
+                        "goal_kind": str(goal_kind),
+                        "goal_created_step": int(goal_step),
+                        "decision": "failed",
+                        "reason": str(reason),
+                        "plan_sig": "",
+                        "trace_sig": "",
+                        "steps_total": 0,
+                        "run_dir_sha256": "",
+                        "candidate_id": "",
+                        "certificate_sig": "",
+                        "overhead_bits": 0,
+                        "gain_bits_est": 0,
+                        "used_bits_after": int(used_bits),
+                        "store_hash_before": str(store_hash_before),
+                        "store_hash_after": str(store_hash_before),
+                    }
+                )
+                continue
+
+            attempts_total += 1
+            gid = str(getattr(g, "id", "") or "")
+            attempt_dir = os.path.join(out_dir, f"round{int(r):02d}", f"goal_{gid[:24]}")
+            ensure_absent(attempt_dir)
+            os.makedirs(attempt_dir, exist_ok=False)
+
+            res = run_goal_spec_v80(goal_spec=goal_spec, store=store, seed=int(seed), out_dir=attempt_dir)
+            ok = bool(res.get("ok", False))
+            plan = res.get("plan") if isinstance(res.get("plan"), dict) else {}
+            plan_sig = str(plan.get("plan_sig") or "")
+            tr = trace_from_agent_loop_v72(goal_spec=goal_spec, result=res)
+            traces.append(tr)
+            trace_sig = str(tr.trace_sig())
+            run_sha = run_dir_sha256_v86(run_dir=attempt_dir)
+
+            updated = goal_v75_update_from_run(
+                act=g,
+                run_res=res,
+                trace_sig=str(trace_sig),
+                run_dir_sha256=str(run_sha),
+                step=int(step_ctr),
+            )
+            store.add(updated)
+
+            store_hash_after = str(store.content_hash())
+            _emit_event(
+                {
+                    "round": int(r),
+                    "event_kind": "goal_attempt",
+                    "promotion_index": -1,
+                    "goal_id": str(getattr(g, "id", "")),
+                    "goal_sig": str(goal_sig_v75(g)),
+                    "goal_kind": str(goal_kind),
+                    "goal_created_step": int(goal_step),
+                    "decision": "satisfied" if ok else "active",
+                    "reason": str(res.get("reason") or ""),
+                    "plan_sig": str(plan_sig),
+                    "trace_sig": str(trace_sig),
+                    "steps_total": int(len(tr.steps)),
+                    "run_dir_sha256": str(run_sha),
+                    "candidate_id": "",
+                    "certificate_sig": "",
+                    "overhead_bits": 0,
+                    "gain_bits_est": 0,
+                    "used_bits_after": int(used_bits),
+                    "store_hash_before": str(store_hash_before),
+                    "store_hash_after": str(store_hash_after),
+                }
+            )
+
+        if not bool(enable_promotion):
+            continue
+        if int(promoted_total) >= int(max_promotions_per_run):
+            continue
+
+        traces_ok = [t for t in traces[window_start_idx:] if isinstance(t, TraceV73) and bool(t.outcome.get("ok", False))]
+        traces_ok.sort(key=lambda t: str(t.trace_sig()))
+        if len(traces_ok) < int(promotion_min_traces):
+            continue
+
+        mined, mined_dbg = mine_candidates_v74(
+            traces=traces_ok,
+            max_k=6,
+            min_support=2,
+            top_k=int(promotion_top_k),
+        )
+        if not os.path.exists(mined_path):
+            _write_json_once(
+                mined_path,
+                {
+                    "schema_version": 1,
+                    "round": int(r),
+                    "window_start_idx": int(window_start_idx),
+                    "traces_ok": int(len(traces_ok)),
+                    "candidates": [c.to_dict() for c in mined],
+                    "debug": dict(mined_dbg),
+                },
+            )
+
+        if not mined:
+            continue
+        if int(used_bits) >= int(promotion_budget_bits):
+            continue
+
+        if not os.path.exists(candidates_dir):
+            ensure_absent(candidates_dir)
+            os.makedirs(candidates_dir, exist_ok=False)
+        if not os.path.exists(promotions_dir):
+            ensure_absent(promotions_dir)
+            os.makedirs(promotions_dir, exist_ok=False)
+
+        traces_by_sig = {str(t.trace_sig()): t for t in traces_ok}
+
+        for cand_idx, cand in enumerate(mined):
+            promotion_index = int(promoted_total)
+            store_hash_before = str(store.content_hash())
+
+            kinds = _candidate_goal_kinds_supported(cand, traces_ok)
+            kinds = sorted(set(str(k) for k in kinds if str(k)), key=str)
+            required_kinds = int(promotion_kind_diversity_min) if int(promotion_index) == 0 else 1
+            if len(kinds) < int(required_kinds):
+                _emit_event(
+                    {
+                        "round": int(r),
+                        "event_kind": "promotion_attempt",
+                        "promotion_index": int(promotion_index),
+                        "goal_id": "",
+                        "goal_sig": "",
+                        "goal_kind": "",
+                        "goal_created_step": 0,
+                        "decision": "skipped",
+                        "reason": "insufficient_goal_kind_diversity",
+                        "plan_sig": "",
+                        "trace_sig": "",
+                        "steps_total": 0,
+                        "run_dir_sha256": "",
+                        "candidate_id": "",
+                        "certificate_sig": "",
+                        "overhead_bits": 0,
+                        "gain_bits_est": int(cand.gain_bits_est),
+                        "used_bits_after": int(used_bits),
+                        "store_hash_before": str(store_hash_before),
+                        "store_hash_after": str(store_hash_before),
+                    }
+                )
+                _emit_promo_row(
+                    {
+                        "created_at": deterministic_iso(step=10_000 + int(step_ctr) + int(cand_idx)),
+                        "candidate_id": "",
+                        "certificate_sig": "",
+                        "gain_bits_est": int(cand.gain_bits_est),
+                        "overhead_bits": 0,
+                        "decision": "skipped",
+                        "reason": "insufficient_goal_kind_diversity",
+                        "store_hash_before": str(store_hash_before),
+                        "store_hash_after": str(store_hash_before),
+                        "goal_kinds_supported": list(kinds),
+                        "required_goal_kind_diversity": int(required_kinds),
+                    }
+                )
+                continue
+
+            rep_steps = extract_rep_steps(
+                traces_by_sig=traces_by_sig,
+                rep_trace_sig=str(cand.rep_trace_sig),
+                start_idx=int(cand.start_idx),
+                subpath_len=int(len(cand.subpath)),
+            )
+            act, _dbg = materialize_composed_act_v74(
+                store_base=store,
+                steps=rep_steps,
+                support_contexts=int(cand.support_contexts),
+                contexts=list(cand.contexts),
+                seed_step=0,
+            )
+
+            act.match = {"goal_kinds": list(kinds)}
+            overhead_bits = int((act.cost or {}).get("overhead_bits", 1024) or 1024)
+
+            # Infer output_key for logic binding/render choice.
+            out_key = ""
+            if isinstance(act.evidence, dict):
+                iface = act.evidence.get("interface") if isinstance(act.evidence.get("interface"), dict) else {}
+                iface = iface if isinstance(iface, dict) else {}
+                out_schema = iface.get("output_schema") if isinstance(iface.get("output_schema"), dict) else {}
+                keys = [str(k) for k in sorted(out_schema.keys(), key=str)]
+                if len(keys) == 1:
+                    out_key = str(keys[0])
+
+            if store.get(str(act.id)) is not None:
+                _emit_event(
+                    {
+                        "round": int(r),
+                        "event_kind": "promotion_attempt",
+                        "promotion_index": int(promotion_index),
+                        "goal_id": "",
+                        "goal_sig": "",
+                        "goal_kind": "",
+                        "goal_created_step": 0,
+                        "decision": "skipped",
+                        "reason": "already_in_store",
+                        "plan_sig": "",
+                        "trace_sig": "",
+                        "steps_total": 0,
+                        "run_dir_sha256": "",
+                        "candidate_id": str(act.id),
+                        "certificate_sig": "",
+                        "overhead_bits": int(overhead_bits),
+                        "gain_bits_est": int(cand.gain_bits_est),
+                        "used_bits_after": int(used_bits),
+                        "store_hash_before": str(store_hash_before),
+                        "store_hash_after": str(store_hash_before),
+                    }
+                )
+                _emit_promo_row(
+                    {
+                        "created_at": deterministic_iso(step=11_000 + int(step_ctr) + int(cand_idx)),
+                        "candidate_id": str(act.id),
+                        "certificate_sig": "",
+                        "gain_bits_est": int(cand.gain_bits_est),
+                        "overhead_bits": int(overhead_bits),
+                        "decision": "skipped",
+                        "reason": "already_in_store",
+                        "store_hash_before": str(store_hash_before),
+                        "store_hash_after": str(store_hash_before),
+                    }
+                )
+                continue
+
+            if int(used_bits) + int(overhead_bits) > int(promotion_budget_bits):
+                _emit_event(
+                    {
+                        "round": int(r),
+                        "event_kind": "promotion_attempt",
+                        "promotion_index": int(promotion_index),
+                        "goal_id": "",
+                        "goal_sig": "",
+                        "goal_kind": "",
+                        "goal_created_step": 0,
+                        "decision": "skipped",
+                        "reason": "budget_exceeded",
+                        "plan_sig": "",
+                        "trace_sig": "",
+                        "steps_total": 0,
+                        "run_dir_sha256": "",
+                        "candidate_id": str(act.id),
+                        "certificate_sig": "",
+                        "overhead_bits": int(overhead_bits),
+                        "gain_bits_est": int(cand.gain_bits_est),
+                        "used_bits_after": int(used_bits),
+                        "store_hash_before": str(store_hash_before),
+                        "store_hash_after": str(store_hash_before),
+                    }
+                )
+                _emit_promo_row(
+                    {
+                        "created_at": deterministic_iso(step=12_000 + int(step_ctr) + int(cand_idx)),
+                        "candidate_id": str(act.id),
+                        "certificate_sig": "",
+                        "gain_bits_est": int(cand.gain_bits_est),
+                        "overhead_bits": int(overhead_bits),
+                        "decision": "skipped",
+                        "reason": "budget_exceeded",
+                        "store_hash_before": str(store_hash_before),
+                        "store_hash_after": str(store_hash_before),
+                    }
+                )
+                continue
+
+            logic_spec, logic_reason = _candidate_logic_spec_v86(kinds=kinds, output_key=str(out_key))
+            vectors: Optional[List[Dict[str, Any]]] = None
+            v_reason = ""
+            if logic_spec is not None and str(logic_reason) == "ok":
+                vectors, v_reason = _build_vector_specs_logic_v86(act_candidate=act, kinds=kinds, logic_spec=logic_spec)
+            else:
+                vectors, v_reason = _build_vector_specs_generic_v86(
+                    store_base=store,
+                    act_candidate=act,
+                    cand=cand,
+                    traces_ok=traces_ok,
+                    kinds=kinds,
+                    seed=int(seed),
+                )
+
+            if vectors is None:
+                _emit_event(
+                    {
+                        "round": int(r),
+                        "event_kind": "promotion_attempt",
+                        "promotion_index": int(promotion_index),
+                        "goal_id": "",
+                        "goal_sig": "",
+                        "goal_kind": "",
+                        "goal_created_step": 0,
+                        "decision": "skipped",
+                        "reason": str(v_reason or logic_reason),
+                        "plan_sig": "",
+                        "trace_sig": "",
+                        "steps_total": 0,
+                        "run_dir_sha256": "",
+                        "candidate_id": str(act.id),
+                        "certificate_sig": "",
+                        "overhead_bits": int(overhead_bits),
+                        "gain_bits_est": int(cand.gain_bits_est),
+                        "used_bits_after": int(used_bits),
+                        "store_hash_before": str(store_hash_before),
+                        "store_hash_after": str(store_hash_before),
+                    }
+                )
+                _emit_promo_row(
+                    {
+                        "created_at": deterministic_iso(step=13_000 + int(step_ctr) + int(cand_idx)),
+                        "candidate_id": str(act.id),
+                        "certificate_sig": "",
+                        "gain_bits_est": int(cand.gain_bits_est),
+                        "overhead_bits": int(overhead_bits),
+                        "decision": "skipped",
+                        "reason": str(v_reason or logic_reason),
+                        "store_hash_before": str(store_hash_before),
+                        "store_hash_after": str(store_hash_before),
+                    }
+                )
+                continue
+
+            mined_from = {
+                "trace_sigs": [str(t.trace_sig()) for t in sorted(traces_ok, key=lambda t: str(t.trace_sig()))],
+                "goal_kinds": [str(x) for x in sorted(set(str(t.goal_kind) for t in traces_ok), key=str)],
+                "goal_kinds_distinct": int(len(set(str(t.goal_kind) for t in traces_ok))),
+                "candidate": {"sub_sig": str(cand.sub_sig), "subpath": [str(x) for x in cand.subpath], "goal_kinds_supported": list(kinds)},
+            }
+
+            cert = build_certificate_v86(
+                candidate_act=act,
+                store_base=store,
+                mined_from=mined_from,
+                vector_specs=vectors,
+                seed=int(seed),
+                logic_spec=logic_spec,
+            )
+            ok_pcc, reason_pcc, details_pcc = verify_pcc_v86(candidate_act=act, certificate=cert, store_base=store, seed=int(seed))
+            cert_sig = str(cert.get("certificate_sig") or "")
+            if not ok_pcc:
+                _emit_event(
+                    {
+                        "round": int(r),
+                        "event_kind": "promotion_attempt",
+                        "promotion_index": int(promotion_index),
+                        "goal_id": "",
+                        "goal_sig": "",
+                        "goal_kind": "",
+                        "goal_created_step": 0,
+                        "decision": "skipped",
+                        "reason": f"pcc_fail:{reason_pcc}",
+                        "plan_sig": "",
+                        "trace_sig": "",
+                        "steps_total": 0,
+                        "run_dir_sha256": "",
+                        "candidate_id": str(act.id),
+                        "certificate_sig": str(cert_sig),
+                        "overhead_bits": int(overhead_bits),
+                        "gain_bits_est": int(cand.gain_bits_est),
+                        "used_bits_after": int(used_bits),
+                        "store_hash_before": str(store_hash_before),
+                        "store_hash_after": str(store_hash_before),
+                    }
+                )
+                _emit_promo_row(
+                    {
+                        "created_at": deterministic_iso(step=14_000 + int(step_ctr) + int(cand_idx)),
+                        "candidate_id": str(act.id),
+                        "certificate_sig": str(cert_sig),
+                        "gain_bits_est": int(cand.gain_bits_est),
+                        "overhead_bits": int(overhead_bits),
+                        "decision": "skipped",
+                        "reason": f"pcc_fail:{reason_pcc}",
+                        "store_hash_before": str(store_hash_before),
+                        "store_hash_after": str(store_hash_before),
+                        "details": dict(details_pcc) if isinstance(details_pcc, dict) else {},
+                    }
+                )
+                continue
+
+            cand_k = int(promoted_total)
+            act_path = os.path.join(candidates_dir, f"candidate_{cand_k:03d}_act.json")
+            cert_path = os.path.join(candidates_dir, f"candidate_{cand_k:03d}_certificate_v2.json")
+            _write_json_once(act_path, act.to_dict())
+            _write_json_once(cert_path, cert)
+
+            store_hash_before_add = str(store.content_hash())
+            store.add(act)
+            store_hash_after_add = str(store.content_hash())
+            used_bits += int(overhead_bits)
+            promoted_total += 1
+
+            _emit_event(
+                {
+                    "round": int(r),
+                    "event_kind": "promotion_attempt",
+                    "promotion_index": int(promotion_index),
+                    "goal_id": "",
+                    "goal_sig": "",
+                    "goal_kind": "",
+                    "goal_created_step": 0,
+                    "decision": "promoted",
+                    "reason": "ok",
+                    "plan_sig": "",
+                    "trace_sig": "",
+                    "steps_total": 0,
+                    "run_dir_sha256": "",
+                    "candidate_id": str(act.id),
+                    "certificate_sig": str(cert_sig),
+                    "overhead_bits": int(overhead_bits),
+                    "gain_bits_est": int(cand.gain_bits_est),
+                    "used_bits_after": int(used_bits),
+                    "store_hash_before": str(store_hash_before_add),
+                    "store_hash_after": str(store_hash_after_add),
+                }
+            )
+            _emit_promo_row(
+                {
+                    "created_at": deterministic_iso(step=15_000 + int(step_ctr) + int(cand_idx)),
+                    "candidate_id": str(act.id),
+                    "certificate_sig": str(cert_sig),
+                    "gain_bits_est": int(cand.gain_bits_est),
+                    "overhead_bits": int(overhead_bits),
+                    "decision": "promoted",
+                    "reason": "ok",
+                    "store_hash_before": str(store_hash_before_add),
+                    "store_hash_after": str(store_hash_after_add),
+                }
+            )
+
+            window_start_idx = int(len(traces))
+            break
+
+    traces_sorted = sorted(traces, key=lambda t: str(t.trace_sig()))
+    _write_json_once(traces_path, {"schema_version": 1, "traces": [t.to_canonical_dict(include_sig=True) for t in traces_sorted]})
+    points = _compression_points_from_events(events_buf)
+    curve_core = {"schema_version": 1, "points": list(points), "curve_sig": _sha256_canon(points)}
+    _write_json_once(curve_path, curve_core)
+
+    store_hash_final = str(store.content_hash())
+    return {
+        "schema_version": 1,
+        "seed": int(seed),
+        "store_hash_init": str(store_hash_init),
+        "store_hash_final": str(store_hash_final),
+        "goals_total": int(len(list_goal_acts_v75(store))),
+        "goals_satisfied": int(len([g for g in list_goal_acts_v75(store) if goal_v75_is_satisfied(g)])),
+        "attempts_total": int(attempts_total),
+        "traces_total": int(len(traces)),
+        "promoted_total": int(promoted_total),
+        "used_bits": int(used_bits),
+        "budget_bits": int(promotion_budget_bits),
+        "artifacts": {
+            "goals_v86_events_jsonl_sha256": sha256_file(events_path),
+            "traces_v86_json_sha256": sha256_file(traces_path),
+            "mined_candidates_v86_json_sha256": sha256_file(mined_path) if os.path.exists(mined_path) else "",
+            "v86_promotions_jsonl_sha256": sha256_file(promotions_path) if os.path.exists(promotions_path) else "",
+            "compression_curve_json_sha256": sha256_file(curve_path),
+        },
+    }
+
--- /dev/null	2026-01-12 23:24:59
+++ scripts/smoke_goal_act_agent_loop_v86_pcc_logic_bound.py	2026-01-12 23:23:31
@@ -0,0 +1,699 @@
+#!/usr/bin/env python3
+from __future__ import annotations
+
+import argparse
+import hashlib
+import json
+import os
+import sys
+from typing import Any, Dict, List, Optional, Sequence, Tuple
+
+sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
+
+from atos_core.act import Act, Instruction, canonical_json_dumps, deterministic_iso, sha256_hex
+from atos_core.agent_loop_goals_v86 import run_goals_v86
+from atos_core.logic_v86 import ensure_bool_primitives_registered
+from atos_core.pcc_v74 import certificate_sig_v2
+from atos_core.pcc_v85 import build_certificate_v85
+from atos_core.pcc_v86 import build_certificate_v86, verify_pcc_v86
+from atos_core.store import ActStore
+
+
+def sha256_file(path: str) -> str:
+    h = hashlib.sha256()
+    with open(path, "rb") as f:
+        while True:
+            b = f.read(1024 * 1024)
+            if not b:
+                break
+            h.update(b)
+    return h.hexdigest()
+
+
+def sha256_text(s: str) -> str:
+    return hashlib.sha256(str(s).encode("utf-8")).hexdigest()
+
+
+def sha256_canon(obj: Any) -> str:
+    return sha256_hex(canonical_json_dumps(obj).encode("utf-8"))
+
+
+def _fail(msg: str, *, code: int = 2) -> None:
+    print(msg, file=sys.stderr)
+    raise SystemExit(code)
+
+
+def ensure_absent(path: str) -> None:
+    if os.path.exists(path):
+        _fail(f"ERROR: path already exists: {path}")
+
+
+def write_json(path: str, obj: Any) -> str:
+    ensure_absent(path)
+    tmp = path + ".tmp"
+    with open(tmp, "w", encoding="utf-8") as f:
+        f.write(json.dumps(obj, ensure_ascii=False, indent=2, sort_keys=True))
+        f.write("\n")
+    os.replace(tmp, path)
+    return sha256_file(path)
+
+
+def make_concept_act(
+    *,
+    act_id: str,
+    match: Optional[Dict[str, Any]] = None,
+    input_schema: Dict[str, str],
+    output_schema: Dict[str, str],
+    validator_id: str,
+    program: List[Instruction],
+) -> Act:
+    return Act(
+        id=str(act_id),
+        version=1,
+        created_at=deterministic_iso(step=0),
+        kind="concept_csv",
+        match=dict(match) if isinstance(match, dict) else {},
+        program=list(program),
+        evidence={
+            "interface": {
+                "input_schema": dict(input_schema),
+                "output_schema": dict(output_schema),
+                "validator_id": str(validator_id),
+            }
+        },
+        cost={},
+        deps=[],
+        active=True,
+    )
+
+
+def _read_jsonl(path: str) -> List[Dict[str, Any]]:
+    rows: List[Dict[str, Any]] = []
+    with open(path, "r", encoding="utf-8") as f:
+        for line in f:
+            line = line.strip()
+            if not line:
+                continue
+            rows.append(json.loads(line))
+    return rows
+
+
+def _points_from_events(events: Sequence[Dict[str, Any]]) -> List[Dict[str, Any]]:
+    idxs: List[int] = []
+    for i, r in enumerate(events):
+        if not isinstance(r, dict):
+            continue
+        if str(r.get("event_kind") or "") == "promotion_attempt" and str(r.get("decision") or "") == "promoted":
+            idxs.append(int(i))
+
+    points: List[Dict[str, Any]] = []
+    for pi, ev_idx in enumerate(idxs):
+        before = None
+        for r in reversed(list(events[:ev_idx])):
+            if not isinstance(r, dict):
+                continue
+            if str(r.get("event_kind") or "") != "goal_attempt":
+                continue
+            before = int(r.get("steps_total", 0) or 0)
+            break
+        after = None
+        for r in list(events[ev_idx + 1 :]):
+            if not isinstance(r, dict):
+                continue
+            if str(r.get("event_kind") or "") != "goal_attempt":
+                continue
+            after = int(r.get("steps_total", 0) or 0)
+            break
+        if before is None or after is None:
+            _fail("ERROR: could not derive before/after steps around promotion event")
+        points.append(
+            {
+                "promotion_index": int(pi),
+                "steps_before": int(before),
+                "steps_after": int(after),
+                "delta_steps": int(int(before) - int(after)),
+            }
+        )
+    return points
+
+
+def _iface_output_keys_from_act_json(act_json: Dict[str, Any]) -> List[str]:
+    ev = act_json.get("evidence") if isinstance(act_json.get("evidence"), dict) else {}
+    iface = ev.get("interface") if isinstance(ev.get("interface"), dict) else {}
+    out_schema = iface.get("output_schema") if isinstance(iface.get("output_schema"), dict) else {}
+    return [str(k) for k in sorted(out_schema.keys(), key=str)]
+
+
+def _negative_test_missing_logic_binding(*, seed: int) -> Dict[str, Any]:
+    ensure_bool_primitives_registered()
+    store_base = ActStore()
+
+    cand_id = "concept_v86_neg_missing_logic_binding_candidate_v0"
+    candidate_act = make_concept_act(
+        act_id=cand_id,
+        match={"goal_kinds": ["v86_logic_sum"]},
+        input_schema={"a": "str", "b": "str"},
+        output_schema={"bit": "str"},
+        validator_id="text_exact",
+        program=[
+            Instruction("CSV_GET_INPUT", {"name": "a", "out": "a"}),
+            Instruction("CSV_GET_INPUT", {"name": "b", "out": "b"}),
+            Instruction("CSV_PRIMITIVE", {"fn": "bool_xor01", "in": ["a", "b"], "out": "bit"}),
+            Instruction("CSV_RETURN", {"var": "bit"}),
+        ],
+    )
+
+    vector_specs = [
+        {"context_id": "tt00", "goal_kind": "v86_logic_sum", "inputs": {"a": "0", "b": "0"}, "expected": "0"},
+        {"context_id": "tt01", "goal_kind": "v86_logic_sum", "inputs": {"a": "0", "b": "1"}, "expected": "1"},
+        {"context_id": "tt10", "goal_kind": "v86_logic_sum", "inputs": {"a": "1", "b": "0"}, "expected": "1"},
+        {"context_id": "tt11", "goal_kind": "v86_logic_sum", "inputs": {"a": "1", "b": "1"}, "expected": "0"},
+    ]
+    mined_from = {
+        "trace_sigs": ["trace_a", "trace_b"],
+        "goal_kinds": ["v86_logic_sum"],
+        "goal_kinds_distinct": 1,
+        "candidate": {"sub_sig": "sub_sig_dummy", "subpath": ["noop"], "goal_kinds_supported": ["v86_logic_sum"]},
+    }
+
+    # Build a V85 cert (no logic_binding) that should pass V85 and fail V86 requirement.
+    cert = build_certificate_v85(
+        candidate_act=candidate_act,
+        store_base=store_base,
+        mined_from=mined_from,
+        vector_specs=vector_specs,
+        seed=int(seed),
+    )
+
+    ok, reason, details = verify_pcc_v86(candidate_act=candidate_act, certificate=cert, store_base=store_base, seed=int(seed))
+    if bool(ok):
+        _fail("ERROR: expected verify_pcc_v86 to fail for missing_logic_binding")
+    if str(reason) != "missing_logic_binding":
+        _fail(f"ERROR: expected reason=='missing_logic_binding', got={reason}")
+    return {"ok": False, "reason": str(reason), "certificate_sig": str(cert.get("certificate_sig") or "")}
+
+
+def _logic_spec_xor_raw() -> Dict[str, Any]:
+    return {
+        "vars": ["a", "b"],
+        "domain_values": ["0", "1"],
+        "expr": {"op": "xor", "args": [{"op": "var", "name": "a"}, {"op": "var", "name": "b"}]},
+        "render": {"kind": "raw01"},
+    }
+
+
+def _logic_spec_xor_prefix(prefix: str) -> Dict[str, Any]:
+    return {
+        "vars": ["a", "b"],
+        "domain_values": ["0", "1"],
+        "expr": {"op": "xor", "args": [{"op": "var", "name": "a"}, {"op": "var", "name": "b"}]},
+        "render": {"kind": "prefix01", "prefix": str(prefix)},
+    }
+
+
+def _negative_test_logic_binding_sig_mismatch(*, seed: int) -> Dict[str, Any]:
+    ensure_bool_primitives_registered()
+    store_base = ActStore()
+
+    cand_id = "concept_v86_neg_logic_binding_sig_mismatch_candidate_v0"
+    candidate_act = make_concept_act(
+        act_id=cand_id,
+        match={"goal_kinds": ["v86_logic_sum"]},
+        input_schema={"a": "str", "b": "str"},
+        output_schema={"bit": "str"},
+        validator_id="text_exact",
+        program=[
+            Instruction("CSV_GET_INPUT", {"name": "a", "out": "a"}),
+            Instruction("CSV_GET_INPUT", {"name": "b", "out": "b"}),
+            Instruction("CSV_PRIMITIVE", {"fn": "bool_xor01", "in": ["a", "b"], "out": "bit"}),
+            Instruction("CSV_RETURN", {"var": "bit"}),
+        ],
+    )
+
+    vector_specs = [
+        {"context_id": "tt00", "goal_kind": "v86_logic_sum", "inputs": {"a": "0", "b": "0"}, "expected": "0"},
+        {"context_id": "tt01", "goal_kind": "v86_logic_sum", "inputs": {"a": "0", "b": "1"}, "expected": "1"},
+        {"context_id": "tt10", "goal_kind": "v86_logic_sum", "inputs": {"a": "1", "b": "0"}, "expected": "1"},
+        {"context_id": "tt11", "goal_kind": "v86_logic_sum", "inputs": {"a": "1", "b": "1"}, "expected": "0"},
+    ]
+    mined_from = {
+        "trace_sigs": ["trace_sig_a", "trace_sig_b"],
+        "goal_kinds": ["v86_logic_sum"],
+        "goal_kinds_distinct": 1,
+        "candidate": {"sub_sig": "sub_sig_lb", "subpath": ["noop"], "goal_kinds_supported": ["v86_logic_sum"]},
+    }
+
+    cert = build_certificate_v86(
+        candidate_act=candidate_act,
+        store_base=store_base,
+        mined_from=mined_from,
+        vector_specs=vector_specs,
+        seed=int(seed),
+        logic_spec=_logic_spec_xor_raw(),
+    )
+
+    # Tamper binding_sig but keep certificate_sig consistent.
+    cert2 = json.loads(json.dumps(cert))
+    lb = cert2.get("logic_binding")
+    if not isinstance(lb, dict):
+        _fail("ERROR: missing logic_binding in built certificate")
+    lb["binding_sig"] = "0" * 64
+    cert2["logic_binding"] = dict(lb)
+    cert2["certificate_sig"] = certificate_sig_v2(cert2)
+
+    ok, reason, details = verify_pcc_v86(candidate_act=candidate_act, certificate=cert2, store_base=store_base, seed=int(seed))
+    if bool(ok):
+        _fail("ERROR: expected verify_pcc_v86 to fail for logic_binding_sig_mismatch")
+    if str(reason) != "logic_binding_sig_mismatch":
+        _fail(f"ERROR: expected reason=='logic_binding_sig_mismatch', got={reason}")
+    if not isinstance(details, dict):
+        _fail("ERROR: expected details dict for logic_binding_sig_mismatch")
+    return {"ok": False, "reason": str(reason), "want": str(details.get("want") or ""), "got": str(details.get("got") or "")}
+
+
+def _negative_test_logic_vector_coverage_incomplete(*, seed: int) -> Dict[str, Any]:
+    ensure_bool_primitives_registered()
+    store_base = ActStore()
+
+    cand_id = "concept_v86_neg_logic_vector_coverage_incomplete_candidate_v0"
+    candidate_act = make_concept_act(
+        act_id=cand_id,
+        match={"goal_kinds": ["v86_logic_sum"]},
+        input_schema={"a": "str", "b": "str"},
+        output_schema={"bit": "str"},
+        validator_id="text_exact",
+        program=[
+            Instruction("CSV_GET_INPUT", {"name": "a", "out": "a"}),
+            Instruction("CSV_GET_INPUT", {"name": "b", "out": "b"}),
+            Instruction("CSV_PRIMITIVE", {"fn": "bool_xor01", "in": ["a", "b"], "out": "bit"}),
+            Instruction("CSV_RETURN", {"var": "bit"}),
+        ],
+    )
+
+    # Omit one assignment (tt11).
+    vector_specs = [
+        {"context_id": "tt00", "goal_kind": "v86_logic_sum", "inputs": {"a": "0", "b": "0"}, "expected": "0"},
+        {"context_id": "tt01", "goal_kind": "v86_logic_sum", "inputs": {"a": "0", "b": "1"}, "expected": "1"},
+        {"context_id": "tt10", "goal_kind": "v86_logic_sum", "inputs": {"a": "1", "b": "0"}, "expected": "1"},
+    ]
+    mined_from = {
+        "trace_sigs": ["trace_sig_a", "trace_sig_b"],
+        "goal_kinds": ["v86_logic_sum"],
+        "goal_kinds_distinct": 1,
+        "candidate": {"sub_sig": "sub_sig_cov", "subpath": ["noop"], "goal_kinds_supported": ["v86_logic_sum"]},
+    }
+
+    cert = build_certificate_v86(
+        candidate_act=candidate_act,
+        store_base=store_base,
+        mined_from=mined_from,
+        vector_specs=vector_specs,
+        seed=int(seed),
+        logic_spec=_logic_spec_xor_raw(),
+    )
+
+    ok, reason, details = verify_pcc_v86(candidate_act=candidate_act, certificate=cert, store_base=store_base, seed=int(seed))
+    if bool(ok):
+        _fail("ERROR: expected verify_pcc_v86 to fail for logic_vector_coverage_incomplete")
+    if str(reason) != "logic_vector_coverage_incomplete":
+        _fail(f"ERROR: expected reason=='logic_vector_coverage_incomplete', got={reason}")
+    if not isinstance(details, dict):
+        _fail("ERROR: expected details dict for logic_vector_coverage_incomplete")
+    if int(details.get("missing_total", 0) or 0) <= 0:
+        _fail("ERROR: expected missing_total > 0 for logic_vector_coverage_incomplete")
+    return {"ok": False, "reason": str(reason), "missing_total": int(details.get("missing_total", 0) or 0)}
+
+
+def _negative_test_logic_expected_mismatch(*, seed: int) -> Dict[str, Any]:
+    ensure_bool_primitives_registered()
+    store_base = ActStore()
+
+    cand_id = "concept_v86_neg_logic_expected_mismatch_candidate_v0"
+    candidate_act = make_concept_act(
+        act_id=cand_id,
+        match={"goal_kinds": ["v86_logic_sum"]},
+        input_schema={"a": "str", "b": "str"},
+        output_schema={"bit": "str"},
+        validator_id="text_exact",
+        program=[
+            Instruction("CSV_GET_INPUT", {"name": "a", "out": "a"}),
+            Instruction("CSV_GET_INPUT", {"name": "b", "out": "b"}),
+            Instruction("CSV_PRIMITIVE", {"fn": "bool_xor01", "in": ["a", "b"], "out": "bit"}),
+            Instruction("CSV_RETURN", {"var": "bit"}),
+        ],
+    )
+
+    # Correct XOR vectors (so V85 passes), but bind logic expr as AND (so V86 fails).
+    vector_specs = [
+        {"context_id": "tt00", "goal_kind": "v86_logic_sum", "inputs": {"a": "0", "b": "0"}, "expected": "0"},
+        {"context_id": "tt01", "goal_kind": "v86_logic_sum", "inputs": {"a": "0", "b": "1"}, "expected": "1"},
+        {"context_id": "tt10", "goal_kind": "v86_logic_sum", "inputs": {"a": "1", "b": "0"}, "expected": "1"},
+        {"context_id": "tt11", "goal_kind": "v86_logic_sum", "inputs": {"a": "1", "b": "1"}, "expected": "0"},
+    ]
+    mined_from = {
+        "trace_sigs": ["trace_sig_a", "trace_sig_b"],
+        "goal_kinds": ["v86_logic_sum"],
+        "goal_kinds_distinct": 1,
+        "candidate": {"sub_sig": "sub_sig_exp", "subpath": ["noop"], "goal_kinds_supported": ["v86_logic_sum"]},
+    }
+
+    logic_spec_and = {
+        "vars": ["a", "b"],
+        "domain_values": ["0", "1"],
+        "expr": {"op": "and", "args": [{"op": "var", "name": "a"}, {"op": "var", "name": "b"}]},
+        "render": {"kind": "raw01"},
+    }
+
+    cert = build_certificate_v86(
+        candidate_act=candidate_act,
+        store_base=store_base,
+        mined_from=mined_from,
+        vector_specs=vector_specs,
+        seed=int(seed),
+        logic_spec=logic_spec_and,
+    )
+
+    ok, reason, details = verify_pcc_v86(candidate_act=candidate_act, certificate=cert, store_base=store_base, seed=int(seed))
+    if bool(ok):
+        _fail("ERROR: expected verify_pcc_v86 to fail for logic_expected_mismatch")
+    if str(reason) != "logic_expected_mismatch":
+        _fail(f"ERROR: expected reason=='logic_expected_mismatch', got={reason}")
+    if not isinstance(details, dict):
+        _fail("ERROR: expected details dict for logic_expected_mismatch")
+    if not str(details.get("want") or "") or not str(details.get("got") or ""):
+        _fail("ERROR: expected want/got in details for logic_expected_mismatch")
+    return {"ok": False, "reason": str(reason), "inputs": details.get("inputs"), "want": str(details.get("want") or ""), "got": str(details.get("got") or "")}
+
+
+def _xor01(a: str, b: str) -> str:
+    aa = 1 if str(a) == "1" else 0
+    bb = 1 if str(b) == "1" else 0
+    return "1" if (aa ^ bb) else "0"
+
+
+def smoke_try(*, out_dir: str, seed: int) -> Dict[str, Any]:
+    ensure_bool_primitives_registered()
+    store = ActStore()
+
+    # Base concepts (2 goal_kinds with different prefixes to force core promotion first).
+    normalize_a_id = "concept_v86_normalize_a_v0"
+    normalize_b_id = "concept_v86_normalize_b_v0"
+    xor_id = "concept_v86_xor_na_nb_v0"
+    fmt_sum_id = "concept_v86_fmt_bool_sum_v0"
+    fmt_total_id = "concept_v86_fmt_bool_total_v0"
+
+    store.add(
+        make_concept_act(
+            act_id=normalize_a_id,
+            match={},
+            input_schema={"a": "str"},
+            output_schema={"na": "str"},
+            validator_id="text_exact",
+            program=[
+                Instruction("CSV_GET_INPUT", {"name": "a", "out": "a"}),
+                Instruction("CSV_RETURN", {"var": "a"}),
+            ],
+        )
+    )
+    store.add(
+        make_concept_act(
+            act_id=normalize_b_id,
+            match={},
+            input_schema={"b": "str"},
+            output_schema={"nb": "str"},
+            validator_id="text_exact",
+            program=[
+                Instruction("CSV_GET_INPUT", {"name": "b", "out": "b"}),
+                Instruction("CSV_RETURN", {"var": "b"}),
+            ],
+        )
+    )
+    store.add(
+        make_concept_act(
+            act_id=xor_id,
+            match={},
+            input_schema={"na": "str", "nb": "str"},
+            output_schema={"bit": "str"},
+            validator_id="text_exact",
+            program=[
+                Instruction("CSV_GET_INPUT", {"name": "na", "out": "na"}),
+                Instruction("CSV_GET_INPUT", {"name": "nb", "out": "nb"}),
+                Instruction("CSV_PRIMITIVE", {"fn": "bool_xor01", "in": ["na", "nb"], "out": "bit"}),
+                Instruction("CSV_RETURN", {"var": "bit"}),
+            ],
+        )
+    )
+    store.add(
+        make_concept_act(
+            act_id=fmt_sum_id,
+            match={"goal_kinds": ["v86_logic_sum"]},
+            input_schema={"bit": "str"},
+            output_schema={"out": "str"},
+            validator_id="text_exact",
+            program=[
+                Instruction("CSV_GET_INPUT", {"name": "bit", "out": "bit"}),
+                Instruction("CSV_CONST", {"out": "prefix", "value": "BOOL="}),
+                Instruction("CSV_PRIMITIVE", {"fn": "str_concat", "in": ["prefix", "bit"], "out": "out"}),
+                Instruction("CSV_RETURN", {"var": "out"}),
+            ],
+        )
+    )
+    store.add(
+        make_concept_act(
+            act_id=fmt_total_id,
+            match={"goal_kinds": ["v86_logic_total"]},
+            input_schema={"bit": "str"},
+            output_schema={"out": "str"},
+            validator_id="text_exact",
+            program=[
+                Instruction("CSV_GET_INPUT", {"name": "bit", "out": "bit"}),
+                Instruction("CSV_CONST", {"out": "prefix", "value": "TBOOL="}),
+                Instruction("CSV_PRIMITIVE", {"fn": "str_concat", "in": ["prefix", "bit"], "out": "out"}),
+                Instruction("CSV_RETURN", {"var": "out"}),
+            ],
+        )
+    )
+
+    # V86 negatives.
+    neg_missing = _negative_test_missing_logic_binding(seed=int(seed))
+    neg_sig = _negative_test_logic_binding_sig_mismatch(seed=int(seed))
+    neg_cov = _negative_test_logic_vector_coverage_incomplete(seed=int(seed))
+    neg_exp = _negative_test_logic_expected_mismatch(seed=int(seed))
+
+    # Goals: first two force diversity, then two sum to enable second promotion.
+    goals_specs = [
+        {"created_step": 0, "goal_kind": "v86_logic_sum", "a": "0", "b": "1", "prefix": "BOOL="},
+        {"created_step": 1, "goal_kind": "v86_logic_total", "a": "1", "b": "0", "prefix": "TBOOL="},
+        {"created_step": 2, "goal_kind": "v86_logic_sum", "a": "0", "b": "0", "prefix": "BOOL="},
+        {"created_step": 3, "goal_kind": "v86_logic_sum", "a": "1", "b": "1", "prefix": "BOOL="},
+        {"created_step": 4, "goal_kind": "v86_logic_sum", "a": "1", "b": "0", "prefix": "BOOL="},
+        {"created_step": 5, "goal_kind": "v86_logic_total", "a": "0", "b": "0", "prefix": "TBOOL="},
+    ]
+    for gs in goals_specs:
+        bit = _xor01(str(gs["a"]), str(gs["b"]))
+        expected = f"{gs['prefix']}{bit}"
+        # create goal_v75 act via helper already in repo
+        from atos_core.goal_act_v75 import make_goal_act_v75
+
+        ga = make_goal_act_v75(
+            goal_kind=str(gs["goal_kind"]),
+            bindings={"a": str(gs["a"]), "b": str(gs["b"])},
+            output_key="out",
+            expected=str(expected),
+            validator_id="text_exact",
+            created_step=int(gs["created_step"]),
+        )
+        store.add(ga)
+
+    loop_res = run_goals_v86(
+        store=store,
+        seed=int(seed),
+        out_dir=out_dir,
+        max_rounds=10,
+        max_goals_per_round=1,
+        enable_promotion=True,
+        promotion_budget_bits=2048,
+        promotion_min_traces=2,
+        promotion_top_k=8,
+        max_promotions_per_run=2,
+        promotion_kind_diversity_min=2,
+    )
+
+    if int(loop_res.get("goals_total", 0) or 0) != 6:
+        _fail(f"ERROR: expected goals_total==6, got={loop_res.get('goals_total')}")
+    if int(loop_res.get("goals_satisfied", 0) or 0) != 6:
+        _fail(f"ERROR: expected goals_satisfied==6, got={loop_res.get('goals_satisfied')}")
+    if int(loop_res.get("promoted_total", 0) or 0) != 2:
+        _fail(f"ERROR: expected promoted_total==2, got={loop_res.get('promoted_total')}")
+
+    budget_bits = int(loop_res.get("budget_bits", 0) or 0)
+    used_bits = int(loop_res.get("used_bits", 0) or 0)
+    if budget_bits != 2048:
+        _fail(f"ERROR: expected budget_bits==2048, got={budget_bits}")
+    if used_bits != 2048:
+        _fail(f"ERROR: expected used_bits==2048, got={used_bits}")
+
+    events_path = os.path.join(out_dir, "goals_v86_events.jsonl")
+    traces_path = os.path.join(out_dir, "traces_v86.json")
+    mined_path = os.path.join(out_dir, "mined_candidates_v86.json")
+    promos_path = os.path.join(out_dir, "promotion", "v86_promotions.jsonl")
+    curve_path = os.path.join(out_dir, "compression_curve.json")
+    cand0_act = os.path.join(out_dir, "candidates", "candidate_000_act.json")
+    cand0_cert = os.path.join(out_dir, "candidates", "candidate_000_certificate_v2.json")
+    cand1_act = os.path.join(out_dir, "candidates", "candidate_001_act.json")
+    cand1_cert = os.path.join(out_dir, "candidates", "candidate_001_certificate_v2.json")
+
+    for p in [events_path, traces_path, mined_path, promos_path, curve_path, cand0_act, cand0_cert, cand1_act, cand1_cert]:
+        if not os.path.exists(p):
+            _fail(f"ERROR: missing required artifact: {p}")
+
+    events = _read_jsonl(events_path)
+    promo_events = [r for r in events if isinstance(r, dict) and str(r.get("event_kind") or "") == "promotion_attempt" and str(r.get("decision") or "") == "promoted"]
+    if len(promo_events) != 2:
+        _fail(f"ERROR: expected 2 promoted promotion_attempt events, got={len(promo_events)}")
+
+    points = _points_from_events(events)
+    if len(points) != 2:
+        _fail(f"ERROR: expected 2 compression points, got={points}")
+    steps_after = [int(p.get("steps_after", 0) or 0) for p in points if isinstance(p, dict)]
+    if steps_after != [2, 1]:
+        _fail(f"ERROR: expected curve steps_after [2,1], got={steps_after}")
+
+    curve = json.load(open(curve_path, "r", encoding="utf-8"))
+    curve_points = curve.get("points") if isinstance(curve.get("points"), list) else []
+    if curve_points != points:
+        _fail("ERROR: compression_curve.json points mismatch vs derived points")
+
+    cand0 = json.load(open(cand0_act, "r", encoding="utf-8"))
+    cand1 = json.load(open(cand1_act, "r", encoding="utf-8"))
+    out_keys0 = _iface_output_keys_from_act_json(cand0 if isinstance(cand0, dict) else {})
+    out_keys1 = _iface_output_keys_from_act_json(cand1 if isinstance(cand1, dict) else {})
+    if "bit" not in out_keys0 or "out" in out_keys0:
+        _fail(f"ERROR: candidate_000_act output_schema must contain 'bit' and NOT 'out', got={out_keys0}")
+    if "out" not in out_keys1:
+        _fail(f"ERROR: candidate_001_act output_schema must contain 'out', got={out_keys1}")
+
+    cert0 = json.load(open(cand0_cert, "r", encoding="utf-8"))
+    cert1 = json.load(open(cand1_cert, "r", encoding="utf-8"))
+    lb0 = cert0.get("logic_binding") if isinstance(cert0.get("logic_binding"), dict) else None
+    lb1 = cert1.get("logic_binding") if isinstance(cert1.get("logic_binding"), dict) else None
+    if not isinstance(lb0, dict) or not str(lb0.get("truth_table_sha256") or ""):
+        _fail("ERROR: candidate_000_certificate_v2.json missing logic_binding/truth_table_sha256")
+    if not isinstance(lb1, dict) or not str(lb1.get("truth_table_sha256") or ""):
+        _fail("ERROR: candidate_001_certificate_v2.json missing logic_binding/truth_table_sha256")
+    if str((lb0.get("render") or {}).get("kind") or "") != "raw01":
+        _fail("ERROR: expected candidate_000 logic_binding.render.kind == raw01")
+    if str((lb1.get("render") or {}).get("kind") or "") != "prefix01":
+        _fail("ERROR: expected candidate_001 logic_binding.render.kind == prefix01")
+
+    cert_sigs: List[str] = [str(r.get("certificate_sig") or "") for r in promo_events]
+    if len(cert_sigs) != 2 or any(not s for s in cert_sigs):
+        _fail("ERROR: missing certificate_sig(s) in promotion events")
+
+    artifacts = {
+        "goals_v86_events_jsonl_sha256": sha256_file(events_path),
+        "traces_v86_json_sha256": sha256_file(traces_path),
+        "mined_candidates_v86_json_sha256": sha256_file(mined_path),
+        "v86_promotions_jsonl_sha256": sha256_file(promos_path),
+        "compression_curve_json_sha256": sha256_file(curve_path),
+        "candidate_000_act_json_sha256": sha256_file(cand0_act),
+        "candidate_000_certificate_v2_json_sha256": sha256_file(cand0_cert),
+        "candidate_001_act_json_sha256": sha256_file(cand1_act),
+        "candidate_001_certificate_v2_json_sha256": sha256_file(cand1_cert),
+    }
+
+    return {
+        "schema_version": 1,
+        "seed": int(seed),
+        "negative_missing_logic_binding": dict(neg_missing),
+        "negative_logic_binding_sig_mismatch": dict(neg_sig),
+        "negative_logic_vector_coverage_incomplete": dict(neg_cov),
+        "negative_logic_expected_mismatch": dict(neg_exp),
+        "goals_total": int(loop_res.get("goals_total", 0) or 0),
+        "goals_satisfied": int(loop_res.get("goals_satisfied", 0) or 0),
+        "promoted_total": int(loop_res.get("promoted_total", 0) or 0),
+        "budget_bits": int(budget_bits),
+        "used_bits": int(used_bits),
+        "certificate_sigs": list(cert_sigs),
+        "compression_curve_points": list(points),
+        "artifacts": dict(artifacts),
+    }
+
+
+def main() -> None:
+    ap = argparse.ArgumentParser()
+    ap.add_argument("--out_base", default="results/run_smoke_goal_act_agent_loop_v86_pcc_logic_bound")
+    ap.add_argument("--seed", type=int, default=0)
+    args = ap.parse_args()
+
+    out_base = str(args.out_base)
+    seed = int(args.seed)
+
+    results: Dict[str, Any] = {"seed": seed, "tries": {}}
+    sigs: List[Tuple[Tuple[str, ...], Tuple[int, ...], int, str, str, str, str, str]] = []
+    summary_shas: List[str] = []
+
+    for t in (1, 2):
+        out_dir = f"{out_base}_try{t}"
+        ensure_absent(out_dir)
+
+        ev = smoke_try(out_dir=out_dir, seed=seed)
+        eval_path = os.path.join(out_dir, "eval.json")
+        eval_sha = write_json(eval_path, ev)
+
+        points = ev.get("compression_curve_points") if isinstance(ev.get("compression_curve_points"), list) else []
+        pts_sig = tuple(int(p.get("steps_after", 0) or 0) for p in points if isinstance(p, dict))
+        certs = tuple(str(x) for x in (ev.get("certificate_sigs") or []) if str(x))
+        r_a = str(((ev.get("negative_missing_logic_binding") or {}) if isinstance(ev.get("negative_missing_logic_binding"), dict) else {}).get("reason") or "")
+        r_b = str(((ev.get("negative_logic_binding_sig_mismatch") or {}) if isinstance(ev.get("negative_logic_binding_sig_mismatch"), dict) else {}).get("reason") or "")
+        r_c = str(((ev.get("negative_logic_vector_coverage_incomplete") or {}) if isinstance(ev.get("negative_logic_vector_coverage_incomplete"), dict) else {}).get("reason") or "")
+        r_d = str(((ev.get("negative_logic_expected_mismatch") or {}) if isinstance(ev.get("negative_logic_expected_mismatch"), dict) else {}).get("reason") or "")
+
+        core = {
+            "seed": int(seed),
+            "negative_missing_logic_binding_reason": str(r_a),
+            "negative_logic_binding_sig_mismatch_reason": str(r_b),
+            "negative_logic_vector_coverage_incomplete_reason": str(r_c),
+            "negative_logic_expected_mismatch_reason": str(r_d),
+            "promoted_total": int(ev.get("promoted_total", 0) or 0),
+            "budget_bits": int(ev.get("budget_bits", 0) or 0),
+            "used_bits": int(ev.get("used_bits", 0) or 0),
+            "certificate_sigs": list(certs),
+            "compression_curve_points": list(points),
+            "sha256_eval_json": str(eval_sha),
+        }
+        summary_sha = sha256_text(canonical_json_dumps(core))
+        smoke = {"summary": core, "determinism": {"summary_sha256": str(summary_sha)}}
+        smoke_path = os.path.join(out_dir, "smoke_summary.json")
+        smoke_sha = write_json(smoke_path, smoke)
+
+        sigs.append((certs, pts_sig, int(ev.get("promoted_total", 0) or 0), str(eval_sha), str(r_a), str(r_b), str(r_c), str(r_d)))
+        summary_shas.append(str(summary_sha))
+
+        results["tries"][f"try{t}"] = {
+            "out_dir": out_dir,
+            "eval_json": {"path": eval_path, "sha256": eval_sha},
+            "smoke_summary_json": {"path": smoke_path, "sha256": smoke_sha},
+            "summary_sha256": summary_sha,
+        }
+
+    determinism_ok = bool(len(sigs) == 2 and sigs[0] == sigs[1] and len(summary_shas) == 2 and summary_shas[0] == summary_shas[1])
+    if not determinism_ok:
+        _fail(f"ERROR: determinism mismatch: sigs={sigs} summary_shas={summary_shas}")
+    results["determinism"] = {
+        "ok": True,
+        "summary_sha256": summary_shas[0],
+        "certificate_sigs": list(sigs[0][0]),
+        "curve_steps_after": list(sigs[0][1]),
+        "promoted_total": sigs[0][2],
+        "sha256_eval_json": sigs[0][3],
+        "negative_missing_logic_binding_reason": sigs[0][4],
+        "negative_logic_binding_sig_mismatch_reason": sigs[0][5],
+        "negative_logic_vector_coverage_incomplete_reason": sigs[0][6],
+        "negative_logic_expected_mismatch_reason": sigs[0][7],
+    }
+    print(json.dumps(results, ensure_ascii=False, indent=2, sort_keys=True))
+
+
+if __name__ == "__main__":
+    main()
